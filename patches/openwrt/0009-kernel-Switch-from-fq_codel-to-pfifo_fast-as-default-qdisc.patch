From: Sven Eckelmann <sven@narfation.org>
Date: Sat, 1 Oct 2016 19:51:25 +0200
Subject: kernel: Switch from fq_codel to pfifo_fast as default qdisc

fq_codel can use a lot of memory for small devices used for gluon. This
problem was avoided in Linux 4.4 by adding a memory_limit. But backporting
this requires many extra patches to restructure fq_codel. This makes it
unfeasible until gluon switched from OpenWrt CC to LEDE.

Bug-gluon: https://github.com/freifunk-gluon/gluon/issues/753

diff --git a/package/kernel/mac80211/patches/914-mac80211-reduce_txqueuelen.patch b/package/kernel/mac80211/patches/914-mac80211-reduce_txqueuelen.patch
new file mode 100644
index 0000000000000000000000000000000000000000..f274861cb06c3f5978eaf4148891e0c054055beb
--- /dev/null
+++ b/package/kernel/mac80211/patches/914-mac80211-reduce_txqueuelen.patch
@@ -0,0 +1,10 @@
+--- a/net/mac80211/iface.c
++++ b/net/mac80211/iface.c
+@@ -995,6 +995,7 @@ static const struct net_device_ops ieee8
+ static void ieee80211_if_setup(struct net_device *dev)
+ {
+ 	ether_setup(dev);
++	dev->tx_queue_len = 32 * 8;
+ 	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+ 	netdev_attach_ops(dev, &ieee80211_dataif_ops);
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
diff --git a/target/linux/generic/hack-4.14/661-use_fq_codel_by_default.patch b/target/linux/generic/hack-4.14/661-use_fq_codel_by_default.patch
deleted file mode 100644
index 7c724c0af71af40fefb9597eb09e37632982b50e..0000000000000000000000000000000000000000
--- a/target/linux/generic/hack-4.14/661-use_fq_codel_by_default.patch
+++ /dev/null
@@ -1,94 +0,0 @@
-From 1d418f7e88035ed7a94073f6354246c66e9193e9 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:22:58 +0200
-Subject: fq_codel: switch default qdisc from pfifo_fast to fq_codel and remove pfifo_fast
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/net/sch_generic.h | 3 ++-
- net/sched/Kconfig         | 3 ++-
- net/sched/sch_api.c       | 2 +-
- net/sched/sch_fq_codel.c  | 3 ++-
- net/sched/sch_generic.c   | 4 ++--
- 5 files changed, 9 insertions(+), 6 deletions(-)
-
---- a/include/net/sch_generic.h
-+++ b/include/net/sch_generic.h
-@@ -368,12 +368,13 @@ extern struct Qdisc_ops noop_qdisc_ops;
- extern struct Qdisc_ops pfifo_fast_ops;
- extern struct Qdisc_ops mq_qdisc_ops;
- extern struct Qdisc_ops noqueue_qdisc_ops;
-+extern struct Qdisc_ops fq_codel_qdisc_ops;
- extern const struct Qdisc_ops *default_qdisc_ops;
- static inline const struct Qdisc_ops *
- get_default_qdisc_ops(const struct net_device *dev, int ntx)
- {
- 	return ntx < dev->real_num_tx_queues ?
--			default_qdisc_ops : &pfifo_fast_ops;
-+			default_qdisc_ops : &fq_codel_qdisc_ops;
- }
- 
- struct Qdisc_class_common {
---- a/net/sched/Kconfig
-+++ b/net/sched/Kconfig
-@@ -3,8 +3,9 @@
- # 
- 
- menuconfig NET_SCHED
--	bool "QoS and/or fair queueing"
-+	def_bool y
- 	select NET_SCH_FIFO
-+	select NET_SCH_FQ_CODEL
- 	---help---
- 	  When the kernel has several packets to send out over a network
- 	  device, it has to decide which ones to send first, which ones to
---- a/net/sched/sch_api.c
-+++ b/net/sched/sch_api.c
-@@ -2014,7 +2014,7 @@ static int __init pktsched_init(void)
- 		return err;
- 	}
- 
--	register_qdisc(&pfifo_fast_ops);
-+	register_qdisc(&fq_codel_qdisc_ops);
- 	register_qdisc(&pfifo_qdisc_ops);
- 	register_qdisc(&bfifo_qdisc_ops);
- 	register_qdisc(&pfifo_head_drop_qdisc_ops);
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -700,7 +700,7 @@ static const struct Qdisc_class_ops fq_c
- 	.walk		=	fq_codel_walk,
- };
- 
--static struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
-+struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
- 	.cl_ops		=	&fq_codel_class_ops,
- 	.id		=	"fq_codel",
- 	.priv_size	=	sizeof(struct fq_codel_sched_data),
-@@ -715,6 +715,7 @@ static struct Qdisc_ops fq_codel_qdisc_o
- 	.dump_stats =	fq_codel_dump_stats,
- 	.owner		=	THIS_MODULE,
- };
-+EXPORT_SYMBOL(fq_codel_qdisc_ops);
- 
- static int __init fq_codel_module_init(void)
- {
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -32,7 +32,7 @@
- #include <trace/events/qdisc.h>
- 
- /* Qdisc to use by default */
--const struct Qdisc_ops *default_qdisc_ops = &pfifo_fast_ops;
-+const struct Qdisc_ops *default_qdisc_ops = &fq_codel_qdisc_ops;
- EXPORT_SYMBOL(default_qdisc_ops);
- 
- /* Main transmission queue. */
-@@ -760,7 +760,7 @@ static void attach_one_default_qdisc(str
- 				     void *_unused)
- {
- 	struct Qdisc *qdisc;
--	const struct Qdisc_ops *ops = default_qdisc_ops;
-+	const struct Qdisc_ops *ops = &fq_codel_qdisc_ops;
- 
- 	if (dev->priv_flags & IFF_NO_QUEUE)
- 		ops = &noqueue_qdisc_ops;
diff --git a/target/linux/generic/hack-4.14/662-remove_pfifo_fast.patch b/target/linux/generic/hack-4.14/662-remove_pfifo_fast.patch
deleted file mode 100644
index 7b6e38da2934239e012ad3594c892b807c3a2e67..0000000000000000000000000000000000000000
--- a/target/linux/generic/hack-4.14/662-remove_pfifo_fast.patch
+++ /dev/null
@@ -1,159 +0,0 @@
-From b531d492d5ef1cf9dba0f4888eb5fd8624a6d762 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:23:42 +0200
-Subject: net: sched: switch default qdisc from pfifo_fast to fq_codel and remove pfifo_fast
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/sched/sch_generic.c | 140 ------------------------------------------------
- 1 file changed, 140 deletions(-)
-
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -453,146 +453,6 @@ struct Qdisc_ops noqueue_qdisc_ops __rea
- 	.owner		=	THIS_MODULE,
- };
- 
--static const u8 prio2band[TC_PRIO_MAX + 1] = {
--	1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1
--};
--
--/* 3-band FIFO queue: old style, but should be a bit faster than
--   generic prio+fifo combination.
-- */
--
--#define PFIFO_FAST_BANDS 3
--
--/*
-- * Private data for a pfifo_fast scheduler containing:
-- * 	- queues for the three band
-- * 	- bitmap indicating which of the bands contain skbs
-- */
--struct pfifo_fast_priv {
--	u32 bitmap;
--	struct qdisc_skb_head q[PFIFO_FAST_BANDS];
--};
--
--/*
-- * Convert a bitmap to the first band number where an skb is queued, where:
-- * 	bitmap=0 means there are no skbs on any band.
-- * 	bitmap=1 means there is an skb on band 0.
-- *	bitmap=7 means there are skbs on all 3 bands, etc.
-- */
--static const int bitmap2band[] = {-1, 0, 1, 0, 2, 0, 1, 0};
--
--static inline struct qdisc_skb_head *band2list(struct pfifo_fast_priv *priv,
--					     int band)
--{
--	return priv->q + band;
--}
--
--static int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc *qdisc,
--			      struct sk_buff **to_free)
--{
--	if (qdisc->q.qlen < qdisc_dev(qdisc)->tx_queue_len) {
--		int band = prio2band[skb->priority & TC_PRIO_MAX];
--		struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--		struct qdisc_skb_head *list = band2list(priv, band);
--
--		priv->bitmap |= (1 << band);
--		qdisc->q.qlen++;
--		return __qdisc_enqueue_tail(skb, qdisc, list);
--	}
--
--	return qdisc_drop(skb, qdisc, to_free);
--}
--
--static struct sk_buff *pfifo_fast_dequeue(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (likely(band >= 0)) {
--		struct qdisc_skb_head *qh = band2list(priv, band);
--		struct sk_buff *skb = __qdisc_dequeue_head(qh);
--
--		if (likely(skb != NULL)) {
--			qdisc_qstats_backlog_dec(qdisc, skb);
--			qdisc_bstats_update(qdisc, skb);
--		}
--
--		qdisc->q.qlen--;
--		if (qh->qlen == 0)
--			priv->bitmap &= ~(1 << band);
--
--		return skb;
--	}
--
--	return NULL;
--}
--
--static struct sk_buff *pfifo_fast_peek(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (band >= 0) {
--		struct qdisc_skb_head *qh = band2list(priv, band);
--
--		return qh->head;
--	}
--
--	return NULL;
--}
--
--static void pfifo_fast_reset(struct Qdisc *qdisc)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		__qdisc_reset_queue(band2list(priv, prio));
--
--	priv->bitmap = 0;
--	qdisc->qstats.backlog = 0;
--	qdisc->q.qlen = 0;
--}
--
--static int pfifo_fast_dump(struct Qdisc *qdisc, struct sk_buff *skb)
--{
--	struct tc_prio_qopt opt = { .bands = PFIFO_FAST_BANDS };
--
--	memcpy(&opt.priomap, prio2band, TC_PRIO_MAX + 1);
--	if (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))
--		goto nla_put_failure;
--	return skb->len;
--
--nla_put_failure:
--	return -1;
--}
--
--static int pfifo_fast_init(struct Qdisc *qdisc, struct nlattr *opt)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		qdisc_skb_head_init(band2list(priv, prio));
--
--	/* Can by-pass the queue discipline */
--	qdisc->flags |= TCQ_F_CAN_BYPASS;
--	return 0;
--}
--
--struct Qdisc_ops pfifo_fast_ops __read_mostly = {
--	.id		=	"pfifo_fast",
--	.priv_size	=	sizeof(struct pfifo_fast_priv),
--	.enqueue	=	pfifo_fast_enqueue,
--	.dequeue	=	pfifo_fast_dequeue,
--	.peek		=	pfifo_fast_peek,
--	.init		=	pfifo_fast_init,
--	.reset		=	pfifo_fast_reset,
--	.dump		=	pfifo_fast_dump,
--	.owner		=	THIS_MODULE,
--};
--EXPORT_SYMBOL(pfifo_fast_ops);
--
- static struct lock_class_key qdisc_tx_busylock;
- static struct lock_class_key qdisc_running_key;
- 
diff --git a/target/linux/generic/hack-4.9/661-use_fq_codel_by_default.patch b/target/linux/generic/hack-4.9/661-use_fq_codel_by_default.patch
deleted file mode 100644
index 981170cbb1e2b868d9a0c1626fd12c6f4a9aec68..0000000000000000000000000000000000000000
--- a/target/linux/generic/hack-4.9/661-use_fq_codel_by_default.patch
+++ /dev/null
@@ -1,94 +0,0 @@
-From 1d418f7e88035ed7a94073f6354246c66e9193e9 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:22:58 +0200
-Subject: fq_codel: switch default qdisc from pfifo_fast to fq_codel and remove pfifo_fast
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/net/sch_generic.h | 3 ++-
- net/sched/Kconfig         | 3 ++-
- net/sched/sch_api.c       | 2 +-
- net/sched/sch_fq_codel.c  | 3 ++-
- net/sched/sch_generic.c   | 4 ++--
- 5 files changed, 9 insertions(+), 6 deletions(-)
-
---- a/include/net/sch_generic.h
-+++ b/include/net/sch_generic.h
-@@ -339,12 +339,13 @@ extern struct Qdisc_ops noop_qdisc_ops;
- extern struct Qdisc_ops pfifo_fast_ops;
- extern struct Qdisc_ops mq_qdisc_ops;
- extern struct Qdisc_ops noqueue_qdisc_ops;
-+extern struct Qdisc_ops fq_codel_qdisc_ops;
- extern const struct Qdisc_ops *default_qdisc_ops;
- static inline const struct Qdisc_ops *
- get_default_qdisc_ops(const struct net_device *dev, int ntx)
- {
- 	return ntx < dev->real_num_tx_queues ?
--			default_qdisc_ops : &pfifo_fast_ops;
-+			default_qdisc_ops : &fq_codel_qdisc_ops;
- }
- 
- struct Qdisc_class_common {
---- a/net/sched/Kconfig
-+++ b/net/sched/Kconfig
-@@ -3,8 +3,9 @@
- # 
- 
- menuconfig NET_SCHED
--	bool "QoS and/or fair queueing"
-+	def_bool y
- 	select NET_SCH_FIFO
-+	select NET_SCH_FQ_CODEL
- 	---help---
- 	  When the kernel has several packets to send out over a network
- 	  device, it has to decide which ones to send first, which ones to
---- a/net/sched/sch_api.c
-+++ b/net/sched/sch_api.c
-@@ -1978,7 +1978,7 @@ static int __init pktsched_init(void)
- 		return err;
- 	}
- 
--	register_qdisc(&pfifo_fast_ops);
-+	register_qdisc(&fq_codel_qdisc_ops);
- 	register_qdisc(&pfifo_qdisc_ops);
- 	register_qdisc(&bfifo_qdisc_ops);
- 	register_qdisc(&pfifo_head_drop_qdisc_ops);
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -715,7 +715,7 @@ static const struct Qdisc_class_ops fq_c
- 	.walk		=	fq_codel_walk,
- };
- 
--static struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
-+struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
- 	.cl_ops		=	&fq_codel_class_ops,
- 	.id		=	"fq_codel",
- 	.priv_size	=	sizeof(struct fq_codel_sched_data),
-@@ -730,6 +730,7 @@ static struct Qdisc_ops fq_codel_qdisc_o
- 	.dump_stats =	fq_codel_dump_stats,
- 	.owner		=	THIS_MODULE,
- };
-+EXPORT_SYMBOL(fq_codel_qdisc_ops);
- 
- static int __init fq_codel_module_init(void)
- {
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -31,7 +31,7 @@
- #include <net/dst.h>
- 
- /* Qdisc to use by default */
--const struct Qdisc_ops *default_qdisc_ops = &pfifo_fast_ops;
-+const struct Qdisc_ops *default_qdisc_ops = &fq_codel_qdisc_ops;
- EXPORT_SYMBOL(default_qdisc_ops);
- 
- /* Main transmission queue. */
-@@ -760,7 +760,7 @@ static void attach_one_default_qdisc(str
- 				     void *_unused)
- {
- 	struct Qdisc *qdisc;
--	const struct Qdisc_ops *ops = default_qdisc_ops;
-+	const struct Qdisc_ops *ops = &fq_codel_qdisc_ops;
- 
- 	if (dev->priv_flags & IFF_NO_QUEUE)
- 		ops = &noqueue_qdisc_ops;
diff --git a/target/linux/generic/hack-4.9/662-remove_pfifo_fast.patch b/target/linux/generic/hack-4.9/662-remove_pfifo_fast.patch
deleted file mode 100644
index d9fba6288d21ecf519c525d792a44967db96cf0f..0000000000000000000000000000000000000000
--- a/target/linux/generic/hack-4.9/662-remove_pfifo_fast.patch
+++ /dev/null
@@ -1,159 +0,0 @@
-From b531d492d5ef1cf9dba0f4888eb5fd8624a6d762 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:23:42 +0200
-Subject: net: sched: switch default qdisc from pfifo_fast to fq_codel and remove pfifo_fast
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- net/sched/sch_generic.c | 140 ------------------------------------------------
- 1 file changed, 140 deletions(-)
-
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -449,146 +449,6 @@ struct Qdisc_ops noqueue_qdisc_ops __rea
- 	.owner		=	THIS_MODULE,
- };
- 
--static const u8 prio2band[TC_PRIO_MAX + 1] = {
--	1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1
--};
--
--/* 3-band FIFO queue: old style, but should be a bit faster than
--   generic prio+fifo combination.
-- */
--
--#define PFIFO_FAST_BANDS 3
--
--/*
-- * Private data for a pfifo_fast scheduler containing:
-- * 	- queues for the three band
-- * 	- bitmap indicating which of the bands contain skbs
-- */
--struct pfifo_fast_priv {
--	u32 bitmap;
--	struct qdisc_skb_head q[PFIFO_FAST_BANDS];
--};
--
--/*
-- * Convert a bitmap to the first band number where an skb is queued, where:
-- * 	bitmap=0 means there are no skbs on any band.
-- * 	bitmap=1 means there is an skb on band 0.
-- *	bitmap=7 means there are skbs on all 3 bands, etc.
-- */
--static const int bitmap2band[] = {-1, 0, 1, 0, 2, 0, 1, 0};
--
--static inline struct qdisc_skb_head *band2list(struct pfifo_fast_priv *priv,
--					     int band)
--{
--	return priv->q + band;
--}
--
--static int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc *qdisc,
--			      struct sk_buff **to_free)
--{
--	if (qdisc->q.qlen < qdisc_dev(qdisc)->tx_queue_len) {
--		int band = prio2band[skb->priority & TC_PRIO_MAX];
--		struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--		struct qdisc_skb_head *list = band2list(priv, band);
--
--		priv->bitmap |= (1 << band);
--		qdisc->q.qlen++;
--		return __qdisc_enqueue_tail(skb, qdisc, list);
--	}
--
--	return qdisc_drop(skb, qdisc, to_free);
--}
--
--static struct sk_buff *pfifo_fast_dequeue(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (likely(band >= 0)) {
--		struct qdisc_skb_head *qh = band2list(priv, band);
--		struct sk_buff *skb = __qdisc_dequeue_head(qh);
--
--		if (likely(skb != NULL)) {
--			qdisc_qstats_backlog_dec(qdisc, skb);
--			qdisc_bstats_update(qdisc, skb);
--		}
--
--		qdisc->q.qlen--;
--		if (qh->qlen == 0)
--			priv->bitmap &= ~(1 << band);
--
--		return skb;
--	}
--
--	return NULL;
--}
--
--static struct sk_buff *pfifo_fast_peek(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (band >= 0) {
--		struct qdisc_skb_head *qh = band2list(priv, band);
--
--		return qh->head;
--	}
--
--	return NULL;
--}
--
--static void pfifo_fast_reset(struct Qdisc *qdisc)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		__qdisc_reset_queue(band2list(priv, prio));
--
--	priv->bitmap = 0;
--	qdisc->qstats.backlog = 0;
--	qdisc->q.qlen = 0;
--}
--
--static int pfifo_fast_dump(struct Qdisc *qdisc, struct sk_buff *skb)
--{
--	struct tc_prio_qopt opt = { .bands = PFIFO_FAST_BANDS };
--
--	memcpy(&opt.priomap, prio2band, TC_PRIO_MAX + 1);
--	if (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))
--		goto nla_put_failure;
--	return skb->len;
--
--nla_put_failure:
--	return -1;
--}
--
--static int pfifo_fast_init(struct Qdisc *qdisc, struct nlattr *opt)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		qdisc_skb_head_init(band2list(priv, prio));
--
--	/* Can by-pass the queue discipline */
--	qdisc->flags |= TCQ_F_CAN_BYPASS;
--	return 0;
--}
--
--struct Qdisc_ops pfifo_fast_ops __read_mostly = {
--	.id		=	"pfifo_fast",
--	.priv_size	=	sizeof(struct pfifo_fast_priv),
--	.enqueue	=	pfifo_fast_enqueue,
--	.dequeue	=	pfifo_fast_dequeue,
--	.peek		=	pfifo_fast_peek,
--	.init		=	pfifo_fast_init,
--	.reset		=	pfifo_fast_reset,
--	.dump		=	pfifo_fast_dump,
--	.owner		=	THIS_MODULE,
--};
--EXPORT_SYMBOL(pfifo_fast_ops);
--
- static struct lock_class_key qdisc_tx_busylock;
- static struct lock_class_key qdisc_running_key;
- 
diff --git a/target/linux/generic/pending-3.18/662-use_fq_codel_by_default.patch b/target/linux/generic/pending-3.18/662-use_fq_codel_by_default.patch
deleted file mode 100644
index 39abfaabea7b925be2929284eb98a90f3d556d1a..0000000000000000000000000000000000000000
--- a/target/linux/generic/pending-3.18/662-use_fq_codel_by_default.patch
+++ /dev/null
@@ -1,95 +0,0 @@
---- a/net/sched/Kconfig
-+++ b/net/sched/Kconfig
-@@ -3,8 +3,9 @@
- # 
- 
- menuconfig NET_SCHED
--	bool "QoS and/or fair queueing"
-+	def_bool y
- 	select NET_SCH_FIFO
-+	select NET_SCH_FQ_CODEL
- 	---help---
- 	  When the kernel has several packets to send out over a network
- 	  device, it has to decide which ones to send first, which ones to
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -599,7 +599,7 @@ static const struct Qdisc_class_ops fq_c
- 	.walk		=	fq_codel_walk,
- };
- 
--static struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
-+struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
- 	.cl_ops		=	&fq_codel_class_ops,
- 	.id		=	"fq_codel",
- 	.priv_size	=	sizeof(struct fq_codel_sched_data),
-@@ -615,6 +615,7 @@ static struct Qdisc_ops fq_codel_qdisc_o
- 	.dump_stats =	fq_codel_dump_stats,
- 	.owner		=	THIS_MODULE,
- };
-+EXPORT_SYMBOL(fq_codel_qdisc_ops);
- 
- static int __init fq_codel_module_init(void)
- {
---- a/include/net/sch_generic.h
-+++ b/include/net/sch_generic.h
-@@ -341,6 +341,7 @@ extern struct Qdisc noop_qdisc;
- extern struct Qdisc_ops noop_qdisc_ops;
- extern struct Qdisc_ops pfifo_fast_ops;
- extern struct Qdisc_ops mq_qdisc_ops;
-+extern struct Qdisc_ops fq_codel_qdisc_ops;
- extern const struct Qdisc_ops *default_qdisc_ops;
- 
- struct Qdisc_class_common {
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -31,7 +31,7 @@
- #include <net/dst.h>
- 
- /* Qdisc to use by default */
--const struct Qdisc_ops *default_qdisc_ops = &pfifo_fast_ops;
-+const struct Qdisc_ops *default_qdisc_ops = &fq_codel_qdisc_ops;
- EXPORT_SYMBOL(default_qdisc_ops);
- 
- /* Main transmission queue. */
-@@ -742,7 +742,7 @@ static void attach_one_default_qdisc(str
- 
- 	if (dev->tx_queue_len) {
- 		qdisc = qdisc_create_dflt(dev_queue,
--					  default_qdisc_ops, TC_H_ROOT);
-+					  &fq_codel_qdisc_ops, TC_H_ROOT);
- 		if (!qdisc) {
- 			netdev_info(dev, "activation failed\n");
- 			return;
---- a/net/sched/sch_mq.c
-+++ b/net/sched/sch_mq.c
-@@ -57,7 +57,7 @@ static int mq_init(struct Qdisc *sch, st
- 
- 	for (ntx = 0; ntx < dev->num_tx_queues; ntx++) {
- 		dev_queue = netdev_get_tx_queue(dev, ntx);
--		qdisc = qdisc_create_dflt(dev_queue, default_qdisc_ops,
-+		qdisc = qdisc_create_dflt(dev_queue, &fq_codel_qdisc_ops,
- 					  TC_H_MAKE(TC_H_MAJ(sch->handle),
- 						    TC_H_MIN(ntx + 1)));
- 		if (qdisc == NULL)
---- a/net/sched/sch_mqprio.c
-+++ b/net/sched/sch_mqprio.c
-@@ -124,7 +124,7 @@ static int mqprio_init(struct Qdisc *sch
- 
- 	for (i = 0; i < dev->num_tx_queues; i++) {
- 		dev_queue = netdev_get_tx_queue(dev, i);
--		qdisc = qdisc_create_dflt(dev_queue, default_qdisc_ops,
-+		qdisc = qdisc_create_dflt(dev_queue, &fq_codel_qdisc_ops,
- 					  TC_H_MAKE(TC_H_MAJ(sch->handle),
- 						    TC_H_MIN(i + 1)));
- 		if (qdisc == NULL) {
---- a/net/sched/sch_api.c
-+++ b/net/sched/sch_api.c
-@@ -1949,7 +1949,7 @@ static int __init pktsched_init(void)
- 		return err;
- 	}
- 
--	register_qdisc(&pfifo_fast_ops);
-+	register_qdisc(&fq_codel_qdisc_ops);
- 	register_qdisc(&pfifo_qdisc_ops);
- 	register_qdisc(&bfifo_qdisc_ops);
- 	register_qdisc(&pfifo_head_drop_qdisc_ops);
diff --git a/target/linux/generic/pending-3.18/663-remove_pfifo_fast.patch b/target/linux/generic/pending-3.18/663-remove_pfifo_fast.patch
deleted file mode 100644
index 50b90b375f611d78b90e7e6dd9c1228e8c09d28a..0000000000000000000000000000000000000000
--- a/target/linux/generic/pending-3.18/663-remove_pfifo_fast.patch
+++ /dev/null
@@ -1,143 +0,0 @@
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -445,140 +445,6 @@ static struct Qdisc noqueue_qdisc = {
- 	.busylock	=	__SPIN_LOCK_UNLOCKED(noqueue_qdisc.busylock),
- };
- 
--
--static const u8 prio2band[TC_PRIO_MAX + 1] = {
--	1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1
--};
--
--/* 3-band FIFO queue: old style, but should be a bit faster than
--   generic prio+fifo combination.
-- */
--
--#define PFIFO_FAST_BANDS 3
--
--/*
-- * Private data for a pfifo_fast scheduler containing:
-- * 	- queues for the three band
-- * 	- bitmap indicating which of the bands contain skbs
-- */
--struct pfifo_fast_priv {
--	u32 bitmap;
--	struct sk_buff_head q[PFIFO_FAST_BANDS];
--};
--
--/*
-- * Convert a bitmap to the first band number where an skb is queued, where:
-- * 	bitmap=0 means there are no skbs on any band.
-- * 	bitmap=1 means there is an skb on band 0.
-- *	bitmap=7 means there are skbs on all 3 bands, etc.
-- */
--static const int bitmap2band[] = {-1, 0, 1, 0, 2, 0, 1, 0};
--
--static inline struct sk_buff_head *band2list(struct pfifo_fast_priv *priv,
--					     int band)
--{
--	return priv->q + band;
--}
--
--static int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc *qdisc)
--{
--	if (skb_queue_len(&qdisc->q) < qdisc_dev(qdisc)->tx_queue_len) {
--		int band = prio2band[skb->priority & TC_PRIO_MAX];
--		struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--		struct sk_buff_head *list = band2list(priv, band);
--
--		priv->bitmap |= (1 << band);
--		qdisc->q.qlen++;
--		return __qdisc_enqueue_tail(skb, qdisc, list);
--	}
--
--	return qdisc_drop(skb, qdisc);
--}
--
--static struct sk_buff *pfifo_fast_dequeue(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (likely(band >= 0)) {
--		struct sk_buff_head *list = band2list(priv, band);
--		struct sk_buff *skb = __qdisc_dequeue_head(qdisc, list);
--
--		qdisc->q.qlen--;
--		if (skb_queue_empty(list))
--			priv->bitmap &= ~(1 << band);
--
--		return skb;
--	}
--
--	return NULL;
--}
--
--static struct sk_buff *pfifo_fast_peek(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (band >= 0) {
--		struct sk_buff_head *list = band2list(priv, band);
--
--		return skb_peek(list);
--	}
--
--	return NULL;
--}
--
--static void pfifo_fast_reset(struct Qdisc *qdisc)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		__qdisc_reset_queue(qdisc, band2list(priv, prio));
--
--	priv->bitmap = 0;
--	qdisc->qstats.backlog = 0;
--	qdisc->q.qlen = 0;
--}
--
--static int pfifo_fast_dump(struct Qdisc *qdisc, struct sk_buff *skb)
--{
--	struct tc_prio_qopt opt = { .bands = PFIFO_FAST_BANDS };
--
--	memcpy(&opt.priomap, prio2band, TC_PRIO_MAX + 1);
--	if (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))
--		goto nla_put_failure;
--	return skb->len;
--
--nla_put_failure:
--	return -1;
--}
--
--static int pfifo_fast_init(struct Qdisc *qdisc, struct nlattr *opt)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		__skb_queue_head_init(band2list(priv, prio));
--
--	/* Can by-pass the queue discipline */
--	qdisc->flags |= TCQ_F_CAN_BYPASS;
--	return 0;
--}
--
--struct Qdisc_ops pfifo_fast_ops __read_mostly = {
--	.id		=	"pfifo_fast",
--	.priv_size	=	sizeof(struct pfifo_fast_priv),
--	.enqueue	=	pfifo_fast_enqueue,
--	.dequeue	=	pfifo_fast_dequeue,
--	.peek		=	pfifo_fast_peek,
--	.init		=	pfifo_fast_init,
--	.reset		=	pfifo_fast_reset,
--	.dump		=	pfifo_fast_dump,
--	.owner		=	THIS_MODULE,
--};
--
- static struct lock_class_key qdisc_tx_busylock;
- 
- struct Qdisc *qdisc_alloc(struct netdev_queue *dev_queue,
diff --git a/target/linux/generic/pending-4.4/662-use_fq_codel_by_default.patch b/target/linux/generic/pending-4.4/662-use_fq_codel_by_default.patch
deleted file mode 100644
index 8d70b82350ee42ba7e1e1ab41b7d9555d70b719a..0000000000000000000000000000000000000000
--- a/target/linux/generic/pending-4.4/662-use_fq_codel_by_default.patch
+++ /dev/null
@@ -1,95 +0,0 @@
---- a/net/sched/Kconfig
-+++ b/net/sched/Kconfig
-@@ -3,8 +3,9 @@
- # 
- 
- menuconfig NET_SCHED
--	bool "QoS and/or fair queueing"
-+	def_bool y
- 	select NET_SCH_FIFO
-+	select NET_SCH_FQ_CODEL
- 	---help---
- 	  When the kernel has several packets to send out over a network
- 	  device, it has to decide which ones to send first, which ones to
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -694,7 +694,7 @@ static const struct Qdisc_class_ops fq_c
- 	.walk		=	fq_codel_walk,
- };
- 
--static struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
-+struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
- 	.cl_ops		=	&fq_codel_class_ops,
- 	.id		=	"fq_codel",
- 	.priv_size	=	sizeof(struct fq_codel_sched_data),
-@@ -710,6 +710,7 @@ static struct Qdisc_ops fq_codel_qdisc_o
- 	.dump_stats =	fq_codel_dump_stats,
- 	.owner		=	THIS_MODULE,
- };
-+EXPORT_SYMBOL(fq_codel_qdisc_ops);
- 
- static int __init fq_codel_module_init(void)
- {
---- a/include/net/sch_generic.h
-+++ b/include/net/sch_generic.h
-@@ -344,6 +344,7 @@ extern struct Qdisc_ops noop_qdisc_ops;
- extern struct Qdisc_ops pfifo_fast_ops;
- extern struct Qdisc_ops mq_qdisc_ops;
- extern struct Qdisc_ops noqueue_qdisc_ops;
-+extern struct Qdisc_ops fq_codel_qdisc_ops;
- extern const struct Qdisc_ops *default_qdisc_ops;
- 
- struct Qdisc_class_common {
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -31,7 +31,7 @@
- #include <net/dst.h>
- 
- /* Qdisc to use by default */
--const struct Qdisc_ops *default_qdisc_ops = &pfifo_fast_ops;
-+const struct Qdisc_ops *default_qdisc_ops = &fq_codel_qdisc_ops;
- EXPORT_SYMBOL(default_qdisc_ops);
- 
- /* Main transmission queue. */
-@@ -731,7 +731,7 @@ static void attach_one_default_qdisc(str
- 				     void *_unused)
- {
- 	struct Qdisc *qdisc;
--	const struct Qdisc_ops *ops = default_qdisc_ops;
-+	const struct Qdisc_ops *ops = &fq_codel_qdisc_ops;
- 
- 	if (dev->priv_flags & IFF_NO_QUEUE)
- 		ops = &noqueue_qdisc_ops;
---- a/net/sched/sch_mq.c
-+++ b/net/sched/sch_mq.c
-@@ -57,7 +57,7 @@ static int mq_init(struct Qdisc *sch, st
- 
- 	for (ntx = 0; ntx < dev->num_tx_queues; ntx++) {
- 		dev_queue = netdev_get_tx_queue(dev, ntx);
--		qdisc = qdisc_create_dflt(dev_queue, default_qdisc_ops,
-+		qdisc = qdisc_create_dflt(dev_queue, &fq_codel_qdisc_ops,
- 					  TC_H_MAKE(TC_H_MAJ(sch->handle),
- 						    TC_H_MIN(ntx + 1)));
- 		if (!qdisc)
---- a/net/sched/sch_mqprio.c
-+++ b/net/sched/sch_mqprio.c
-@@ -122,7 +122,7 @@ static int mqprio_init(struct Qdisc *sch
- 
- 	for (i = 0; i < dev->num_tx_queues; i++) {
- 		dev_queue = netdev_get_tx_queue(dev, i);
--		qdisc = qdisc_create_dflt(dev_queue, default_qdisc_ops,
-+		qdisc = qdisc_create_dflt(dev_queue, &fq_codel_qdisc_ops,
- 					  TC_H_MAKE(TC_H_MAJ(sch->handle),
- 						    TC_H_MIN(i + 1)));
- 		if (!qdisc)
---- a/net/sched/sch_api.c
-+++ b/net/sched/sch_api.c
-@@ -1951,7 +1951,7 @@ static int __init pktsched_init(void)
- 		return err;
- 	}
- 
--	register_qdisc(&pfifo_fast_ops);
-+	register_qdisc(&fq_codel_qdisc_ops);
- 	register_qdisc(&pfifo_qdisc_ops);
- 	register_qdisc(&bfifo_qdisc_ops);
- 	register_qdisc(&pfifo_head_drop_qdisc_ops);
diff --git a/target/linux/generic/pending-4.4/663-remove_pfifo_fast.patch b/target/linux/generic/pending-4.4/663-remove_pfifo_fast.patch
deleted file mode 100644
index 6f72b1935807e13d8bb924d6119bc9adbd32d885..0000000000000000000000000000000000000000
--- a/target/linux/generic/pending-4.4/663-remove_pfifo_fast.patch
+++ /dev/null
@@ -1,142 +0,0 @@
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -438,139 +438,6 @@ struct Qdisc_ops noqueue_qdisc_ops __rea
- 	.owner		=	THIS_MODULE,
- };
- 
--static const u8 prio2band[TC_PRIO_MAX + 1] = {
--	1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1
--};
--
--/* 3-band FIFO queue: old style, but should be a bit faster than
--   generic prio+fifo combination.
-- */
--
--#define PFIFO_FAST_BANDS 3
--
--/*
-- * Private data for a pfifo_fast scheduler containing:
-- * 	- queues for the three band
-- * 	- bitmap indicating which of the bands contain skbs
-- */
--struct pfifo_fast_priv {
--	u32 bitmap;
--	struct sk_buff_head q[PFIFO_FAST_BANDS];
--};
--
--/*
-- * Convert a bitmap to the first band number where an skb is queued, where:
-- * 	bitmap=0 means there are no skbs on any band.
-- * 	bitmap=1 means there is an skb on band 0.
-- *	bitmap=7 means there are skbs on all 3 bands, etc.
-- */
--static const int bitmap2band[] = {-1, 0, 1, 0, 2, 0, 1, 0};
--
--static inline struct sk_buff_head *band2list(struct pfifo_fast_priv *priv,
--					     int band)
--{
--	return priv->q + band;
--}
--
--static int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc *qdisc)
--{
--	if (skb_queue_len(&qdisc->q) < qdisc_dev(qdisc)->tx_queue_len) {
--		int band = prio2band[skb->priority & TC_PRIO_MAX];
--		struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--		struct sk_buff_head *list = band2list(priv, band);
--
--		priv->bitmap |= (1 << band);
--		qdisc->q.qlen++;
--		return __qdisc_enqueue_tail(skb, qdisc, list);
--	}
--
--	return qdisc_drop(skb, qdisc);
--}
--
--static struct sk_buff *pfifo_fast_dequeue(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (likely(band >= 0)) {
--		struct sk_buff_head *list = band2list(priv, band);
--		struct sk_buff *skb = __qdisc_dequeue_head(qdisc, list);
--
--		qdisc->q.qlen--;
--		if (skb_queue_empty(list))
--			priv->bitmap &= ~(1 << band);
--
--		return skb;
--	}
--
--	return NULL;
--}
--
--static struct sk_buff *pfifo_fast_peek(struct Qdisc *qdisc)
--{
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--	int band = bitmap2band[priv->bitmap];
--
--	if (band >= 0) {
--		struct sk_buff_head *list = band2list(priv, band);
--
--		return skb_peek(list);
--	}
--
--	return NULL;
--}
--
--static void pfifo_fast_reset(struct Qdisc *qdisc)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		__qdisc_reset_queue(qdisc, band2list(priv, prio));
--
--	priv->bitmap = 0;
--	qdisc->qstats.backlog = 0;
--	qdisc->q.qlen = 0;
--}
--
--static int pfifo_fast_dump(struct Qdisc *qdisc, struct sk_buff *skb)
--{
--	struct tc_prio_qopt opt = { .bands = PFIFO_FAST_BANDS };
--
--	memcpy(&opt.priomap, prio2band, TC_PRIO_MAX + 1);
--	if (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))
--		goto nla_put_failure;
--	return skb->len;
--
--nla_put_failure:
--	return -1;
--}
--
--static int pfifo_fast_init(struct Qdisc *qdisc, struct nlattr *opt)
--{
--	int prio;
--	struct pfifo_fast_priv *priv = qdisc_priv(qdisc);
--
--	for (prio = 0; prio < PFIFO_FAST_BANDS; prio++)
--		__skb_queue_head_init(band2list(priv, prio));
--
--	/* Can by-pass the queue discipline */
--	qdisc->flags |= TCQ_F_CAN_BYPASS;
--	return 0;
--}
--
--struct Qdisc_ops pfifo_fast_ops __read_mostly = {
--	.id		=	"pfifo_fast",
--	.priv_size	=	sizeof(struct pfifo_fast_priv),
--	.enqueue	=	pfifo_fast_enqueue,
--	.dequeue	=	pfifo_fast_dequeue,
--	.peek		=	pfifo_fast_peek,
--	.init		=	pfifo_fast_init,
--	.reset		=	pfifo_fast_reset,
--	.dump		=	pfifo_fast_dump,
--	.owner		=	THIS_MODULE,
--};
--
- static struct lock_class_key qdisc_tx_busylock;
- 
- struct Qdisc *qdisc_alloc(struct netdev_queue *dev_queue,
