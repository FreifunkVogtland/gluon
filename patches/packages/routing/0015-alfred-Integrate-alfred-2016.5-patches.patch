From: Sven Eckelmann <sven@narfation.org>
Date: Sat, 3 Dec 2016 14:26:34 +0100
Subject: alfred: Integrate alfred 2016.5 patches

diff --git a/alfred/patches/0002-alfred-Start-new-development-cycle.patch b/alfred/patches/0002-alfred-Start-new-development-cycle.patch
new file mode 100644
index 0000000..86d623d
--- /dev/null
+++ b/alfred/patches/0002-alfred-Start-new-development-cycle.patch
@@ -0,0 +1,50 @@
+From: Simon Wunderlich <sw@simonwunderlich.de>
+Date: Thu, 27 Oct 2016 21:24:16 +0200
+Subject: [PATCH] alfred: Start new development cycle
+
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ alfred.h           | 2 +-
+ gpsd/alfred-gpsd.h | 2 +-
+ vis/vis.h          | 2 +-
+ 3 files changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/alfred.h b/alfred.h
+index 3c66819..b2b08b0 100644
+--- a/alfred.h
++++ b/alfred.h
+@@ -20,7 +20,7 @@
+  */
+ 
+ #ifndef SOURCE_VERSION
+-#define SOURCE_VERSION			"2016.4"
++#define SOURCE_VERSION			"2016.5"
+ #endif
+ 
+ #include <net/ethernet.h>
+diff --git a/gpsd/alfred-gpsd.h b/gpsd/alfred-gpsd.h
+index e1a258b..6ea06e6 100644
+--- a/gpsd/alfred-gpsd.h
++++ b/gpsd/alfred-gpsd.h
+@@ -38,7 +38,7 @@
+ #include "../list.h"
+ 
+ #ifndef SOURCE_VERSION
+-#define SOURCE_VERSION				"2016.4"
++#define SOURCE_VERSION				"2016.5"
+ #endif
+ 
+ #define ALFRED_SOCK_PATH_DEFAULT		"/var/run/alfred.sock"
+diff --git a/vis/vis.h b/vis/vis.h
+index 04618c4..017eddd 100644
+--- a/vis/vis.h
++++ b/vis/vis.h
+@@ -27,7 +27,7 @@
+ 
+ 
+ #ifndef SOURCE_VERSION
+-#define SOURCE_VERSION				"2016.4"
++#define SOURCE_VERSION				"2016.5"
+ #endif
+ 
+ #define ALFRED_SOCK_PATH_DEFAULT		"/var/run/alfred.sock"
diff --git a/alfred/patches/0003-alfred-vis-Add-missing-return-for-vis_server.patch b/alfred/patches/0003-alfred-vis-Add-missing-return-for-vis_server.patch
new file mode 100644
index 0000000..8c3796d
--- /dev/null
+++ b/alfred/patches/0003-alfred-vis-Add-missing-return-for-vis_server.patch
@@ -0,0 +1,23 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Tue, 1 Nov 2016 13:17:25 +0100
+Subject: [PATCH] alfred: vis: Add missing return for vis_server
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ vis/vis.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/vis/vis.c b/vis/vis.c
+index f4d13c7..d14744c 100644
+--- a/vis/vis.c
++++ b/vis/vis.c
+@@ -1145,6 +1145,8 @@ static int vis_server(struct globals *globals)
+ 		vis_update_data(globals);
+ 		sleep(UPDATE_INTERVAL);
+ 	}
++
++	return 0;
+ }
+ 
+ int main(int argc, char *argv[])
diff --git a/alfred/patches/0004-alfred-vis-Don-t-fail-when-debugfs-cannot-be-mounted.patch b/alfred/patches/0004-alfred-vis-Don-t-fail-when-debugfs-cannot-be-mounted.patch
new file mode 100644
index 0000000..6d39e7f
--- /dev/null
+++ b/alfred/patches/0004-alfred-vis-Don-t-fail-when-debugfs-cannot-be-mounted.patch
@@ -0,0 +1,33 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Tue, 1 Nov 2016 13:19:37 +0100
+Subject: [PATCH] alfred: vis: Don't fail when debugfs cannot be mounted
+
+The vis server is supposed to use netlink when available. This allows to
+work on systems without debugfs and under network namespaces. Thus it is
+now not strictly required anymore to have debugfs available.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ vis/vis.c | 8 +-------
+ 1 file changed, 1 insertion(+), 7 deletions(-)
+
+diff --git a/vis/vis.c b/vis/vis.c
+index d14744c..22e052b 100644
+--- a/vis/vis.c
++++ b/vis/vis.c
+@@ -1120,13 +1120,7 @@ static struct globals *vis_init(int argc, char *argv[])
+ 
+ static int vis_server(struct globals *globals)
+ {
+-	char *debugfs_mnt;
+-
+-	debugfs_mnt = debugfs_mount(NULL);
+-	if (!debugfs_mnt) {
+-		fprintf(stderr, "Error - can't mount or find debugfs\n");
+-		return EXIT_FAILURE;
+-	}
++	debugfs_mount(NULL);
+ 
+ 	globals->push = (struct alfred_push_data_v0 *) globals->buf;
+ 	globals->vis_data = (struct vis_v1 *) (globals->buf + sizeof(*globals->push) + sizeof(struct alfred_data));
diff --git a/alfred/patches/0005-alfred-Check-batadv-interfaces-via-netlink.patch b/alfred/patches/0005-alfred-Check-batadv-interfaces-via-netlink.patch
new file mode 100644
index 0000000..c8c9790
--- /dev/null
+++ b/alfred/patches/0005-alfred-Check-batadv-interfaces-via-netlink.patch
@@ -0,0 +1,105 @@
+From: Jean-Jacques Sarton <jj.sarton@t-online.de>
+Date: Sun, 6 Nov 2016 10:37:38 +0100
+Subject: [PATCH] alfred: Check batadv interfaces via netlink
+
+alfred is checking the status of the mesh interface before it starts. The
+mesh interface has to have accessible debugfs files "transtable_global" and
+"originators" before alfred will accept it.
+
+batman-adv will not create debugfs entries for network namespaces. Thus
+this check has to be modified to first check via netlink if the interface
+is providing the same information without debugfs. If it does then no check
+for the debugfs files is necessary anymore.
+
+Signed-off-by: Jean-Jacques Sarton <jj.sarton@t-online.de>
+[sven@narfation.org: fixed commit message, mark debugfs function static,
+ fix whitespaces, fix unused init of variable, only fallback to debugfs on
+ EOPNOTSUPP, rewritten batadv_interface_check_netlink, fix return of
+ batadv_interface_check]
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ batadv_query.c | 16 +++++++++++++++-
+ netlink.c      | 25 +++++++++++++++++++++++++
+ netlink.h      |  1 +
+ 3 files changed, 41 insertions(+), 1 deletion(-)
+
+diff --git a/batadv_query.c b/batadv_query.c
+index a671b79..c17132f 100644
+--- a/batadv_query.c
++++ b/batadv_query.c
+@@ -136,7 +136,7 @@ int ipv6_to_mac(const struct in6_addr *addr, struct ether_addr *mac)
+ 	return 0;
+ }
+ 
+-int batadv_interface_check(const char *mesh_iface)
++static int batadv_interface_check_debugfs(const char *mesh_iface)
+ {
+ 	char full_path[MAX_PATH + 1];
+ 	FILE *f;
+@@ -166,6 +166,20 @@ int batadv_interface_check(const char *mesh_iface)
+ 	return 0;
+ }
+ 
++int batadv_interface_check(const char *mesh_iface)
++{
++	int ret;
++
++	enable_net_admin_capability(1);
++	ret = batadv_interface_check_netlink(mesh_iface);
++	enable_net_admin_capability(0);
++
++	if (ret == -EOPNOTSUPP)
++		ret = batadv_interface_check_debugfs(mesh_iface);
++
++	return ret;
++}
++
+ static int translate_mac_debugfs(const char *mesh_iface,
+ 				 const struct ether_addr *mac,
+ 				 struct ether_addr *mac_out)
+diff --git a/netlink.c b/netlink.c
+index 1b5695c..73fab28 100644
+--- a/netlink.c
++++ b/netlink.c
+@@ -365,3 +365,28 @@ int get_tq_netlink(const char *mesh_iface, const struct ether_addr *mac,
+ 
+ 	return 0;
+ }
++
++static int check_nlcmd_cb(struct nl_msg *msg __unused, void *arg __unused)
++{
++	return NL_STOP;
++}
++
++int batadv_interface_check_netlink(const char *mesh_iface)
++{
++	struct nlquery_opts opts = {
++		.err = 0,
++	};
++	int ret;
++
++	ret = netlink_query_common(mesh_iface,  BATADV_CMD_GET_ORIGINATORS,
++				   check_nlcmd_cb, &opts);
++	if (ret < 0)
++		return ret;
++
++	ret = netlink_query_common(mesh_iface, BATADV_CMD_GET_TRANSTABLE_GLOBAL,
++				   check_nlcmd_cb, &opts);
++	if (ret < 0)
++		return ret;
++
++	return 0;
++}
+diff --git a/netlink.h b/netlink.h
+index b08e872..9bc75a1 100644
+--- a/netlink.h
++++ b/netlink.h
+@@ -49,6 +49,7 @@ int translate_mac_netlink(const char *mesh_iface, const struct ether_addr *mac,
+ 			  struct ether_addr *mac_out);
+ int get_tq_netlink(const char *mesh_iface, const struct ether_addr *mac,
+ 		   uint8_t *tq);
++int batadv_interface_check_netlink(const char *mesh_iface);
+ 
+ extern struct nla_policy batadv_netlink_policy[];
+ 
diff --git a/alfred/patches/0006-alfred-Avoid-hash-search-for-transaction-cleanup.patch b/alfred/patches/0006-alfred-Avoid-hash-search-for-transaction-cleanup.patch
new file mode 100644
index 0000000..186fd40
--- /dev/null
+++ b/alfred/patches/0006-alfred-Avoid-hash-search-for-transaction-cleanup.patch
@@ -0,0 +1,63 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 12 Nov 2016 10:25:18 +0100
+Subject: [PATCH] alfred: Avoid hash search for transaction cleanup
+
+A transaction can either be cleaned up on timeout or on TXEND. alfred has
+in both situations already the head of the transaction list. An extra
+search in the transaction hash is therefore not needed.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ alfred.h |  3 ---
+ recv.c   | 16 +---------------
+ 2 files changed, 1 insertion(+), 18 deletions(-)
+
+diff --git a/alfred.h b/alfred.h
+index b2b08b0..7e7811b 100644
+--- a/alfred.h
++++ b/alfred.h
+@@ -159,9 +159,6 @@ int recv_alfred_packet(struct globals *globals, struct interface *interface,
+ 		       int recv_sock);
+ struct transaction_head *
+ transaction_add(struct globals *globals, struct ether_addr mac, uint16_t id);
+-struct transaction_head *
+-transaction_clean_hash(struct globals *globals,
+-		       struct transaction_head *search);
+ struct transaction_head *transaction_clean(struct globals *globals,
+ 					   struct transaction_head *head);
+ /* send.c */
+diff --git a/recv.c b/recv.c
+index 98539cb..b6b6eab 100644
+--- a/recv.c
++++ b/recv.c
+@@ -160,18 +160,6 @@ struct transaction_head *transaction_clean(struct globals *globals,
+ 	return head;
+ }
+ 
+-struct transaction_head *
+-transaction_clean_hash(struct globals *globals, struct transaction_head *search)
+-{
+-	struct transaction_head *head;
+-
+-	head = hash_find(globals->transaction_hash, search);
+-	if (!head)
+-		return head;
+-
+-	return transaction_clean(globals, head);
+-}
+-
+ static int process_alfred_push_data(struct globals *globals,
+ 				    struct in6_addr *source,
+ 				    struct alfred_push_data_v0 *push)
+@@ -369,9 +357,7 @@ static int process_alfred_status_txend(struct globals *globals,
+ 		free(transaction_packet);
+ 	}
+ 
+-	head = transaction_clean_hash(globals, &search);
+-	if (!head)
+-		return -1;
++	transaction_clean(globals, head);
+ 
+ 	if (head->client_socket < 0)
+ 		free(head);
diff --git a/alfred/patches/0007-alfred-Move-tx-finish-functionality-in-extra-functio.patch b/alfred/patches/0007-alfred-Move-tx-finish-functionality-in-extra-functio.patch
new file mode 100644
index 0000000..fdb8ff6
--- /dev/null
+++ b/alfred/patches/0007-alfred-Move-tx-finish-functionality-in-extra-functio.patch
@@ -0,0 +1,110 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 12 Nov 2016 10:25:19 +0100
+Subject: [PATCH] alfred: Move tx finish functionality in extra function
+
+The process_alfred_status_txend has two main functionalities. It first
+tries to find a transaction to be able to get its status. When it was found
+then it either commits the data or just cleans it up.
+
+The latter will be used by later by process_alfred_push_data to implement
+out-of-order txend packets. Thus split process_alfred_status_txend now into
+two functions to avoid code duplication.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ recv.c | 67 ++++++++++++++++++++++++++++++++++++++----------------------------
+ 1 file changed, 39 insertions(+), 28 deletions(-)
+
+diff --git a/recv.c b/recv.c
+index b6b6eab..6878e5e 100644
+--- a/recv.c
++++ b/recv.c
+@@ -160,6 +160,44 @@ struct transaction_head *transaction_clean(struct globals *globals,
+ 	return head;
+ }
+ 
++static int finish_alfred_transaction(struct globals *globals,
++				     struct transaction_head *head,
++				     struct ether_addr mac,
++				     uint16_t num_packets)
++{
++	struct transaction_packet *transaction_packet, *safe;
++
++	/* this transaction was already finished/dropped */
++	if (head->finished != 0)
++		return -1;
++
++	/* missing packets -> cleanup everything */
++	if (head->num_packet == num_packets)
++		head->finished = -1;
++	else
++		head->finished = 1;
++
++	list_for_each_entry_safe(transaction_packet, safe, &head->packet_list,
++				 list) {
++		if (head->finished == 1)
++			finish_alfred_push_data(globals, mac,
++						transaction_packet->push);
++
++		list_del(&transaction_packet->list);
++		free(transaction_packet->push);
++		free(transaction_packet);
++	}
++
++	transaction_clean(globals, head);
++
++	if (head->client_socket < 0)
++		free(head);
++	else
++		unix_sock_req_data_finish(globals, head);
++
++	return 1;
++}
++
+ static int process_alfred_push_data(struct globals *globals,
+ 				    struct in6_addr *source,
+ 				    struct alfred_push_data_v0 *push)
+@@ -313,7 +351,6 @@ static int process_alfred_status_txend(struct globals *globals,
+ 				       struct alfred_status_v0 *request)
+ {
+ 	struct transaction_head search, *head;
+-	struct transaction_packet *transaction_packet, *safe;
+ 	struct ether_addr mac;
+ 	int len, ret;
+ 
+@@ -336,33 +373,7 @@ static int process_alfred_status_txend(struct globals *globals,
+ 	if (!head)
+ 		return -1;
+ 
+-	/* this transaction was already finished/dropped */
+-	if (head->finished != 0)
+-		return -1;
+-
+-	/* missing packets -> cleanup everything */
+-	if (head->num_packet != ntohs(request->tx.seqno))
+-		head->finished = -1;
+-	else
+-		head->finished = 1;
+-
+-	list_for_each_entry_safe(transaction_packet, safe, &head->packet_list,
+-				 list) {
+-		if (head->finished == 1)
+-			finish_alfred_push_data(globals, mac,
+-						transaction_packet->push);
+-
+-		list_del(&transaction_packet->list);
+-		free(transaction_packet->push);
+-		free(transaction_packet);
+-	}
+-
+-	transaction_clean(globals, head);
+-
+-	if (head->client_socket < 0)
+-		free(head);
+-	else
+-		unix_sock_req_data_finish(globals, head);
++	finish_alfred_transaction(globals, head, mac, ntohs(request->tx.seqno));
+ 
+ 	return 0;
+ }
diff --git a/alfred/patches/0008-alfred-Remove-checks-for-committed-dropped-transacti.patch b/alfred/patches/0008-alfred-Remove-checks-for-committed-dropped-transacti.patch
new file mode 100644
index 0000000..d1bed0d
--- /dev/null
+++ b/alfred/patches/0008-alfred-Remove-checks-for-committed-dropped-transacti.patch
@@ -0,0 +1,40 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 12 Nov 2016 10:25:20 +0100
+Subject: [PATCH] alfred: Remove checks for committed/dropped transaction
+
+Transactions will be removed from the transaction has when they were
+committed. Thus is is not necessary to check in the push_data/txend packet
+processing functions for committed/dropped transactions.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ recv.c | 8 --------
+ 1 file changed, 8 deletions(-)
+
+diff --git a/recv.c b/recv.c
+index 6878e5e..21ea539 100644
+--- a/recv.c
++++ b/recv.c
+@@ -167,10 +167,6 @@ static int finish_alfred_transaction(struct globals *globals,
+ {
+ 	struct transaction_packet *transaction_packet, *safe;
+ 
+-	/* this transaction was already finished/dropped */
+-	if (head->finished != 0)
+-		return -1;
+-
+ 	/* missing packets -> cleanup everything */
+ 	if (head->num_packet == num_packets)
+ 		head->finished = -1;
+@@ -233,10 +229,6 @@ static int process_alfred_push_data(struct globals *globals,
+ 	}
+ 	clock_gettime(CLOCK_MONOTONIC, &head->last_rx_time);
+ 
+-	/* this transaction was already finished/dropped */
+-	if (head->finished != 0)
+-		return -1;
+-
+ 	found = 0;
+ 	list_for_each_entry(transaction_packet, &head->packet_list, list) {
+ 		if (transaction_packet->push->tx.seqno == push->tx.seqno) {
diff --git a/alfred/patches/0009-alfred-Don-t-force-cleanup-of-transaction-on-TXEND.patch b/alfred/patches/0009-alfred-Don-t-force-cleanup-of-transaction-on-TXEND.patch
new file mode 100644
index 0000000..242b638
--- /dev/null
+++ b/alfred/patches/0009-alfred-Don-t-force-cleanup-of-transaction-on-TXEND.patch
@@ -0,0 +1,60 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 12 Nov 2016 10:25:21 +0100
+Subject: [PATCH] alfred: Don't force cleanup of transaction on TXEND
+
+A committed transaction has always to be cleaned up/removed when the TXEND
+was received. But TXEND packets which are out-of-order may still be waiting
+for PUSH_DATA packets which will be receive later. Thus TXEND packets which
+don't trigger a commit of the PUSH_DATA should not automatically drop the
+transaction.
+
+A transaction which doesn't get all PUSH_DATA packets will be timeout
+automatically and no extra handling is necessary.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ alfred.h |  2 +-
+ recv.c   | 13 +++++--------
+ 2 files changed, 6 insertions(+), 9 deletions(-)
+
+diff --git a/alfred.h b/alfred.h
+index 7e7811b..9d0f6a6 100644
+--- a/alfred.h
++++ b/alfred.h
+@@ -71,7 +71,7 @@ struct transaction_head {
+ 	struct ether_addr server_addr;
+ 	uint16_t id;
+ 	uint8_t requested_type;
+-	int finished;
++	uint16_t finished;
+ 	int num_packet;
+ 	int client_socket;
+ 	struct timespec last_rx_time;
+diff --git a/recv.c b/recv.c
+index 21ea539..dd0b021 100644
+--- a/recv.c
++++ b/recv.c
+@@ -167,17 +167,14 @@ static int finish_alfred_transaction(struct globals *globals,
+ {
+ 	struct transaction_packet *transaction_packet, *safe;
+ 
+-	/* missing packets -> cleanup everything */
+-	if (head->num_packet == num_packets)
+-		head->finished = -1;
+-	else
+-		head->finished = 1;
++	/* finish when all packets received */
++	if (head->num_packet != num_packets)
++		return 0;
+ 
++	head->finished = 1;
+ 	list_for_each_entry_safe(transaction_packet, safe, &head->packet_list,
+ 				 list) {
+-		if (head->finished == 1)
+-			finish_alfred_push_data(globals, mac,
+-						transaction_packet->push);
++		finish_alfred_push_data(globals, mac, transaction_packet->push);
+ 
+ 		list_del(&transaction_packet->list);
+ 		free(transaction_packet->push);
diff --git a/alfred/patches/0010-alfred-Use-expected-packet-count-to-finished-transac.patch b/alfred/patches/0010-alfred-Use-expected-packet-count-to-finished-transac.patch
new file mode 100644
index 0000000..c5f8d08
--- /dev/null
+++ b/alfred/patches/0010-alfred-Use-expected-packet-count-to-finished-transac.patch
@@ -0,0 +1,98 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 12 Nov 2016 10:25:22 +0100
+Subject: [PATCH] alfred: Use expected packet count to finished transactions
+
+The TXEND packet will specify the number of PUSH_DATA packets are required
+to finish a transaction. This number has therefore to be stored when a
+TXEND packet is receiver to later be able to decide whether the
+transaction can be finished or not.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ alfred.h    |  8 +++++++-
+ recv.c      | 11 +++++------
+ unix_sock.c |  2 +-
+ 3 files changed, 13 insertions(+), 8 deletions(-)
+
+diff --git a/alfred.h b/alfred.h
+index 9d0f6a6..eb8200c 100644
+--- a/alfred.h
++++ b/alfred.h
+@@ -71,7 +71,7 @@ struct transaction_head {
+ 	struct ether_addr server_addr;
+ 	uint16_t id;
+ 	uint8_t requested_type;
+-	uint16_t finished;
++	uint16_t txend_packets;
+ 	int num_packet;
+ 	int client_socket;
+ 	struct timespec last_rx_time;
+@@ -161,6 +161,12 @@ struct transaction_head *
+ transaction_add(struct globals *globals, struct ether_addr mac, uint16_t id);
+ struct transaction_head *transaction_clean(struct globals *globals,
+ 					   struct transaction_head *head);
++
++static inline bool transaction_finished(struct transaction_head *head)
++{
++	return head->txend_packets == head->num_packet;
++}
++
+ /* send.c */
+ int push_data(struct globals *globals, struct interface *interface,
+ 	      struct in6_addr *destination, enum data_source max_source_level,
+diff --git a/recv.c b/recv.c
+index dd0b021..1f56016 100644
+--- a/recv.c
++++ b/recv.c
+@@ -131,7 +131,7 @@ transaction_add(struct globals *globals, struct ether_addr mac, uint16_t id)
+ 	head->server_addr = mac;
+ 	head->id = id;
+ 	head->requested_type = 0;
+-	head->finished = 0;
++	head->txend_packets = 0;
+ 	head->num_packet = 0;
+ 	head->client_socket = -1;
+ 	clock_gettime(CLOCK_MONOTONIC, &head->last_rx_time);
+@@ -162,16 +162,14 @@ struct transaction_head *transaction_clean(struct globals *globals,
+ 
+ static int finish_alfred_transaction(struct globals *globals,
+ 				     struct transaction_head *head,
+-				     struct ether_addr mac,
+-				     uint16_t num_packets)
++				     struct ether_addr mac)
+ {
+ 	struct transaction_packet *transaction_packet, *safe;
+ 
+ 	/* finish when all packets received */
+-	if (head->num_packet != num_packets)
++	if (!transaction_finished(head))
+ 		return 0;
+ 
+-	head->finished = 1;
+ 	list_for_each_entry_safe(transaction_packet, safe, &head->packet_list,
+ 				 list) {
+ 		finish_alfred_push_data(globals, mac, transaction_packet->push);
+@@ -362,7 +360,8 @@ static int process_alfred_status_txend(struct globals *globals,
+ 	if (!head)
+ 		return -1;
+ 
+-	finish_alfred_transaction(globals, head, mac, ntohs(request->tx.seqno));
++	head->txend_packets = ntohs(request->tx.seqno);
++	finish_alfred_transaction(globals, head, mac);
+ 
+ 	return 0;
+ }
+diff --git a/unix_sock.c b/unix_sock.c
+index 150ad32..edc7e0b 100644
+--- a/unix_sock.c
++++ b/unix_sock.c
+@@ -276,7 +276,7 @@ int unix_sock_req_data_finish(struct globals *globals,
+ 	requested_type = head->requested_type;
+ 	id = head->id;
+ 	client_sock = head->client_socket;
+-	if (head->finished != 1)
++	if (!transaction_finished(head))
+ 		send_data = 0;
+ 
+ 	free(head);
diff --git a/alfred/patches/0011-alfred-Allow-PUSH_DATA-to-finish-transactions.patch b/alfred/patches/0011-alfred-Allow-PUSH_DATA-to-finish-transactions.patch
new file mode 100644
index 0000000..2727ac3
--- /dev/null
+++ b/alfred/patches/0011-alfred-Allow-PUSH_DATA-to-finish-transactions.patch
@@ -0,0 +1,27 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 12 Nov 2016 10:25:23 +0100
+Subject: [PATCH] alfred: Allow PUSH_DATA to finish transactions
+
+A TXEND packet which is received in the middle of a transaction cannot
+finish this transaction. This can only be done by a PUSH_DATA when the rest
+of the packets were received.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ recv.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/recv.c b/recv.c
+index 1f56016..9fabfa4 100644
+--- a/recv.c
++++ b/recv.c
+@@ -250,6 +250,8 @@ static int process_alfred_push_data(struct globals *globals,
+ 	list_add_tail(&transaction_packet->list, &head->packet_list);
+ 	head->num_packet++;
+ 
++	finish_alfred_transaction(globals, head, mac);
++
+ 	return 0;
+ err:
+ 	return -1;
diff --git a/alfred/patches/0012-alfred-Allow-TXEND-to-start-new-transaction.patch b/alfred/patches/0012-alfred-Allow-TXEND-to-start-new-transaction.patch
new file mode 100644
index 0000000..1c12baa
--- /dev/null
+++ b/alfred/patches/0012-alfred-Allow-TXEND-to-start-new-transaction.patch
@@ -0,0 +1,52 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 12 Nov 2016 10:25:24 +0100
+Subject: [PATCH] alfred: Allow TXEND to start new transaction
+
+A TXEND which comes before all other PUSH_DATA packets also has to create
+its own transaction. Otherwise it cannot store the number of expected
+packets for this transaction.
+
+The PUSH_DATA packets can then trigger the finish of the transaction. Or
+the transaction will timeout automatically.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ recv.c | 19 +++++++++++++++++--
+ 1 file changed, 17 insertions(+), 2 deletions(-)
+
+diff --git a/recv.c b/recv.c
+index 9fabfa4..bd208fd 100644
+--- a/recv.c
++++ b/recv.c
+@@ -359,13 +359,28 @@ static int process_alfred_status_txend(struct globals *globals,
+ 	search.id = ntohs(request->tx.id);
+ 
+ 	head = hash_find(globals->transaction_hash, &search);
+-	if (!head)
+-		return -1;
++	if (!head) {
++		/* slave must create the transactions to be able to correctly
++		 *  wait for it */
++		if (globals->opmode != OPMODE_MASTER)
++			goto err;
++
++		/* 0-packet txend for unknown transaction */
++		if (ntohs(request->tx.seqno) == 0)
++			goto err;
++
++		head = transaction_add(globals, mac, ntohs(request->tx.id));
++		if (!head)
++			goto err;
++	}
++	clock_gettime(CLOCK_MONOTONIC, &head->last_rx_time);
+ 
+ 	head->txend_packets = ntohs(request->tx.seqno);
+ 	finish_alfred_transaction(globals, head, mac);
+ 
+ 	return 0;
++err:
++	return -1;
+ }
+ 
+ int recv_alfred_packet(struct globals *globals, struct interface *interface,
