From: Sven Eckelmann <sven@narfation.org>
Date: Tue, 20 Nov 2018 21:52:01 +0100
Subject: batman-adv: Penalize TQ based on SNR/signal of remote

Forwarded: no

diff --git a/batman-adv/patches/1003-batman-adv-mac80211-signal.patch b/batman-adv/patches/1003-batman-adv-mac80211-signal.patch
new file mode 100644
index 0000000000000000000000000000000000000000..dd2692cb95242bf5f245f7ff0b9d9004674d4bfb
--- /dev/null
+++ b/batman-adv/patches/1003-batman-adv-mac80211-signal.patch
@@ -0,0 +1,136 @@
+From: Antonio Quartulli <ordex@autistici.org>
+Date: Sat, 27 Oct 2012 15:50:38 +0200
+Subject: [PATCH] batman-adv: mac80211 signal
+
+Forwarded: not-needed
+ This is a private hack which will not be accepted by upstream. The
+ real solution here is to switch to B.A.T.M.A.N. V
+---
+ net/batman-adv/bat_iv_ogm.c | 107 +++++++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 106 insertions(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index 81931a3bead9b1645b0a4234f5b489738e742995..dbc232431d8d5d74169fe09a0c60a47f41c0c27e 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -1155,6 +1155,108 @@ batadv_iv_ogm_orig_update(struct batadv_priv *bat_priv,
+ 		batadv_neigh_ifinfo_put(router_ifinfo);
+ }
+ 
++int mac80211_get_signal(struct net_device *net_dev, const char *mac_addr, int *signal);
++
++/**
++ * batadv_signal_penalty - get penalty for signal quality of neighbor
++ * @bat_priv: the bat priv with all the soft interface information
++ * @net_dev: network device to check
++ * @mac_addr: address of the neighbor
++ *
++ * Return: penalty between 0 and BATADV_TQ_MAX_VALUE
++ */
++static unsigned int batadv_signal_penalty(struct batadv_priv *bat_priv,
++					  struct net_device *net_dev,
++					  const char *mac_addr)
++{
++	unsigned int penalty;
++	int signal;
++	int ret;
++
++	ret = mac80211_get_signal(net_dev, mac_addr, &signal);
++	if (ret < 0)
++		return 0;
++
++	if (signal >= -65)
++		/* signal >= -65       -> 0% penalty */
++		penalty = 0;
++	else if (signal >= -70)
++		/* -65 > signal >= -70 -> 10% penalty */
++		penalty = 25;
++	else if (signal >= -75)
++		/* -70 > signal >= -75 -> 25% penalty */
++		penalty = 63;
++	else if (signal >= -80)
++		/* -75 > signal >= -80 -> 50% penalty */
++		penalty = 127;
++	else
++		/* -80 > signal        -> 75% penalty */
++		penalty = 191;
++
++	batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
++		   "bidirectional (mac80211): %pM: signal: %i, penalty: %u%%\n",
++		   mac_addr, signal, (penalty * 100) / BATADV_TQ_MAX_VALUE);
++
++	return penalty;
++}
++
++/**
++ * batadv_wifi_penalty - get penalty for wifi neighbor
++ * @bat_priv: the bat priv with all the soft interface information
++ * @hardif: interface to check
++ * @mac_addr: address of the neighbor
++ *
++ * Return: penalty between 0 and BATADV_TQ_MAX_VALUE
++ */
++static unsigned int batadv_wifi_penalty(struct batadv_priv *bat_priv,
++					struct batadv_hard_iface *hardif,
++					const char *mac_addr)
++{
++	unsigned int signal_penalty;
++	unsigned int penalty;
++
++	if (!batadv_is_wifi_hardif(hardif))
++		return 0;
++
++	if (!batadv_is_cfg80211_hardif(hardif))
++		return 0;
++
++	penalty = 0;
++
++	signal_penalty = batadv_signal_penalty(bat_priv, hardif->net_dev,
++					       mac_addr);
++	penalty = max_t(unsigned int, penalty, signal_penalty);
++
++	return penalty;
++}
++
++/**
++ * batadv_apply_tq_penalty - apply penalty for neighbor
++ * @bat_priv: the bat priv with all the soft interface information
++ * @hardif: interface to check
++ * @mac_addr: address of the neighbor
++ * @combined_tq: unpenalized tq value for neighbor
++ *
++ * Return: new tq value with penalty applied
++ */
++static unsigned int batadv_apply_tq_penalty(struct batadv_priv *bat_priv,
++					    struct batadv_hard_iface *hardif,
++					    const char *mac_addr,
++					    unsigned int combined_tq)
++{
++	unsigned int wifi_penalty;
++	unsigned int penalty;
++	unsigned int remaining;
++
++	wifi_penalty = batadv_wifi_penalty(bat_priv, hardif, mac_addr);
++	wifi_penalty = min_t(unsigned int, wifi_penalty, BATADV_TQ_MAX_VALUE);
++
++	penalty = wifi_penalty;
++	remaining = BATADV_TQ_MAX_VALUE - penalty;
++
++	return (combined_tq * remaining) / BATADV_TQ_MAX_VALUE;
++}
++
+ /**
+  * batadv_iv_ogm_calc_tq - calculate tq for current received ogm packet
+  * @orig_node: the orig node who originally emitted the ogm packet
+@@ -1280,7 +1382,10 @@ static bool batadv_iv_ogm_calc_tq(struct batadv_orig_node *orig_node,
+ 	combined_tq /= BATADV_TQ_MAX_VALUE *
+ 		       BATADV_TQ_MAX_VALUE *
+ 		       BATADV_TQ_MAX_VALUE;
+-	batadv_ogm_packet->tq = combined_tq;
++	batadv_ogm_packet->tq = batadv_apply_tq_penalty(bat_priv,
++							if_incoming,
++							orig_neigh_node->orig,
++							combined_tq);
+ 
+ 	batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
+ 		   "bidirectional: orig = %-15pM neigh = %-15pM => own_bcast = %2i, real recv = %2i, local tq: %3i, asym_penalty: %3i, iface_penalty: %3i, total tq: %3i, if_incoming = %s, if_outgoing = %s\n",
