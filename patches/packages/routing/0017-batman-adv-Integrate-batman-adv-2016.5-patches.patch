From: Sven Eckelmann <sven@narfation.org>
Date: Sat, 3 Dec 2016 14:52:30 +0100
Subject: batman-adv: Integrate batman-adv 2016.5 patches

diff --git a/batman-adv/files/compat-hacks.h b/batman-adv/files/compat-hacks.h
index 32903b5..af91f41 100644
--- a/batman-adv/files/compat-hacks.h
+++ b/batman-adv/files/compat-hacks.h
@@ -49,6 +49,11 @@ int ipv6_mc_check_mld(struct sk_buff *skb, struct sk_buff **skb_trimmed);
 
 #define IFF_NO_QUEUE	0; dev->tx_queue_len = 0
 
+static inline bool hlist_fake(struct hlist_node *h)
+{
+	return h->pprev == &h->next;
+}
+
 #endif /* < KERNEL_VERSION(4, 3, 0) */
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
@@ -187,3 +192,15 @@ static inline int batadv_nla_put_u64_64bit(struct sk_buff *skb, int attrtype,
 
 #endif /* < KERNEL_VERSION(4, 7, 0) */
 
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+
+#include_next <linux/cache.h>
+
+/* hack for netlink.c which marked the family ops as ro */
+#ifdef __ro_after_init
+#undef __ro_after_init
+#endif
+#define __ro_after_init
+
+#endif /* < KERNEL_VERSION(4, 10, 0) */
diff --git a/batman-adv/patches/0006-batman-adv-Add-B.A.T.M.A.N.-V-sysfs-files-to-README.patch b/batman-adv/patches/0006-batman-adv-Add-B.A.T.M.A.N.-V-sysfs-files-to-README.patch
new file mode 100644
index 0000000..0aa3e15
--- /dev/null
+++ b/batman-adv/patches/0006-batman-adv-Add-B.A.T.M.A.N.-V-sysfs-files-to-README.patch
@@ -0,0 +1,22 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 16 Jul 2016 21:30:21 +0200
+Subject: [PATCH] batman-adv: Add B.A.T.M.A.N. V sysfs files to README
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ Documentation/networking/batman-adv.txt | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/Documentation/networking/batman-adv.txt b/Documentation/networking/batman-adv.txt
+index 8a8d3d9..d414e60 100644
+--- a/Documentation/networking/batman-adv.txt
++++ b/Documentation/networking/batman-adv.txt
+@@ -32,7 +32,7 @@ compatible interfaces. Once found, it will create  subfolders  in
+ the /sys directories of each supported interface, e.g.
+ 
+ # ls /sys/class/net/eth0/batman_adv/
+-# iface_status  mesh_iface
++# elp_interval  iface_status  mesh_iface  throughput_override
+ 
+ If an interface does not have the "batman_adv" subfolder it prob-
+ ably is not supported. Not supported  interfaces  are:  loopback,
diff --git a/batman-adv/patches/0007-batman-adv-Add-network_coding-and-mcast-sysfs-files-.patch b/batman-adv/patches/0007-batman-adv-Add-network_coding-and-mcast-sysfs-files-.patch
new file mode 100644
index 0000000..51b3643
--- /dev/null
+++ b/batman-adv/patches/0007-batman-adv-Add-network_coding-and-mcast-sysfs-files-.patch
@@ -0,0 +1,29 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 16 Jul 2016 21:30:22 +0200
+Subject: [PATCH] batman-adv: Add network_coding and mcast sysfs files to README
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ Documentation/networking/batman-adv.txt | 9 +++++----
+ 1 file changed, 5 insertions(+), 4 deletions(-)
+
+diff --git a/Documentation/networking/batman-adv.txt b/Documentation/networking/batman-adv.txt
+index d414e60..8afa991 100644
+--- a/Documentation/networking/batman-adv.txt
++++ b/Documentation/networking/batman-adv.txt
+@@ -71,10 +71,11 @@ All  mesh  wide  settings  can be found in batman's own interface
+ folder:
+ 
+ # ls /sys/class/net/bat0/mesh/
+-#aggregated_ogms        distributed_arp_table  gw_sel_class    orig_interval
+-#ap_isolation           fragmentation          hop_penalty     routing_algo
+-#bonding                gw_bandwidth           isolation_mark  vlan0
+-#bridge_loop_avoidance  gw_mode                log_level
++# aggregated_ogms        fragmentation  isolation_mark  routing_algo
++# ap_isolation           gw_bandwidth   log_level       vlan0
++# bonding                gw_mode        multicast_mode
++# bridge_loop_avoidance  gw_sel_class   network_coding
++# distributed_arp_table  hop_penalty    orig_interval
+ 
+ There is a special folder for debugging information:
+ 
diff --git a/batman-adv/patches/0008-batman-adv-Add-dat-mcast-nc-and-neighbor-debugfs-fil.patch b/batman-adv/patches/0008-batman-adv-Add-dat-mcast-nc-and-neighbor-debugfs-fil.patch
new file mode 100644
index 0000000..d3fe076
--- /dev/null
+++ b/batman-adv/patches/0008-batman-adv-Add-dat-mcast-nc-and-neighbor-debugfs-fil.patch
@@ -0,0 +1,27 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 16 Jul 2016 21:32:01 +0200
+Subject: [PATCH] batman-adv: Add dat, mcast, nc and neighbor debugfs files to README
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ Documentation/networking/batman-adv.txt | 7 ++++---
+ 1 file changed, 4 insertions(+), 3 deletions(-)
+
+diff --git a/Documentation/networking/batman-adv.txt b/Documentation/networking/batman-adv.txt
+index 8afa991..a918131 100644
+--- a/Documentation/networking/batman-adv.txt
++++ b/Documentation/networking/batman-adv.txt
+@@ -80,9 +80,10 @@ folder:
+ There is a special folder for debugging information:
+ 
+ # ls /sys/kernel/debug/batman_adv/bat0/
+-# bla_backbone_table  log                 transtable_global
+-# bla_claim_table     originators         transtable_local
+-# gateways            socket
++# bla_backbone_table  log          neighbors          transtable_local
++# bla_claim_table     mcast_flags  originators
++# dat_cache           nc           socket
++# gateways            nc_nodes     transtable_global
+ 
+ Some of the files contain all sort of status information  regard-
+ ing  the  mesh  network.  For  example, you can view the table of
diff --git a/batman-adv/patches/0009-batman-adv-Document-new-nc-mcast-and-tpmeter-log-lev.patch b/batman-adv/patches/0009-batman-adv-Document-new-nc-mcast-and-tpmeter-log-lev.patch
new file mode 100644
index 0000000..f17fcf0
--- /dev/null
+++ b/batman-adv/patches/0009-batman-adv-Document-new-nc-mcast-and-tpmeter-log-lev.patch
@@ -0,0 +1,37 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 16 Jul 2016 21:32:02 +0200
+Subject: [PATCH] batman-adv: Document new nc, mcast and tpmeter log levels
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ Documentation/networking/batman-adv.txt | 17 ++++++++++-------
+ 1 file changed, 10 insertions(+), 7 deletions(-)
+
+diff --git a/Documentation/networking/batman-adv.txt b/Documentation/networking/batman-adv.txt
+index a918131..ccf9467 100644
+--- a/Documentation/networking/batman-adv.txt
++++ b/Documentation/networking/batman-adv.txt
+@@ -161,13 +161,16 @@ file in debugfs
+ The additional debug output is by default disabled. It can be en-
+ abled  during run time. Following log_levels are defined:
+ 
+-0 - All  debug  output  disabled
+-1 - Enable messages related to routing / flooding / broadcasting
+-2 - Enable messages related to route added / changed / deleted
+-4 - Enable messages related to translation table operations
+-8 - Enable messages related to bridge loop avoidance
+-16 - Enable messaged related to DAT, ARP snooping and parsing
+-31 - Enable all messages
++  0 - All  debug  output  disabled
++  1 - Enable messages related to routing / flooding / broadcasting
++  2 - Enable messages related to route added / changed / deleted
++  4 - Enable messages related to translation table operations
++  8 - Enable messages related to bridge loop avoidance
++ 16 - Enable messages related to DAT, ARP snooping and parsing
++ 32 - Enable messages related to network coding
++ 64 - Enable messages related to multicast
++128 - Enable messages related to throughput meter
++255 - Enable all messages
+ 
+ The debug output can be changed at runtime  using  the  file
+ /sys/class/net/bat0/mesh/log_level. e.g.
diff --git a/batman-adv/patches/0010-batman-adv-Remove-unused-function-batadv_hash_delete.patch b/batman-adv/patches/0010-batman-adv-Remove-unused-function-batadv_hash_delete.patch
new file mode 100644
index 0000000..15a6cfd
--- /dev/null
+++ b/batman-adv/patches/0010-batman-adv-Remove-unused-function-batadv_hash_delete.patch
@@ -0,0 +1,50 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 22 Jul 2016 01:30:09 +0200
+Subject: [PATCH] batman-adv: Remove unused function batadv_hash_delete
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/hash.h | 30 ------------------------------
+ 1 file changed, 30 deletions(-)
+
+diff --git a/net/batman-adv/hash.h b/net/batman-adv/hash.h
+index cbbf870..557a704 100644
+--- a/net/batman-adv/hash.h
++++ b/net/batman-adv/hash.h
+@@ -61,36 +61,6 @@ void batadv_hash_set_lock_class(struct batadv_hashtable *hash,
+ /* free only the hashtable and the hash itself. */
+ void batadv_hash_destroy(struct batadv_hashtable *hash);
+ 
+-/* remove the hash structure. if hashdata_free_cb != NULL, this function will be
+- * called to remove the elements inside of the hash.  if you don't remove the
+- * elements, memory might be leaked.
+- */
+-static inline void batadv_hash_delete(struct batadv_hashtable *hash,
+-				      batadv_hashdata_free_cb free_cb,
+-				      void *arg)
+-{
+-	struct hlist_head *head;
+-	struct hlist_node *node, *node_tmp;
+-	spinlock_t *list_lock; /* spinlock to protect write access */
+-	u32 i;
+-
+-	for (i = 0; i < hash->size; i++) {
+-		head = &hash->table[i];
+-		list_lock = &hash->list_locks[i];
+-
+-		spin_lock_bh(list_lock);
+-		hlist_for_each_safe(node, node_tmp, head) {
+-			hlist_del_rcu(node);
+-
+-			if (free_cb)
+-				free_cb(node, arg);
+-		}
+-		spin_unlock_bh(list_lock);
+-	}
+-
+-	batadv_hash_destroy(hash);
+-}
+-
+ /**
+  *	batadv_hash_add - adds data to the hashtable
+  *	@hash: storage hash table
diff --git a/batman-adv/patches/0011-batman-adv-Move-batadv_sum_counter-to-soft-interface.patch b/batman-adv/patches/0011-batman-adv-Move-batadv_sum_counter-to-soft-interface.patch
new file mode 100644
index 0000000..e22f9c2
--- /dev/null
+++ b/batman-adv/patches/0011-batman-adv-Move-batadv_sum_counter-to-soft-interface.patch
@@ -0,0 +1,91 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 22 Jul 2016 01:30:10 +0200
+Subject: [PATCH] batman-adv: Move batadv_sum_counter to soft-interface.c
+
+The function batadv_sum_counter is only used in soft-interface.c and has no
+special relevance for main.h.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/main.h           | 21 ---------------------
+ net/batman-adv/soft-interface.c | 21 +++++++++++++++++++++
+ 2 files changed, 21 insertions(+), 21 deletions(-)
+
+diff --git a/net/batman-adv/main.h b/net/batman-adv/main.h
+index 09af21e..7f44b26 100644
+--- a/net/batman-adv/main.h
++++ b/net/batman-adv/main.h
+@@ -185,7 +185,6 @@ enum batadv_uev_type {
+ 
+ #include <linux/bitops.h> /* for packet.h */
+ #include <linux/compiler.h>
+-#include <linux/cpumask.h>
+ #include <linux/etherdevice.h>
+ #include <linux/if_ether.h> /* for packet.h */
+ #include <linux/if_vlan.h>
+@@ -284,26 +283,6 @@ static inline void batadv_add_counter(struct batadv_priv *bat_priv, size_t idx,
+ 
+ #define batadv_inc_counter(b, i) batadv_add_counter(b, i, 1)
+ 
+-/**
+- * batadv_sum_counter - Sum the cpu-local counters for index 'idx'
+- * @bat_priv: the bat priv with all the soft interface information
+- * @idx: index of counter to sum up
+- *
+- * Return: sum of all cpu-local counters
+- */
+-static inline u64 batadv_sum_counter(struct batadv_priv *bat_priv,  size_t idx)
+-{
+-	u64 *counters, sum = 0;
+-	int cpu;
+-
+-	for_each_possible_cpu(cpu) {
+-		counters = per_cpu_ptr(bat_priv->bat_counters, cpu);
+-		sum += counters[idx];
+-	}
+-
+-	return sum;
+-}
+-
+ /* Define a macro to reach the control buffer of the skb. The members of the
+  * control buffer are defined in struct batadv_skb_cb in types.h.
+  * The macro is inspired by the similar macro TCP_SKB_CB() in tcp.h.
+diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
+index 49e16b6..f37c1c7 100644
+--- a/net/batman-adv/soft-interface.c
++++ b/net/batman-adv/soft-interface.c
+@@ -22,6 +22,7 @@
+ #include <linux/byteorder/generic.h>
+ #include <linux/cache.h>
+ #include <linux/compiler.h>
++#include <linux/cpumask.h>
+ #include <linux/errno.h>
+ #include <linux/etherdevice.h>
+ #include <linux/ethtool.h>
+@@ -116,6 +117,26 @@ static int batadv_interface_release(struct net_device *dev)
+ 	return 0;
+ }
+ 
++/**
++ * batadv_sum_counter - Sum the cpu-local counters for index 'idx'
++ * @bat_priv: the bat priv with all the soft interface information
++ * @idx: index of counter to sum up
++ *
++ * Return: sum of all cpu-local counters
++ */
++static u64 batadv_sum_counter(struct batadv_priv *bat_priv,  size_t idx)
++{
++	u64 *counters, sum = 0;
++	int cpu;
++
++	for_each_possible_cpu(cpu) {
++		counters = per_cpu_ptr(bat_priv->bat_counters, cpu);
++		sum += counters[idx];
++	}
++
++	return sum;
++}
++
+ static struct net_device_stats *batadv_interface_stats(struct net_device *dev)
+ {
+ 	struct batadv_priv *bat_priv = netdev_priv(dev);
diff --git a/batman-adv/patches/0012-batman-adv-Remove-unused-batadv_icmp_user_cmd_type.patch b/batman-adv/patches/0012-batman-adv-Remove-unused-batadv_icmp_user_cmd_type.patch
new file mode 100644
index 0000000..a3536a7
--- /dev/null
+++ b/batman-adv/patches/0012-batman-adv-Remove-unused-batadv_icmp_user_cmd_type.patch
@@ -0,0 +1,30 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 22 Jul 2016 01:30:11 +0200
+Subject: [PATCH] batman-adv: Remove unused batadv_icmp_user_cmd_type
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/packet.h | 10 ----------
+ 1 file changed, 10 deletions(-)
+
+diff --git a/net/batman-adv/packet.h b/net/batman-adv/packet.h
+index 6afc0b8..d2e9bbd 100644
+--- a/net/batman-adv/packet.h
++++ b/net/batman-adv/packet.h
+@@ -252,16 +252,6 @@ struct batadv_elp_packet {
+ #define BATADV_ELP_HLEN sizeof(struct batadv_elp_packet)
+ 
+ /**
+- * enum batadv_icmp_user_cmd_type - types for batman-adv icmp cmd modes
+- * @BATADV_TP_START: start a throughput meter run
+- * @BATADV_TP_STOP: stop a throughput meter run
+- */
+-enum batadv_icmp_user_cmd_type {
+-	BATADV_TP_START		= 0,
+-	BATADV_TP_STOP		= 2,
+-};
+-
+-/**
+  * struct batadv_icmp_header - common members among all the ICMP packets
+  * @packet_type: batman-adv packet type, part of the general header
+  * @version: batman-adv protocol version, part of the genereal header
diff --git a/batman-adv/patches/0013-batman-adv-fix-batadv_forw_packet-kerneldoc-for-list.patch b/batman-adv/patches/0013-batman-adv-fix-batadv_forw_packet-kerneldoc-for-list.patch
new file mode 100644
index 0000000..5f0edf7
--- /dev/null
+++ b/batman-adv/patches/0013-batman-adv-fix-batadv_forw_packet-kerneldoc-for-list.patch
@@ -0,0 +1,25 @@
+From: Linus Lüssing <linus.luessing@c0d3.blue>
+Date: Tue, 23 Aug 2016 03:13:16 +0200
+Subject: [PATCH] batman-adv: fix batadv_forw_packet kerneldoc for list attribute
+
+The forw_packet list node is wrongly attributed to the icmp socket code.
+
+Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/types.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index b3dd1a3..97336ec 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -1363,7 +1363,7 @@ struct batadv_skb_cb {
+ 
+ /**
+  * struct batadv_forw_packet - structure for bcast packets to be sent/forwarded
+- * @list: list node for batadv_socket_client::queue_list
++ * @list: list node for batadv_priv::forw_{bat,bcast}_list
+  * @send_time: execution time for delayed_work (packet sending)
+  * @own: bool for locally generated packets (local OGMs are re-scheduled after
+  *  sending)
diff --git a/batman-adv/patches/0014-batman-adv-Allow-selecting-BATMAN-V-if-CFG80211-is-n.patch b/batman-adv/patches/0014-batman-adv-Allow-selecting-BATMAN-V-if-CFG80211-is-n.patch
new file mode 100644
index 0000000..08c47f1
--- /dev/null
+++ b/batman-adv/patches/0014-batman-adv-Allow-selecting-BATMAN-V-if-CFG80211-is-n.patch
@@ -0,0 +1,59 @@
+From: Linus Lüssing <linus.luessing@c0d3.blue>
+Date: Tue, 20 Sep 2016 15:59:17 +0200
+Subject: [PATCH] batman-adv: Allow selecting BATMAN V if CFG80211 is not built
+
+With the new stub for cfg80211_get_station(), we can now build the
+BATMAN V protocol even with a kernel that was built without any
+wireless support.
+
+Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ compat-include/net/cfg80211.h | 24 ++++++++++++++++++++++++
+ net/batman-adv/Kconfig        |  2 +-
+ 2 files changed, 25 insertions(+), 1 deletion(-)
+ create mode 100644 compat-include/net/cfg80211.h
+
+diff --git a/compat-include/net/cfg80211.h b/compat-include/net/cfg80211.h
+new file mode 100644
+index 0000000..8dbbf0e
+--- /dev/null
++++ b/compat-include/net/cfg80211.h
+@@ -0,0 +1,24 @@
++#ifndef _NET_BATMAN_ADV_COMPAT_NET_CFG80211_H_
++#define _NET_BATMAN_ADV_COMPAT_NET_CFG80211_H_
++
++#include <linux/version.h>
++#include_next <net/cfg80211.h>
++
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
++
++#if !IS_ENABLED(CONFIG_CFG80211)
++
++#define cfg80211_get_station(dev, mac_addr, sinfo) \
++	batadv_cfg80211_get_station(dev, mac_addr, sinfo)
++
++static inline int batadv_cfg80211_get_station(struct net_device *dev,
++					      const u8 *mac_addr,
++					      struct station_info *sinfo)
++{
++	return -ENOENT;
++}
++#endif
++
++#endif /* < KERNEL_VERSION(4, 8, 0) */
++
++#endif	/* _NET_BATMAN_ADV_COMPAT_NET_CFG80211_H_ */
+diff --git a/net/batman-adv/Kconfig b/net/batman-adv/Kconfig
+index f20742c..b73b96a 100644
+--- a/net/batman-adv/Kconfig
++++ b/net/batman-adv/Kconfig
+@@ -17,7 +17,7 @@ config BATMAN_ADV
+ 
+ config BATMAN_ADV_BATMAN_V
+ 	bool "B.A.T.M.A.N. V protocol (experimental)"
+-	depends on BATMAN_ADV && CFG80211=y || (CFG80211=m && BATMAN_ADV=m)
++	depends on BATMAN_ADV && !(CFG80211=m && BATMAN_ADV=y)
+ 	default n
+ 	help
+ 	  This option enables the B.A.T.M.A.N. V protocol, the successor
diff --git a/batman-adv/patches/0015-batman-adv-remove-unsed-argument-from-batadv_dbg_arp.patch b/batman-adv/patches/0015-batman-adv-remove-unsed-argument-from-batadv_dbg_arp.patch
new file mode 100644
index 0000000..d53c548
--- /dev/null
+++ b/batman-adv/patches/0015-batman-adv-remove-unsed-argument-from-batadv_dbg_arp.patch
@@ -0,0 +1,80 @@
+From: Antonio Quartulli <a@unstable.cc>
+Date: Sun, 25 Sep 2016 08:46:36 +0800
+Subject: [PATCH] batman-adv: remove unsed argument from batadv_dbg_arp() function
+
+The argument "type" passed to the batadv_dbg_arp() function is
+never used. Remove it.
+
+Signed-off-by: Antonio Quartulli <a@unstable.cc>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/distributed-arp-table.c | 17 ++++++-----------
+ 1 file changed, 6 insertions(+), 11 deletions(-)
+
+diff --git a/net/batman-adv/distributed-arp-table.c b/net/batman-adv/distributed-arp-table.c
+index e257efd..cbb4f32 100644
+--- a/net/batman-adv/distributed-arp-table.c
++++ b/net/batman-adv/distributed-arp-table.c
+@@ -369,12 +369,11 @@ out:
+  * batadv_dbg_arp - print a debug message containing all the ARP packet details
+  * @bat_priv: the bat priv with all the soft interface information
+  * @skb: ARP packet
+- * @type: ARP type
+  * @hdr_size: size of the possible header before the ARP packet
+  * @msg: message to print together with the debugging information
+  */
+ static void batadv_dbg_arp(struct batadv_priv *bat_priv, struct sk_buff *skb,
+-			   u16 type, int hdr_size, char *msg)
++			   int hdr_size, char *msg)
+ {
+ 	struct batadv_unicast_4addr_packet *unicast_4addr_packet;
+ 	struct batadv_bcast_packet *bcast_pkt;
+@@ -441,7 +440,7 @@ static void batadv_dbg_arp(struct batadv_priv *bat_priv, struct sk_buff *skb,
+ #else
+ 
+ static void batadv_dbg_arp(struct batadv_priv *bat_priv, struct sk_buff *skb,
+-			   u16 type, int hdr_size, char *msg)
++			   int hdr_size, char *msg)
+ {
+ }
+ 
+@@ -983,8 +982,7 @@ bool batadv_dat_snoop_outgoing_arp_request(struct batadv_priv *bat_priv,
+ 	if (type != ARPOP_REQUEST)
+ 		goto out;
+ 
+-	batadv_dbg_arp(bat_priv, skb, type, hdr_size,
+-		       "Parsing outgoing ARP REQUEST");
++	batadv_dbg_arp(bat_priv, skb, hdr_size, "Parsing outgoing ARP REQUEST");
+ 
+ 	ip_src = batadv_arp_ip_src(skb, hdr_size);
+ 	hw_src = batadv_arp_hw_src(skb, hdr_size);
+@@ -1075,8 +1073,7 @@ bool batadv_dat_snoop_incoming_arp_request(struct batadv_priv *bat_priv,
+ 	ip_src = batadv_arp_ip_src(skb, hdr_size);
+ 	ip_dst = batadv_arp_ip_dst(skb, hdr_size);
+ 
+-	batadv_dbg_arp(bat_priv, skb, type, hdr_size,
+-		       "Parsing incoming ARP REQUEST");
++	batadv_dbg_arp(bat_priv, skb, hdr_size, "Parsing incoming ARP REQUEST");
+ 
+ 	batadv_dat_entry_add(bat_priv, ip_src, hw_src, vid);
+ 
+@@ -1149,8 +1146,7 @@ void batadv_dat_snoop_outgoing_arp_reply(struct batadv_priv *bat_priv,
+ 	if (type != ARPOP_REPLY)
+ 		return;
+ 
+-	batadv_dbg_arp(bat_priv, skb, type, hdr_size,
+-		       "Parsing outgoing ARP REPLY");
++	batadv_dbg_arp(bat_priv, skb, hdr_size, "Parsing outgoing ARP REPLY");
+ 
+ 	hw_src = batadv_arp_hw_src(skb, hdr_size);
+ 	ip_src = batadv_arp_ip_src(skb, hdr_size);
+@@ -1195,8 +1191,7 @@ bool batadv_dat_snoop_incoming_arp_reply(struct batadv_priv *bat_priv,
+ 	if (type != ARPOP_REPLY)
+ 		goto out;
+ 
+-	batadv_dbg_arp(bat_priv, skb, type, hdr_size,
+-		       "Parsing incoming ARP REPLY");
++	batadv_dbg_arp(bat_priv, skb, hdr_size, "Parsing incoming ARP REPLY");
+ 
+ 	hw_src = batadv_arp_hw_src(skb, hdr_size);
+ 	ip_src = batadv_arp_ip_src(skb, hdr_size);
diff --git a/batman-adv/patches/0016-batman-adv-Less-function-calls-in-batadv_is_ap_isola.patch b/batman-adv/patches/0016-batman-adv-Less-function-calls-in-batadv_is_ap_isola.patch
new file mode 100644
index 0000000..76b229c
--- /dev/null
+++ b/batman-adv/patches/0016-batman-adv-Less-function-calls-in-batadv_is_ap_isola.patch
@@ -0,0 +1,70 @@
+From: Markus Elfring <elfring@users.sourceforge.net>
+Date: Fri, 11 Mar 2016 13:10:20 +0100
+Subject: [PATCH] batman-adv: Less function calls in batadv_is_ap_isolated() after error detection
+
+The variables "tt_local_entry" and "tt_global_entry" were eventually
+checked again despite of a corresponding null pointer test before.
+
+* Avoid this double check by reordering a function call sequence
+  and the better selection of jump targets.
+
+* Omit the initialisation for these variables at the beginning then.
+
+Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/translation-table.c | 25 +++++++++++--------------
+ 1 file changed, 11 insertions(+), 14 deletions(-)
+
+diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
+index 0dc85eb..956950a 100644
+--- a/net/batman-adv/translation-table.c
++++ b/net/batman-adv/translation-table.c
+@@ -3835,8 +3835,8 @@ void batadv_tt_local_commit_changes(struct batadv_priv *bat_priv)
+ bool batadv_is_ap_isolated(struct batadv_priv *bat_priv, u8 *src, u8 *dst,
+ 			   unsigned short vid)
+ {
+-	struct batadv_tt_local_entry *tt_local_entry = NULL;
+-	struct batadv_tt_global_entry *tt_global_entry = NULL;
++	struct batadv_tt_local_entry *tt_local_entry;
++	struct batadv_tt_global_entry *tt_global_entry;
+ 	struct batadv_softif_vlan *vlan;
+ 	bool ret = false;
+ 
+@@ -3845,27 +3845,24 @@ bool batadv_is_ap_isolated(struct batadv_priv *bat_priv, u8 *src, u8 *dst,
+ 		return false;
+ 
+ 	if (!atomic_read(&vlan->ap_isolation))
+-		goto out;
++		goto vlan_put;
+ 
+ 	tt_local_entry = batadv_tt_local_hash_find(bat_priv, dst, vid);
+ 	if (!tt_local_entry)
+-		goto out;
++		goto vlan_put;
+ 
+ 	tt_global_entry = batadv_tt_global_hash_find(bat_priv, src, vid);
+ 	if (!tt_global_entry)
+-		goto out;
++		goto local_entry_put;
+ 
+-	if (!_batadv_is_ap_isolated(tt_local_entry, tt_global_entry))
+-		goto out;
++	if (_batadv_is_ap_isolated(tt_local_entry, tt_global_entry))
++		ret = true;
+ 
+-	ret = true;
+-
+-out:
++	batadv_tt_global_entry_put(tt_global_entry);
++local_entry_put:
++	batadv_tt_local_entry_put(tt_local_entry);
++vlan_put:
+ 	batadv_softif_vlan_put(vlan);
+-	if (tt_global_entry)
+-		batadv_tt_global_entry_put(tt_global_entry);
+-	if (tt_local_entry)
+-		batadv_tt_local_entry_put(tt_local_entry);
+ 	return ret;
+ }
+ 
diff --git a/batman-adv/patches/0017-batman-adv-Remove-needless-init-of-variables-on-stac.patch b/batman-adv/patches/0017-batman-adv-Remove-needless-init-of-variables-on-stac.patch
new file mode 100644
index 0000000..aad5ebe
--- /dev/null
+++ b/batman-adv/patches/0017-batman-adv-Remove-needless-init-of-variables-on-stac.patch
@@ -0,0 +1,118 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Mon, 25 Jul 2016 00:42:44 +0200
+Subject: [PATCH] batman-adv: Remove needless init of variables on stack
+
+Some variables are overwritten immediatelly in a functions. These don't
+have to be initialized to a specific value on the stack because the value
+will be overwritten before they will be used anywhere.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/bat_v.c          | 2 +-
+ net/batman-adv/bat_v_ogm.c      | 4 ++--
+ net/batman-adv/gateway_client.c | 2 +-
+ net/batman-adv/originator.c     | 8 ++++----
+ net/batman-adv/send.c           | 2 +-
+ 5 files changed, 9 insertions(+), 9 deletions(-)
+
+diff --git a/net/batman-adv/bat_v.c b/net/batman-adv/bat_v.c
+index e79f6f0..57c795c 100644
+--- a/net/batman-adv/bat_v.c
++++ b/net/batman-adv/bat_v.c
+@@ -787,7 +787,7 @@ static bool batadv_v_gw_is_eligible(struct batadv_priv *bat_priv,
+ 				    struct batadv_orig_node *curr_gw_orig,
+ 				    struct batadv_orig_node *orig_node)
+ {
+-	struct batadv_gw_node *curr_gw = NULL, *orig_gw = NULL;
++	struct batadv_gw_node *curr_gw, *orig_gw = NULL;
+ 	u32 gw_throughput, orig_throughput, threshold;
+ 	bool ret = false;
+ 
+diff --git a/net/batman-adv/bat_v_ogm.c b/net/batman-adv/bat_v_ogm.c
+index 1aeeadc..61ff5f8 100644
+--- a/net/batman-adv/bat_v_ogm.c
++++ b/net/batman-adv/bat_v_ogm.c
+@@ -401,7 +401,7 @@ static int batadv_v_ogm_metric_update(struct batadv_priv *bat_priv,
+ 				      struct batadv_hard_iface *if_incoming,
+ 				      struct batadv_hard_iface *if_outgoing)
+ {
+-	struct batadv_orig_ifinfo *orig_ifinfo = NULL;
++	struct batadv_orig_ifinfo *orig_ifinfo;
+ 	struct batadv_neigh_ifinfo *neigh_ifinfo = NULL;
+ 	bool protection_started = false;
+ 	int ret = -EINVAL;
+@@ -486,7 +486,7 @@ static bool batadv_v_ogm_route_update(struct batadv_priv *bat_priv,
+ 				      struct batadv_hard_iface *if_outgoing)
+ {
+ 	struct batadv_neigh_node *router = NULL;
+-	struct batadv_orig_node *orig_neigh_node = NULL;
++	struct batadv_orig_node *orig_neigh_node;
+ 	struct batadv_neigh_node *orig_neigh_router = NULL;
+ 	struct batadv_neigh_ifinfo *router_ifinfo = NULL, *neigh_ifinfo = NULL;
+ 	u32 router_throughput, neigh_throughput;
+diff --git a/net/batman-adv/gateway_client.c b/net/batman-adv/gateway_client.c
+index de055d6..69bfe98 100644
+--- a/net/batman-adv/gateway_client.c
++++ b/net/batman-adv/gateway_client.c
+@@ -704,7 +704,7 @@ bool batadv_gw_out_of_range(struct batadv_priv *bat_priv,
+ {
+ 	struct batadv_neigh_node *neigh_curr = NULL;
+ 	struct batadv_neigh_node *neigh_old = NULL;
+-	struct batadv_orig_node *orig_dst_node = NULL;
++	struct batadv_orig_node *orig_dst_node;
+ 	struct batadv_gw_node *gw_node = NULL;
+ 	struct batadv_gw_node *curr_gw = NULL;
+ 	struct batadv_neigh_ifinfo *curr_ifinfo, *old_ifinfo;
+diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
+index 7c8d160..160d545 100644
+--- a/net/batman-adv/originator.c
++++ b/net/batman-adv/originator.c
+@@ -364,7 +364,7 @@ struct batadv_orig_ifinfo *
+ batadv_orig_ifinfo_new(struct batadv_orig_node *orig_node,
+ 		       struct batadv_hard_iface *if_outgoing)
+ {
+-	struct batadv_orig_ifinfo *orig_ifinfo = NULL;
++	struct batadv_orig_ifinfo *orig_ifinfo;
+ 	unsigned long reset_time;
+ 
+ 	spin_lock_bh(&orig_node->neigh_list_lock);
+@@ -520,7 +520,7 @@ batadv_hardif_neigh_create(struct batadv_hard_iface *hard_iface,
+ 			   const u8 *neigh_addr)
+ {
+ 	struct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);
+-	struct batadv_hardif_neigh_node *hardif_neigh = NULL;
++	struct batadv_hardif_neigh_node *hardif_neigh;
+ 
+ 	spin_lock_bh(&hard_iface->neigh_list_lock);
+ 
+@@ -563,7 +563,7 @@ static struct batadv_hardif_neigh_node *
+ batadv_hardif_neigh_get_or_create(struct batadv_hard_iface *hard_iface,
+ 				  const u8 *neigh_addr)
+ {
+-	struct batadv_hardif_neigh_node *hardif_neigh = NULL;
++	struct batadv_hardif_neigh_node *hardif_neigh;
+ 
+ 	/* first check without locking to avoid the overhead */
+ 	hardif_neigh = batadv_hardif_neigh_get(hard_iface, neigh_addr);
+@@ -683,7 +683,7 @@ batadv_neigh_node_get_or_create(struct batadv_orig_node *orig_node,
+ 				struct batadv_hard_iface *hard_iface,
+ 				const u8 *neigh_addr)
+ {
+-	struct batadv_neigh_node *neigh_node = NULL;
++	struct batadv_neigh_node *neigh_node;
+ 
+ 	/* first check without locking to avoid the overhead */
+ 	neigh_node = batadv_neigh_node_get(orig_node, hard_iface, neigh_addr);
+diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
+index 8d4e1f5..e1e9136 100644
+--- a/net/batman-adv/send.c
++++ b/net/batman-adv/send.c
+@@ -562,7 +562,7 @@ int batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+ 				    const struct sk_buff *skb,
+ 				    unsigned long delay)
+ {
+-	struct batadv_hard_iface *primary_if = NULL;
++	struct batadv_hard_iface *primary_if;
+ 	struct batadv_forw_packet *forw_packet;
+ 	struct batadv_bcast_packet *bcast_packet;
+ 	struct sk_buff *newskb;
diff --git a/batman-adv/patches/0018-batman-adv-Use-proper-name-for-fragments-list-head.patch b/batman-adv/patches/0018-batman-adv-Use-proper-name-for-fragments-list-head.patch
new file mode 100644
index 0000000..738c301
--- /dev/null
+++ b/batman-adv/patches/0018-batman-adv-Use-proper-name-for-fragments-list-head.patch
@@ -0,0 +1,123 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Wed, 27 Jul 2016 12:31:07 +0200
+Subject: [PATCH] batman-adv: Use proper name for fragments list head
+
+The batman-adv codebase is using "list" for the list node (prev/next) and
+<list content descriptor>+"_list" for the head of a list. Not using this
+naming scheme can up in confusions because list_head is used for both the
+head of the list and the list node (prev/next) in each item of the list.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/fragmentation.c | 14 +++++++-------
+ net/batman-adv/fragmentation.h |  2 +-
+ net/batman-adv/originator.c    |  2 +-
+ net/batman-adv/types.h         |  6 +++---
+ 4 files changed, 12 insertions(+), 12 deletions(-)
+
+diff --git a/net/batman-adv/fragmentation.c b/net/batman-adv/fragmentation.c
+index 0934730..f725918 100644
+--- a/net/batman-adv/fragmentation.c
++++ b/net/batman-adv/fragmentation.c
+@@ -73,7 +73,7 @@ void batadv_frag_purge_orig(struct batadv_orig_node *orig_node,
+ 		spin_lock_bh(&chain->lock);
+ 
+ 		if (!check_cb || check_cb(chain)) {
+-			batadv_frag_clear_chain(&chain->head);
++			batadv_frag_clear_chain(&chain->fragment_list);
+ 			chain->size = 0;
+ 		}
+ 
+@@ -117,8 +117,8 @@ static bool batadv_frag_init_chain(struct batadv_frag_table_entry *chain,
+ 	if (chain->seqno == seqno)
+ 		return false;
+ 
+-	if (!hlist_empty(&chain->head))
+-		batadv_frag_clear_chain(&chain->head);
++	if (!hlist_empty(&chain->fragment_list))
++		batadv_frag_clear_chain(&chain->fragment_list);
+ 
+ 	chain->size = 0;
+ 	chain->seqno = seqno;
+@@ -176,7 +176,7 @@ static bool batadv_frag_insert_packet(struct batadv_orig_node *orig_node,
+ 	chain = &orig_node->fragments[bucket];
+ 	spin_lock_bh(&chain->lock);
+ 	if (batadv_frag_init_chain(chain, seqno)) {
+-		hlist_add_head(&frag_entry_new->list, &chain->head);
++		hlist_add_head(&frag_entry_new->list, &chain->fragment_list);
+ 		chain->size = skb->len - hdr_size;
+ 		chain->timestamp = jiffies;
+ 		chain->total_size = ntohs(frag_packet->total_size);
+@@ -185,7 +185,7 @@ static bool batadv_frag_insert_packet(struct batadv_orig_node *orig_node,
+ 	}
+ 
+ 	/* Find the position for the new fragment. */
+-	hlist_for_each_entry(frag_entry_curr, &chain->head, list) {
++	hlist_for_each_entry(frag_entry_curr, &chain->fragment_list, list) {
+ 		/* Drop packet if fragment already exists. */
+ 		if (frag_entry_curr->no == frag_entry_new->no)
+ 			goto err_unlock;
+@@ -220,11 +220,11 @@ out:
+ 		 * exceeds the maximum size of one merged packet. Don't allow
+ 		 * packets to have different total_size.
+ 		 */
+-		batadv_frag_clear_chain(&chain->head);
++		batadv_frag_clear_chain(&chain->fragment_list);
+ 		chain->size = 0;
+ 	} else if (ntohs(frag_packet->total_size) == chain->size) {
+ 		/* All fragments received. Hand over chain to caller. */
+-		hlist_move_list(&chain->head, chain_out);
++		hlist_move_list(&chain->fragment_list, chain_out);
+ 		chain->size = 0;
+ 	}
+ 
+diff --git a/net/batman-adv/fragmentation.h b/net/batman-adv/fragmentation.h
+index 3202fe3..b95f619 100644
+--- a/net/batman-adv/fragmentation.h
++++ b/net/batman-adv/fragmentation.h
+@@ -47,7 +47,7 @@ int batadv_frag_send_packet(struct sk_buff *skb,
+ static inline bool
+ batadv_frag_check_entry(struct batadv_frag_table_entry *frags_entry)
+ {
+-	if (!hlist_empty(&frags_entry->head) &&
++	if (!hlist_empty(&frags_entry->fragment_list) &&
+ 	    batadv_has_timed_out(frags_entry->timestamp, BATADV_FRAG_TIMEOUT))
+ 		return true;
+ 	return false;
+diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
+index 160d545..c6e7e1e 100644
+--- a/net/batman-adv/originator.c
++++ b/net/batman-adv/originator.c
+@@ -1021,7 +1021,7 @@ struct batadv_orig_node *batadv_orig_node_new(struct batadv_priv *bat_priv,
+ 	batadv_orig_node_vlan_put(vlan);
+ 
+ 	for (i = 0; i < BATADV_FRAG_BUFFER_COUNT; i++) {
+-		INIT_HLIST_HEAD(&orig_node->fragments[i].head);
++		INIT_HLIST_HEAD(&orig_node->fragments[i].fragment_list);
+ 		spin_lock_init(&orig_node->fragments[i].lock);
+ 		orig_node->fragments[i].size = 0;
+ 	}
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 97336ec..d31e7ec 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -184,7 +184,7 @@ struct batadv_orig_ifinfo {
+ 
+ /**
+  * struct batadv_frag_table_entry - head in the fragment buffer table
+- * @head: head of list with fragments
++ * @fragment_list: head of list with fragments
+  * @lock: lock to protect the list of fragments
+  * @timestamp: time (jiffie) of last received fragment
+  * @seqno: sequence number of the fragments in the list
+@@ -192,8 +192,8 @@ struct batadv_orig_ifinfo {
+  * @total_size: expected size of the assembled packet
+  */
+ struct batadv_frag_table_entry {
+-	struct hlist_head head;
+-	spinlock_t lock; /* protects head */
++	struct hlist_head fragment_list;
++	spinlock_t lock; /* protects fragment_list */
+ 	unsigned long timestamp;
+ 	u16 seqno;
+ 	u16 size;
diff --git a/batman-adv/patches/0019-batman-adv-Use-proper-name-for-gateway-list-head.patch b/batman-adv/patches/0019-batman-adv-Use-proper-name-for-gateway-list-head.patch
new file mode 100644
index 0000000..dae99dc
--- /dev/null
+++ b/batman-adv/patches/0019-batman-adv-Use-proper-name-for-gateway-list-head.patch
@@ -0,0 +1,150 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Wed, 27 Jul 2016 12:31:08 +0200
+Subject: [PATCH] batman-adv: Use proper name for gateway list head
+
+The batman-adv codebase is using "list" for the list node (prev/next) and
+<list content descriptor>+"_list" for the head of a list. Not using this
+naming scheme can up in confusions when reading the code.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/bat_iv_ogm.c     | 6 +++---
+ net/batman-adv/bat_v.c          | 6 +++---
+ net/batman-adv/gateway_client.c | 7 ++++---
+ net/batman-adv/main.c           | 2 +-
+ net/batman-adv/types.h          | 8 ++++----
+ 5 files changed, 15 insertions(+), 14 deletions(-)
+
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index e2d18d0..0b9be62 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -2486,7 +2486,7 @@ batadv_iv_gw_get_best_gw_node(struct batadv_priv *bat_priv)
+ 	struct batadv_orig_node *orig_node;
+ 
+ 	rcu_read_lock();
+-	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.gateway_list, list) {
+ 		orig_node = gw_node->orig_node;
+ 		router = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);
+ 		if (!router)
+@@ -2674,7 +2674,7 @@ static void batadv_iv_gw_print(struct batadv_priv *bat_priv,
+ 		 "      Gateway      (#/255)           Nexthop [outgoingIF]: advertised uplink bandwidth\n");
+ 
+ 	rcu_read_lock();
+-	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.gateway_list, list) {
+ 		/* fails if orig_node has no router */
+ 		if (batadv_iv_gw_write_buffer_text(bat_priv, seq, gw_node) < 0)
+ 			continue;
+@@ -2774,7 +2774,7 @@ static void batadv_iv_gw_dump(struct sk_buff *msg, struct netlink_callback *cb,
+ 	int idx = 0;
+ 
+ 	rcu_read_lock();
+-	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.gateway_list, list) {
+ 		if (idx++ < idx_skip)
+ 			continue;
+ 
+diff --git a/net/batman-adv/bat_v.c b/net/batman-adv/bat_v.c
+index 57c795c..2ac612d 100644
+--- a/net/batman-adv/bat_v.c
++++ b/net/batman-adv/bat_v.c
+@@ -750,7 +750,7 @@ batadv_v_gw_get_best_gw_node(struct batadv_priv *bat_priv)
+ 	u32 max_bw = 0, bw;
+ 
+ 	rcu_read_lock();
+-	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.gateway_list, list) {
+ 		if (!kref_get_unless_zero(&gw_node->refcount))
+ 			continue;
+ 
+@@ -889,7 +889,7 @@ static void batadv_v_gw_print(struct batadv_priv *bat_priv,
+ 		 "      Gateway        ( throughput)           Nexthop [outgoingIF]: advertised uplink bandwidth\n");
+ 
+ 	rcu_read_lock();
+-	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.gateway_list, list) {
+ 		/* fails if orig_node has no router */
+ 		if (batadv_v_gw_write_buffer_text(bat_priv, seq, gw_node) < 0)
+ 			continue;
+@@ -1009,7 +1009,7 @@ static void batadv_v_gw_dump(struct sk_buff *msg, struct netlink_callback *cb,
+ 	int idx = 0;
+ 
+ 	rcu_read_lock();
+-	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.gateway_list, list) {
+ 		if (idx++ < idx_skip)
+ 			continue;
+ 
+diff --git a/net/batman-adv/gateway_client.c b/net/batman-adv/gateway_client.c
+index 69bfe98..52b8bd6 100644
+--- a/net/batman-adv/gateway_client.c
++++ b/net/batman-adv/gateway_client.c
+@@ -348,7 +348,7 @@ static void batadv_gw_node_add(struct batadv_priv *bat_priv,
+ 
+ 	spin_lock_bh(&bat_priv->gw.list_lock);
+ 	kref_get(&gw_node->refcount);
+-	hlist_add_head_rcu(&gw_node->list, &bat_priv->gw.list);
++	hlist_add_head_rcu(&gw_node->list, &bat_priv->gw.gateway_list);
+ 	spin_unlock_bh(&bat_priv->gw.list_lock);
+ 
+ 	batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
+@@ -376,7 +376,8 @@ struct batadv_gw_node *batadv_gw_node_get(struct batadv_priv *bat_priv,
+ 	struct batadv_gw_node *gw_node_tmp, *gw_node = NULL;
+ 
+ 	rcu_read_lock();
+-	hlist_for_each_entry_rcu(gw_node_tmp, &bat_priv->gw.list, list) {
++	hlist_for_each_entry_rcu(gw_node_tmp, &bat_priv->gw.gateway_list,
++				 list) {
+ 		if (gw_node_tmp->orig_node != orig_node)
+ 			continue;
+ 
+@@ -475,7 +476,7 @@ void batadv_gw_node_free(struct batadv_priv *bat_priv)
+ 
+ 	spin_lock_bh(&bat_priv->gw.list_lock);
+ 	hlist_for_each_entry_safe(gw_node, node_tmp,
+-				  &bat_priv->gw.list, list) {
++				  &bat_priv->gw.gateway_list, list) {
+ 		hlist_del_init_rcu(&gw_node->list);
+ 		batadv_gw_node_put(gw_node);
+ 	}
+diff --git a/net/batman-adv/main.c b/net/batman-adv/main.c
+index 2c017ab..5e4e818 100644
+--- a/net/batman-adv/main.c
++++ b/net/batman-adv/main.c
+@@ -160,7 +160,7 @@ int batadv_mesh_init(struct net_device *soft_iface)
+ 
+ 	INIT_HLIST_HEAD(&bat_priv->forw_bat_list);
+ 	INIT_HLIST_HEAD(&bat_priv->forw_bcast_list);
+-	INIT_HLIST_HEAD(&bat_priv->gw.list);
++	INIT_HLIST_HEAD(&bat_priv->gw.gateway_list);
+ #ifdef CONFIG_BATMAN_ADV_MCAST
+ 	INIT_HLIST_HEAD(&bat_priv->mcast.want_all_unsnoopables_list);
+ 	INIT_HLIST_HEAD(&bat_priv->mcast.want_all_ipv4_list);
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index d31e7ec..673a22e 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -706,8 +706,8 @@ struct batadv_priv_debug_log {
+ 
+ /**
+  * struct batadv_priv_gw - per mesh interface gateway data
+- * @list: list of available gateway nodes
+- * @list_lock: lock protecting gw_list & curr_gw
++ * @gateway_list: list of available gateway nodes
++ * @list_lock: lock protecting gateway_list & curr_gw
+  * @curr_gw: pointer to currently selected gateway node
+  * @mode: gateway operation: off, client or server (see batadv_gw_modes)
+  * @sel_class: gateway selection class (applies if gw_mode client)
+@@ -716,8 +716,8 @@ struct batadv_priv_debug_log {
+  * @reselect: bool indicating a gateway re-selection is in progress
+  */
+ struct batadv_priv_gw {
+-	struct hlist_head list;
+-	spinlock_t list_lock; /* protects gw_list & curr_gw */
++	struct hlist_head gateway_list;
++	spinlock_t list_lock; /* protects gateway_list & curr_gw */
+ 	struct batadv_gw_node __rcu *curr_gw;  /* rcu protected pointer */
+ 	atomic_t mode;
+ 	atomic_t sel_class;
diff --git a/batman-adv/patches/0020-batman-adv-Use-octal-permissions-instead-of-macros.patch b/batman-adv/patches/0020-batman-adv-Use-octal-permissions-instead-of-macros.patch
new file mode 100644
index 0000000..e0573fe
--- /dev/null
+++ b/batman-adv/patches/0020-batman-adv-Use-octal-permissions-instead-of-macros.patch
@@ -0,0 +1,73 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Thu, 1 Sep 2016 10:25:12 +0200
+Subject: [PATCH] batman-adv: Use octal permissions instead of macros
+
+Linus prefers to have octal permission numbers instead of combinations of
+macro names ("random line noise"). Also old existing "bad symbolic
+permission bit macro use" should be converted to octal numbers.
+(http://lkml.kernel.org/r/CA+55aFw5v23T-zvDZp-MmD_EYxF8WbafwwB59934FV7g21uMGQ@mail.gmail.com)
+
+Also remove the S_IFREG bit from the octal representation because it is
+filtered out by debugfs_create.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/icmp_socket.c    | 4 ++--
+ net/batman-adv/log.c            | 3 +--
+ net/batman-adv/network-coding.c | 7 +++----
+ 3 files changed, 6 insertions(+), 8 deletions(-)
+
+diff --git a/net/batman-adv/icmp_socket.c b/net/batman-adv/icmp_socket.c
+index 378cc11..aed8125 100644
+--- a/net/batman-adv/icmp_socket.c
++++ b/net/batman-adv/icmp_socket.c
+@@ -322,8 +322,8 @@ int batadv_socket_setup(struct batadv_priv *bat_priv)
+ 	if (!bat_priv->debug_dir)
+ 		goto err;
+ 
+-	d = debugfs_create_file(BATADV_ICMP_SOCKET, S_IFREG | S_IWUSR | S_IRUSR,
+-				bat_priv->debug_dir, bat_priv, &batadv_fops);
++	d = debugfs_create_file(BATADV_ICMP_SOCKET, 0600, bat_priv->debug_dir,
++				bat_priv, &batadv_fops);
+ 	if (!d)
+ 		goto err;
+ 
+diff --git a/net/batman-adv/log.c b/net/batman-adv/log.c
+index 56dc532..46b0725 100644
+--- a/net/batman-adv/log.c
++++ b/net/batman-adv/log.c
+@@ -212,8 +212,7 @@ int batadv_debug_log_setup(struct batadv_priv *bat_priv)
+ 	spin_lock_init(&bat_priv->debug_log->lock);
+ 	init_waitqueue_head(&bat_priv->debug_log->queue_wait);
+ 
+-	d = debugfs_create_file("log", S_IFREG | S_IRUSR,
+-				bat_priv->debug_dir, bat_priv,
++	d = debugfs_create_file("log", 0400, bat_priv->debug_dir, bat_priv,
+ 				&batadv_log_fops);
+ 	if (!d)
+ 		goto err;
+diff --git a/net/batman-adv/network-coding.c b/net/batman-adv/network-coding.c
+index e3baf69..0fc3b5f 100644
+--- a/net/batman-adv/network-coding.c
++++ b/net/batman-adv/network-coding.c
+@@ -1961,17 +1961,16 @@ int batadv_nc_init_debugfs(struct batadv_priv *bat_priv)
+ 	if (!nc_dir)
+ 		goto out;
+ 
+-	file = debugfs_create_u8("min_tq", S_IRUGO | S_IWUSR, nc_dir,
+-				 &bat_priv->nc.min_tq);
++	file = debugfs_create_u8("min_tq", 0644, nc_dir, &bat_priv->nc.min_tq);
+ 	if (!file)
+ 		goto out;
+ 
+-	file = debugfs_create_u32("max_fwd_delay", S_IRUGO | S_IWUSR, nc_dir,
++	file = debugfs_create_u32("max_fwd_delay", 0644, nc_dir,
+ 				  &bat_priv->nc.max_fwd_delay);
+ 	if (!file)
+ 		goto out;
+ 
+-	file = debugfs_create_u32("max_buffer_time", S_IRUGO | S_IWUSR, nc_dir,
++	file = debugfs_create_u32("max_buffer_time", 0644, nc_dir,
+ 				  &bat_priv->nc.max_buffer_time);
+ 	if (!file)
+ 		goto out;
diff --git a/batman-adv/patches/0021-batman-adv-Avoid-precedence-issues-in-macros.patch b/batman-adv/patches/0021-batman-adv-Avoid-precedence-issues-in-macros.patch
new file mode 100644
index 0000000..8f8ce25
--- /dev/null
+++ b/batman-adv/patches/0021-batman-adv-Avoid-precedence-issues-in-macros.patch
@@ -0,0 +1,66 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Wed, 21 Sep 2016 09:23:50 +0200
+Subject: [PATCH] batman-adv: Avoid precedence issues in macros
+
+It must be avoided that arguments to a macro are evaluated ungrouped (which
+enforces normal operator precendence). Otherwise the result of the macro
+is not well defined.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/log.h    | 12 ++++++------
+ net/batman-adv/main.h   |  4 ++--
+ net/batman-adv/packet.h |  2 +-
+ 3 files changed, 9 insertions(+), 9 deletions(-)
+
+diff --git a/net/batman-adv/log.h b/net/batman-adv/log.h
+index d2905a8..3284a7b 100644
+--- a/net/batman-adv/log.h
++++ b/net/batman-adv/log.h
+@@ -71,12 +71,12 @@ int batadv_debug_log(struct batadv_priv *bat_priv, const char *fmt, ...)
+ __printf(2, 3);
+ 
+ /* possibly ratelimited debug output */
+-#define _batadv_dbg(type, bat_priv, ratelimited, fmt, arg...)	\
+-	do {							\
+-		if (atomic_read(&bat_priv->log_level) & type && \
+-		    (!ratelimited || net_ratelimit()))		\
+-			batadv_debug_log(bat_priv, fmt, ## arg);\
+-	}							\
++#define _batadv_dbg(type, bat_priv, ratelimited, fmt, arg...)		\
++	do {								\
++		if (atomic_read(&(bat_priv)->log_level) & (type) &&	\
++		    (!(ratelimited) || net_ratelimit()))		\
++			batadv_debug_log(bat_priv, fmt, ## arg);	\
++	}								\
+ 	while (0)
+ #else /* !CONFIG_BATMAN_ADV_DEBUG */
+ __printf(4, 5)
+diff --git a/net/batman-adv/main.h b/net/batman-adv/main.h
+index 7f44b26..2f84d10 100644
+--- a/net/batman-adv/main.h
++++ b/net/batman-adv/main.h
+@@ -199,8 +199,8 @@ struct packet_type;
+ struct seq_file;
+ struct sk_buff;
+ 
+-#define BATADV_PRINT_VID(vid) ((vid & BATADV_VLAN_HAS_TAG) ? \
+-			       (int)(vid & VLAN_VID_MASK) : -1)
++#define BATADV_PRINT_VID(vid) (((vid) & BATADV_VLAN_HAS_TAG) ? \
++			       (int)((vid) & VLAN_VID_MASK) : -1)
+ 
+ extern struct list_head batadv_hardif_list;
+ 
+diff --git a/net/batman-adv/packet.h b/net/batman-adv/packet.h
+index d2e9bbd..7a36bcf 100644
+--- a/net/batman-adv/packet.h
++++ b/net/batman-adv/packet.h
+@@ -21,7 +21,7 @@
+ #include <asm/byteorder.h>
+ #include <linux/types.h>
+ 
+-#define batadv_tp_is_error(n) ((u8)n > 127 ? 1 : 0)
++#define batadv_tp_is_error(n) ((u8)(n) > 127 ? 1 : 0)
+ 
+ /**
+  * enum batadv_packettype - types for batman-adv encapsulated packets
diff --git a/batman-adv/patches/0022-batman-adv-Add-wrapper-for-ARP-reply-creation.patch b/batman-adv/patches/0022-batman-adv-Add-wrapper-for-ARP-reply-creation.patch
new file mode 100644
index 0000000..ba64b91
--- /dev/null
+++ b/batman-adv/patches/0022-batman-adv-Add-wrapper-for-ARP-reply-creation.patch
@@ -0,0 +1,110 @@
+From: Linus Lüssing <linus.luessing@c0d3.blue>
+Date: Tue, 5 Jul 2016 20:01:36 +0200
+Subject: [PATCH] batman-adv: Add wrapper for ARP reply creation
+
+Removing duplicate code.
+
+Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/distributed-arp-table.c | 67 ++++++++++++++++++++--------------
+ 1 file changed, 40 insertions(+), 27 deletions(-)
+
+diff --git a/net/batman-adv/distributed-arp-table.c b/net/batman-adv/distributed-arp-table.c
+index cbb4f32..49576c5 100644
+--- a/net/batman-adv/distributed-arp-table.c
++++ b/net/batman-adv/distributed-arp-table.c
+@@ -949,6 +949,41 @@ static unsigned short batadv_dat_get_vid(struct sk_buff *skb, int *hdr_size)
+ }
+ 
+ /**
++ * batadv_dat_arp_create_reply - create an ARP Reply
++ * @bat_priv: the bat priv with all the soft interface information
++ * @ip_src: ARP sender IP
++ * @ip_dst: ARP target IP
++ * @hw_src: Ethernet source and ARP sender MAC
++ * @hw_dst: Ethernet destination and ARP target MAC
++ * @vid: VLAN identifier (optional, set to zero otherwise)
++ *
++ * Creates an ARP Reply from the given values, optionally encapsulated in a
++ * VLAN header.
++ *
++ * Return: An skb containing an ARP Reply.
++ */
++static struct sk_buff *
++batadv_dat_arp_create_reply(struct batadv_priv *bat_priv, __be32 ip_src,
++			    __be32 ip_dst, u8 *hw_src, u8 *hw_dst,
++			    unsigned short vid)
++{
++	struct sk_buff *skb;
++
++	skb = arp_create(ARPOP_REPLY, ETH_P_ARP, ip_dst, bat_priv->soft_iface,
++			 ip_src, hw_dst, hw_src, hw_dst);
++	if (!skb)
++		return NULL;
++
++	skb_reset_mac_header(skb);
++
++	if (vid & BATADV_VLAN_HAS_TAG)
++		skb = vlan_insert_tag(skb, htons(ETH_P_8021Q),
++				      vid & VLAN_VID_MASK);
++
++	return skb;
++}
++
++/**
+  * batadv_dat_snoop_outgoing_arp_request - snoop the ARP request and try to
+  * answer using DAT
+  * @bat_priv: the bat priv with all the soft interface information
+@@ -1005,20 +1040,12 @@ bool batadv_dat_snoop_outgoing_arp_request(struct batadv_priv *bat_priv,
+ 			goto out;
+ 		}
+ 
+-		skb_new = arp_create(ARPOP_REPLY, ETH_P_ARP, ip_src,
+-				     bat_priv->soft_iface, ip_dst, hw_src,
+-				     dat_entry->mac_addr, hw_src);
++		skb_new = batadv_dat_arp_create_reply(bat_priv, ip_dst, ip_src,
++						      dat_entry->mac_addr,
++						      hw_src, vid);
+ 		if (!skb_new)
+ 			goto out;
+ 
+-		if (vid & BATADV_VLAN_HAS_TAG) {
+-			skb_new = vlan_insert_tag(skb_new, htons(ETH_P_8021Q),
+-						  vid & VLAN_VID_MASK);
+-			if (!skb_new)
+-				goto out;
+-		}
+-
+-		skb_reset_mac_header(skb_new);
+ 		skb_new->protocol = eth_type_trans(skb_new,
+ 						   bat_priv->soft_iface);
+ 		bat_priv->stats.rx_packets++;
+@@ -1081,25 +1108,11 @@ bool batadv_dat_snoop_incoming_arp_request(struct batadv_priv *bat_priv,
+ 	if (!dat_entry)
+ 		goto out;
+ 
+-	skb_new = arp_create(ARPOP_REPLY, ETH_P_ARP, ip_src,
+-			     bat_priv->soft_iface, ip_dst, hw_src,
+-			     dat_entry->mac_addr, hw_src);
+-
++	skb_new = batadv_dat_arp_create_reply(bat_priv, ip_dst, ip_src,
++					      dat_entry->mac_addr, hw_src, vid);
+ 	if (!skb_new)
+ 		goto out;
+ 
+-	/* the rest of the TX path assumes that the mac_header offset pointing
+-	 * to the inner Ethernet header has been set, therefore reset it now.
+-	 */
+-	skb_reset_mac_header(skb_new);
+-
+-	if (vid & BATADV_VLAN_HAS_TAG) {
+-		skb_new = vlan_insert_tag(skb_new, htons(ETH_P_8021Q),
+-					  vid & VLAN_VID_MASK);
+-		if (!skb_new)
+-			goto out;
+-	}
+-
+ 	/* To preserve backwards compatibility, the node has choose the outgoing
+ 	 * format based on the incoming request packet type. The assumption is
+ 	 * that a node not using the 4addr packet format doesn't support it.
diff --git a/batman-adv/patches/0023-batman-adv-Remove-unnecessary-lockdep-in-batadv_mcas.patch b/batman-adv/patches/0023-batman-adv-Remove-unnecessary-lockdep-in-batadv_mcas.patch
new file mode 100644
index 0000000..2420cef
--- /dev/null
+++ b/batman-adv/patches/0023-batman-adv-Remove-unnecessary-lockdep-in-batadv_mcas.patch
@@ -0,0 +1,48 @@
+From: Linus Lüssing <linus.luessing@c0d3.blue>
+Date: Sat, 6 Aug 2016 22:23:15 +0200
+Subject: [PATCH] batman-adv: Remove unnecessary lockdep in batadv_mcast_mla_list_free
+
+batadv_mcast_mla_list_free() just frees some leftovers of a local feast
+in batadv_mcast_mla_update(). No lockdep needed as it has nothing to do
+with bat_priv->mcast.mla_list.
+
+Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/multicast.c | 8 ++------
+ 1 file changed, 2 insertions(+), 6 deletions(-)
+
+diff --git a/net/batman-adv/multicast.c b/net/batman-adv/multicast.c
+index 13661f4..45757fa 100644
+--- a/net/batman-adv/multicast.c
++++ b/net/batman-adv/multicast.c
+@@ -231,19 +231,15 @@ out:
+ 
+ /**
+  * batadv_mcast_mla_list_free - free a list of multicast addresses
+- * @bat_priv: the bat priv with all the soft interface information
+  * @mcast_list: the list to free
+  *
+  * Removes and frees all items in the given mcast_list.
+  */
+-static void batadv_mcast_mla_list_free(struct batadv_priv *bat_priv,
+-				       struct hlist_head *mcast_list)
++static void batadv_mcast_mla_list_free(struct hlist_head *mcast_list)
+ {
+ 	struct batadv_hw_addr *mcast_entry;
+ 	struct hlist_node *tmp;
+ 
+-	lockdep_assert_held(&bat_priv->tt.commit_lock);
+-
+ 	hlist_for_each_entry_safe(mcast_entry, tmp, mcast_list, list) {
+ 		hlist_del(&mcast_entry->list);
+ 		kfree(mcast_entry);
+@@ -560,7 +556,7 @@ update:
+ 	batadv_mcast_mla_tt_add(bat_priv, &mcast_list);
+ 
+ out:
+-	batadv_mcast_mla_list_free(bat_priv, &mcast_list);
++	batadv_mcast_mla_list_free(&mcast_list);
+ }
+ 
+ /**
diff --git a/batman-adv/patches/0024-batman-adv-Remove-unused-skb_reset_mac_header.patch b/batman-adv/patches/0024-batman-adv-Remove-unused-skb_reset_mac_header.patch
new file mode 100644
index 0000000..b2c6675
--- /dev/null
+++ b/batman-adv/patches/0024-batman-adv-Remove-unused-skb_reset_mac_header.patch
@@ -0,0 +1,32 @@
+From: Linus Lüssing <linus.luessing@c0d3.blue>
+Date: Sun, 7 Aug 2016 12:34:18 +0200
+Subject: [PATCH] batman-adv: Remove unused skb_reset_mac_header()
+
+During broadcast queueing, the skb_reset_mac_header() sets the skb
+to a place invalid for a MAC header, pointing right into the
+batman-adv broadcast packet. Luckily, no one seems to actually use
+eth_hdr(skb) afterwards until batadv_send_skb_packet() resets the
+header to a valid position again.
+
+Therefore removing this unnecessary, weird skb_reset_mac_header()
+call.
+
+Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/send.c | 2 --
+ 1 file changed, 2 deletions(-)
+
+diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
+index e1e9136..be3f6d7 100644
+--- a/net/batman-adv/send.c
++++ b/net/batman-adv/send.c
+@@ -586,8 +586,6 @@ int batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+ 	bcast_packet = (struct batadv_bcast_packet *)newskb->data;
+ 	bcast_packet->ttl--;
+ 
+-	skb_reset_mac_header(newskb);
+-
+ 	forw_packet->skb = newskb;
+ 
+ 	INIT_DELAYED_WORK(&forw_packet->delayed_work,
diff --git a/batman-adv/patches/0025-batman-adv-Remove-unused-header-linux-stat.h.patch b/batman-adv/patches/0025-batman-adv-Remove-unused-header-linux-stat.h.patch
new file mode 100644
index 0000000..81ad955
--- /dev/null
+++ b/batman-adv/patches/0025-batman-adv-Remove-unused-header-linux-stat.h.patch
@@ -0,0 +1,47 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Tue, 18 Oct 2016 22:33:18 +0200
+Subject: [PATCH] batman-adv: Remove unused header linux/stat.h
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/icmp_socket.c    | 1 -
+ net/batman-adv/log.c            | 1 -
+ net/batman-adv/network-coding.c | 1 -
+ 3 files changed, 3 deletions(-)
+
+diff --git a/net/batman-adv/icmp_socket.c b/net/batman-adv/icmp_socket.c
+index aed8125..b310f38 100644
+--- a/net/batman-adv/icmp_socket.c
++++ b/net/batman-adv/icmp_socket.c
+@@ -38,7 +38,6 @@
+ #include <linux/skbuff.h>
+ #include <linux/slab.h>
+ #include <linux/spinlock.h>
+-#include <linux/stat.h>
+ #include <linux/stddef.h>
+ #include <linux/string.h>
+ #include <linux/uaccess.h>
+diff --git a/net/batman-adv/log.c b/net/batman-adv/log.c
+index 46b0725..c73c317 100644
+--- a/net/batman-adv/log.c
++++ b/net/batman-adv/log.c
+@@ -31,7 +31,6 @@
+ #include <linux/sched.h> /* for linux/wait.h */
+ #include <linux/slab.h>
+ #include <linux/spinlock.h>
+-#include <linux/stat.h>
+ #include <linux/stddef.h>
+ #include <linux/types.h>
+ #include <linux/uaccess.h>
+diff --git a/net/batman-adv/network-coding.c b/net/batman-adv/network-coding.c
+index 0fc3b5f..c213dde 100644
+--- a/net/batman-adv/network-coding.c
++++ b/net/batman-adv/network-coding.c
+@@ -44,7 +44,6 @@
+ #include <linux/skbuff.h>
+ #include <linux/slab.h>
+ #include <linux/spinlock.h>
+-#include <linux/stat.h>
+ #include <linux/stddef.h>
+ #include <linux/string.h>
+ #include <linux/workqueue.h>
diff --git a/batman-adv/patches/0026-batman-adv-Use-octal-permissions-instead-of-macros-f.patch b/batman-adv/patches/0026-batman-adv-Use-octal-permissions-instead-of-macros-f.patch
new file mode 100644
index 0000000..157aaf6
--- /dev/null
+++ b/batman-adv/patches/0026-batman-adv-Use-octal-permissions-instead-of-macros-f.patch
@@ -0,0 +1,76 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Thu, 1 Sep 2016 10:25:12 +0200
+Subject: [PATCH] batman-adv: Use octal permissions instead of macros for debugfs
+
+Linus prefers to have octal permission numbers instead of combinations of
+macro names ("random line noise"). Also old existing "bad symbolic
+permission bit macro use" should be converted to octal numbers.
+(http://lkml.kernel.org/r/CA+55aFw5v23T-zvDZp-MmD_EYxF8WbafwwB59934FV7g21uMGQ@mail.gmail.com)
+
+Also remove the S_IFREG bit from the octal representation because it is
+filtered out by debugfs_create.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/debugfs.c | 26 ++++++++++++--------------
+ 1 file changed, 12 insertions(+), 14 deletions(-)
+
+diff --git a/net/batman-adv/debugfs.c b/net/batman-adv/debugfs.c
+index b4ffba7..7792550 100644
+--- a/net/batman-adv/debugfs.c
++++ b/net/batman-adv/debugfs.c
+@@ -186,7 +186,7 @@ struct batadv_debuginfo batadv_debuginfo_##_name = {	\
+ /* the following attributes are general and therefore they will be directly
+  * placed in the BATADV_DEBUGFS_SUBDIR subdirectory of debugfs
+  */
+-static BATADV_DEBUGINFO(routing_algos, S_IRUGO, batadv_algorithms_open);
++static BATADV_DEBUGINFO(routing_algos, 0444, batadv_algorithms_open);
+ 
+ static struct batadv_debuginfo *batadv_general_debuginfos[] = {
+ 	&batadv_debuginfo_routing_algos,
+@@ -194,26 +194,24 @@ static struct batadv_debuginfo *batadv_general_debuginfos[] = {
+ };
+ 
+ /* The following attributes are per soft interface */
+-static BATADV_DEBUGINFO(neighbors, S_IRUGO, neighbors_open);
+-static BATADV_DEBUGINFO(originators, S_IRUGO, batadv_originators_open);
+-static BATADV_DEBUGINFO(gateways, S_IRUGO, batadv_gateways_open);
+-static BATADV_DEBUGINFO(transtable_global, S_IRUGO,
+-			batadv_transtable_global_open);
++static BATADV_DEBUGINFO(neighbors, 0444, neighbors_open);
++static BATADV_DEBUGINFO(originators, 0444, batadv_originators_open);
++static BATADV_DEBUGINFO(gateways, 0444, batadv_gateways_open);
++static BATADV_DEBUGINFO(transtable_global, 0444, batadv_transtable_global_open);
+ #ifdef CONFIG_BATMAN_ADV_BLA
+-static BATADV_DEBUGINFO(bla_claim_table, S_IRUGO, batadv_bla_claim_table_open);
+-static BATADV_DEBUGINFO(bla_backbone_table, S_IRUGO,
++static BATADV_DEBUGINFO(bla_claim_table, 0444, batadv_bla_claim_table_open);
++static BATADV_DEBUGINFO(bla_backbone_table, 0444,
+ 			batadv_bla_backbone_table_open);
+ #endif
+ #ifdef CONFIG_BATMAN_ADV_DAT
+-static BATADV_DEBUGINFO(dat_cache, S_IRUGO, batadv_dat_cache_open);
++static BATADV_DEBUGINFO(dat_cache, 0444, batadv_dat_cache_open);
+ #endif
+-static BATADV_DEBUGINFO(transtable_local, S_IRUGO,
+-			batadv_transtable_local_open);
++static BATADV_DEBUGINFO(transtable_local, 0444, batadv_transtable_local_open);
+ #ifdef CONFIG_BATMAN_ADV_NC
+-static BATADV_DEBUGINFO(nc_nodes, S_IRUGO, batadv_nc_nodes_open);
++static BATADV_DEBUGINFO(nc_nodes, 0444, batadv_nc_nodes_open);
+ #endif
+ #ifdef CONFIG_BATMAN_ADV_MCAST
+-static BATADV_DEBUGINFO(mcast_flags, S_IRUGO, batadv_mcast_flags_open);
++static BATADV_DEBUGINFO(mcast_flags, 0444, batadv_mcast_flags_open);
+ #endif
+ 
+ static struct batadv_debuginfo *batadv_mesh_debuginfos[] = {
+@@ -253,7 +251,7 @@ struct batadv_debuginfo batadv_hardif_debuginfo_##_name = {	\
+ 	},							\
+ }
+ 
+-static BATADV_HARDIF_DEBUGINFO(originators, S_IRUGO,
++static BATADV_HARDIF_DEBUGINFO(originators, 0444,
+ 			       batadv_originators_hardif_open);
+ 
+ static struct batadv_debuginfo *batadv_hardif_debuginfos[] = {
diff --git a/batman-adv/patches/0027-batman-adv-Use-octal-permissions-instead-of-macros-f.patch b/batman-adv/patches/0027-batman-adv-Use-octal-permissions-instead-of-macros-f.patch
new file mode 100644
index 0000000..d24e22f
--- /dev/null
+++ b/batman-adv/patches/0027-batman-adv-Use-octal-permissions-instead-of-macros-f.patch
@@ -0,0 +1,117 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Thu, 1 Sep 2016 10:25:12 +0200
+Subject: [PATCH] batman-adv: Use octal permissions instead of macros for sysfs
+
+Linus prefers to have octal permission numbers instead of combinations of
+macro names ("random line noise"). Also old existing "bad symbolic
+permission bit macro use" should be converted to octal numbers.
+(http://lkml.kernel.org/r/CA+55aFw5v23T-zvDZp-MmD_EYxF8WbafwwB59934FV7g21uMGQ@mail.gmail.com)
+
+Also remove the S_IFREG bit from the octal representation because it is
+filtered out by debugfs_create.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/sysfs.c | 53 ++++++++++++++++++++++----------------------------
+ 1 file changed, 23 insertions(+), 30 deletions(-)
+
+diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
+index 02d96f2..17c8441 100644
+--- a/net/batman-adv/sysfs.c
++++ b/net/batman-adv/sysfs.c
+@@ -33,7 +33,6 @@
+ #include <linux/rcupdate.h>
+ #include <linux/rtnetlink.h>
+ #include <linux/slab.h>
+-#include <linux/stat.h>
+ #include <linux/stddef.h>
+ #include <linux/string.h>
+ #include <linux/stringify.h>
+@@ -666,41 +665,36 @@ static ssize_t batadv_store_isolation_mark(struct kobject *kobj,
+ 	return count;
+ }
+ 
+-BATADV_ATTR_SIF_BOOL(aggregated_ogms, S_IRUGO | S_IWUSR, NULL);
+-BATADV_ATTR_SIF_BOOL(bonding, S_IRUGO | S_IWUSR, NULL);
++BATADV_ATTR_SIF_BOOL(aggregated_ogms, 0644, NULL);
++BATADV_ATTR_SIF_BOOL(bonding, 0644, NULL);
+ #ifdef CONFIG_BATMAN_ADV_BLA
+-BATADV_ATTR_SIF_BOOL(bridge_loop_avoidance, S_IRUGO | S_IWUSR,
+-		     batadv_bla_status_update);
++BATADV_ATTR_SIF_BOOL(bridge_loop_avoidance, 0644, batadv_bla_status_update);
+ #endif
+ #ifdef CONFIG_BATMAN_ADV_DAT
+-BATADV_ATTR_SIF_BOOL(distributed_arp_table, S_IRUGO | S_IWUSR,
+-		     batadv_dat_status_update);
++BATADV_ATTR_SIF_BOOL(distributed_arp_table, 0644, batadv_dat_status_update);
+ #endif
+-BATADV_ATTR_SIF_BOOL(fragmentation, S_IRUGO | S_IWUSR, batadv_update_min_mtu);
+-static BATADV_ATTR(routing_algo, S_IRUGO, batadv_show_bat_algo, NULL);
+-static BATADV_ATTR(gw_mode, S_IRUGO | S_IWUSR, batadv_show_gw_mode,
+-		   batadv_store_gw_mode);
+-BATADV_ATTR_SIF_UINT(orig_interval, orig_interval, S_IRUGO | S_IWUSR,
+-		     2 * BATADV_JITTER, INT_MAX, NULL);
+-BATADV_ATTR_SIF_UINT(hop_penalty, hop_penalty, S_IRUGO | S_IWUSR, 0,
+-		     BATADV_TQ_MAX_VALUE, NULL);
+-static BATADV_ATTR(gw_sel_class, S_IRUGO | S_IWUSR, batadv_show_gw_sel_class,
++BATADV_ATTR_SIF_BOOL(fragmentation, 0644, batadv_update_min_mtu);
++static BATADV_ATTR(routing_algo, 0444, batadv_show_bat_algo, NULL);
++static BATADV_ATTR(gw_mode, 0644, batadv_show_gw_mode, batadv_store_gw_mode);
++BATADV_ATTR_SIF_UINT(orig_interval, orig_interval, 0644, 2 * BATADV_JITTER,
++		     INT_MAX, NULL);
++BATADV_ATTR_SIF_UINT(hop_penalty, hop_penalty, 0644, 0, BATADV_TQ_MAX_VALUE,
++		     NULL);
++static BATADV_ATTR(gw_sel_class, 0644, batadv_show_gw_sel_class,
+ 		   batadv_store_gw_sel_class);
+-static BATADV_ATTR(gw_bandwidth, S_IRUGO | S_IWUSR, batadv_show_gw_bwidth,
++static BATADV_ATTR(gw_bandwidth, 0644, batadv_show_gw_bwidth,
+ 		   batadv_store_gw_bwidth);
+ #ifdef CONFIG_BATMAN_ADV_MCAST
+-BATADV_ATTR_SIF_BOOL(multicast_mode, S_IRUGO | S_IWUSR, NULL);
++BATADV_ATTR_SIF_BOOL(multicast_mode, 0644, NULL);
+ #endif
+ #ifdef CONFIG_BATMAN_ADV_DEBUG
+-BATADV_ATTR_SIF_UINT(log_level, log_level, S_IRUGO | S_IWUSR, 0,
+-		     BATADV_DBG_ALL, NULL);
++BATADV_ATTR_SIF_UINT(log_level, log_level, 0644, 0, BATADV_DBG_ALL, NULL);
+ #endif
+ #ifdef CONFIG_BATMAN_ADV_NC
+-BATADV_ATTR_SIF_BOOL(network_coding, S_IRUGO | S_IWUSR,
+-		     batadv_nc_status_update);
++BATADV_ATTR_SIF_BOOL(network_coding, 0644, batadv_nc_status_update);
+ #endif
+-static BATADV_ATTR(isolation_mark, S_IRUGO | S_IWUSR,
+-		   batadv_show_isolation_mark, batadv_store_isolation_mark);
++static BATADV_ATTR(isolation_mark, 0644, batadv_show_isolation_mark,
++		   batadv_store_isolation_mark);
+ 
+ static struct batadv_attribute *batadv_mesh_attrs[] = {
+ 	&batadv_attr_aggregated_ogms,
+@@ -731,7 +725,7 @@ static struct batadv_attribute *batadv_mesh_attrs[] = {
+ 	NULL,
+ };
+ 
+-BATADV_ATTR_VLAN_BOOL(ap_isolation, S_IRUGO | S_IWUSR, NULL);
++BATADV_ATTR_VLAN_BOOL(ap_isolation, 0644, NULL);
+ 
+ /* array of vlan specific sysfs attributes */
+ static struct batadv_attribute *batadv_vlan_attrs[] = {
+@@ -1116,14 +1110,13 @@ static ssize_t batadv_show_throughput_override(struct kobject *kobj,
+ 
+ #endif
+ 
+-static BATADV_ATTR(mesh_iface, S_IRUGO | S_IWUSR, batadv_show_mesh_iface,
++static BATADV_ATTR(mesh_iface, 0644, batadv_show_mesh_iface,
+ 		   batadv_store_mesh_iface);
+-static BATADV_ATTR(iface_status, S_IRUGO, batadv_show_iface_status, NULL);
++static BATADV_ATTR(iface_status, 0444, batadv_show_iface_status, NULL);
+ #ifdef CONFIG_BATMAN_ADV_BATMAN_V
+-BATADV_ATTR_HIF_UINT(elp_interval, bat_v.elp_interval, S_IRUGO | S_IWUSR,
++BATADV_ATTR_HIF_UINT(elp_interval, bat_v.elp_interval, 0644,
+ 		     2 * BATADV_JITTER, INT_MAX, NULL);
+-static BATADV_ATTR(throughput_override, S_IRUGO | S_IWUSR,
+-		   batadv_show_throughput_override,
++static BATADV_ATTR(throughput_override, 0644, batadv_show_throughput_override,
+ 		   batadv_store_throughput_override);
+ #endif
+ 
diff --git a/batman-adv/patches/0028-batman-adv-Remove-needless-init-of-framentation-vari.patch b/batman-adv/patches/0028-batman-adv-Remove-needless-init-of-framentation-vari.patch
new file mode 100644
index 0000000..ceb1fb7
--- /dev/null
+++ b/batman-adv/patches/0028-batman-adv-Remove-needless-init-of-framentation-vari.patch
@@ -0,0 +1,35 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Mon, 25 Jul 2016 00:42:44 +0200
+Subject: [PATCH] batman-adv: Remove needless init of framentation variables on stack
+
+Some variables are overwritten immediatelly in a functions. These don't
+have to be initialized to a specific value on the stack because the value
+will be overwritten before they will be used anywhere.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/fragmentation.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/net/batman-adv/fragmentation.c b/net/batman-adv/fragmentation.c
+index f725918..2b967a3 100644
+--- a/net/batman-adv/fragmentation.c
++++ b/net/batman-adv/fragmentation.c
+@@ -252,7 +252,7 @@ batadv_frag_merge_packets(struct hlist_head *chain)
+ {
+ 	struct batadv_frag_packet *packet;
+ 	struct batadv_frag_list_entry *entry;
+-	struct sk_buff *skb_out = NULL;
++	struct sk_buff *skb_out;
+ 	int size, hdr_size = sizeof(struct batadv_frag_packet);
+ 
+ 	/* Remove first entry, as this is the destination for the rest of the
+@@ -352,7 +352,7 @@ bool batadv_frag_skb_fwd(struct sk_buff *skb,
+ 			 struct batadv_orig_node *orig_node_src)
+ {
+ 	struct batadv_priv *bat_priv = netdev_priv(recv_if->soft_iface);
+-	struct batadv_orig_node *orig_node_dst = NULL;
++	struct batadv_orig_node *orig_node_dst;
+ 	struct batadv_neigh_node *neigh_node = NULL;
+ 	struct batadv_frag_packet *packet;
+ 	u16 total_size;
diff --git a/batman-adv/patches/0029-batman-adv-Use-own-timer-for-multicast-TT-and-TVLV-u.patch b/batman-adv/patches/0029-batman-adv-Use-own-timer-for-multicast-TT-and-TVLV-u.patch
new file mode 100644
index 0000000..e359426
--- /dev/null
+++ b/batman-adv/patches/0029-batman-adv-Use-own-timer-for-multicast-TT-and-TVLV-u.patch
@@ -0,0 +1,261 @@
+From: Linus Lüssing <linus.luessing@c0d3.blue>
+Date: Sat, 6 Aug 2016 22:23:16 +0200
+Subject: [PATCH] batman-adv: Use own timer for multicast TT and TVLV updates
+
+Instead of latching onto the OGM period, this patch introduces a worker
+dedicated to multicast TT and TVLV updates.
+
+The reasoning is, that upon roaming especially the translation table
+should be updated timely to minimize connectivity issues.
+
+With BATMAN V, the idea is to greatly increase the OGM interval to
+reduce overhead. Unfortunately, right now this could lead to
+a bad user experience if multicast traffic is involved.
+
+Therefore this patch introduces a fixed 500ms update interval for
+multicast TT entries and the multicast TVLV.
+
+Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/main.h              |  1 +
+ net/batman-adv/multicast.c         | 62 ++++++++++++++++++++++++++++++++++----
+ net/batman-adv/multicast.h         |  6 ----
+ net/batman-adv/translation-table.c |  4 ---
+ net/batman-adv/types.h             |  4 ++-
+ 5 files changed, 60 insertions(+), 17 deletions(-)
+
+diff --git a/net/batman-adv/main.h b/net/batman-adv/main.h
+index 2f84d10..2a0bb49 100644
+--- a/net/batman-adv/main.h
++++ b/net/batman-adv/main.h
+@@ -48,6 +48,7 @@
+ #define BATADV_TT_CLIENT_TEMP_TIMEOUT 600000 /* in milliseconds */
+ #define BATADV_TT_WORK_PERIOD 5000 /* 5 seconds */
+ #define BATADV_ORIG_WORK_PERIOD 1000 /* 1 second */
++#define BATADV_MCAST_WORK_PERIOD 500 /* 0.5 seconds */
+ #define BATADV_DAT_ENTRY_TIMEOUT (5 * 60000) /* 5 mins in milliseconds */
+ /* sliding packet range of received originator messages in sequence numbers
+  * (should be a multiple of our word size)
+diff --git a/net/batman-adv/multicast.c b/net/batman-adv/multicast.c
+index 45757fa..090a69f 100644
+--- a/net/batman-adv/multicast.c
++++ b/net/batman-adv/multicast.c
+@@ -33,6 +33,7 @@
+ #include <linux/in6.h>
+ #include <linux/ip.h>
+ #include <linux/ipv6.h>
++#include <linux/jiffies.h>
+ #include <linux/kernel.h>
+ #include <linux/kref.h>
+ #include <linux/list.h>
+@@ -48,6 +49,7 @@
+ #include <linux/stddef.h>
+ #include <linux/string.h>
+ #include <linux/types.h>
++#include <linux/workqueue.h>
+ #include <net/addrconf.h>
+ #include <net/if_inet6.h>
+ #include <net/ip.h>
+@@ -60,6 +62,18 @@
+ #include "translation-table.h"
+ #include "tvlv.h"
+ 
++static void batadv_mcast_mla_update(struct work_struct *work);
++
++/**
++ * batadv_mcast_start_timer - schedule the multicast periodic worker
++ * @bat_priv: the bat priv with all the soft interface information
++ */
++static void batadv_mcast_start_timer(struct batadv_priv *bat_priv)
++{
++	queue_delayed_work(batadv_event_workqueue, &bat_priv->mcast.work,
++			   msecs_to_jiffies(BATADV_MCAST_WORK_PERIOD));
++}
++
+ /**
+  * batadv_mcast_get_bridge - get the bridge on top of the softif if it exists
+  * @soft_iface: netdev struct of the mesh interface
+@@ -255,6 +269,8 @@ static void batadv_mcast_mla_list_free(struct hlist_head *mcast_list)
+  * translation table except the ones listed in the given mcast_list.
+  *
+  * If mcast_list is NULL then all are retracted.
++ *
++ * Do not call outside of the mcast worker! (or cancel mcast worker first)
+  */
+ static void batadv_mcast_mla_tt_retract(struct batadv_priv *bat_priv,
+ 					struct hlist_head *mcast_list)
+@@ -262,7 +278,7 @@ static void batadv_mcast_mla_tt_retract(struct batadv_priv *bat_priv,
+ 	struct batadv_hw_addr *mcast_entry;
+ 	struct hlist_node *tmp;
+ 
+-	lockdep_assert_held(&bat_priv->tt.commit_lock);
++	WARN_ON(delayed_work_pending(&bat_priv->mcast.work));
+ 
+ 	hlist_for_each_entry_safe(mcast_entry, tmp, &bat_priv->mcast.mla_list,
+ 				  list) {
+@@ -287,6 +303,8 @@ static void batadv_mcast_mla_tt_retract(struct batadv_priv *bat_priv,
+  *
+  * Adds multicast listener announcements from the given mcast_list to the
+  * translation table if they have not been added yet.
++ *
++ * Do not call outside of the mcast worker! (or cancel mcast worker first)
+  */
+ static void batadv_mcast_mla_tt_add(struct batadv_priv *bat_priv,
+ 				    struct hlist_head *mcast_list)
+@@ -294,7 +312,7 @@ static void batadv_mcast_mla_tt_add(struct batadv_priv *bat_priv,
+ 	struct batadv_hw_addr *mcast_entry;
+ 	struct hlist_node *tmp;
+ 
+-	lockdep_assert_held(&bat_priv->tt.commit_lock);
++	WARN_ON(delayed_work_pending(&bat_priv->mcast.work));
+ 
+ 	if (!mcast_list)
+ 		return;
+@@ -528,13 +546,18 @@ update:
+ }
+ 
+ /**
+- * batadv_mcast_mla_update - update the own MLAs
++ * __batadv_mcast_mla_update - update the own MLAs
+  * @bat_priv: the bat priv with all the soft interface information
+  *
+  * Updates the own multicast listener announcements in the translation
+  * table as well as the own, announced multicast tvlv container.
++ *
++ * Note that non-conflicting reads and writes to bat_priv->mcast.mla_list
++ * in batadv_mcast_mla_tt_retract() and batadv_mcast_mla_tt_add() are
++ * ensured by the non-parallel execution of the worker this function
++ * belongs to.
+  */
+-void batadv_mcast_mla_update(struct batadv_priv *bat_priv)
++static void __batadv_mcast_mla_update(struct batadv_priv *bat_priv)
+ {
+ 	struct net_device *soft_iface = bat_priv->soft_iface;
+ 	struct hlist_head mcast_list = HLIST_HEAD_INIT;
+@@ -560,6 +583,29 @@ out:
+ }
+ 
+ /**
++ * batadv_mcast_mla_update - update the own MLAs
++ * @work: kernel work struct
++ *
++ * Updates the own multicast listener announcements in the translation
++ * table as well as the own, announced multicast tvlv container.
++ *
++ * In the end, reschedules the work timer.
++ */
++static void batadv_mcast_mla_update(struct work_struct *work)
++{
++	struct delayed_work *delayed_work;
++	struct batadv_priv_mcast *priv_mcast;
++	struct batadv_priv *bat_priv;
++
++	delayed_work = to_delayed_work(work);
++	priv_mcast = container_of(delayed_work, struct batadv_priv_mcast, work);
++	bat_priv = container_of(priv_mcast, struct batadv_priv, mcast);
++
++	__batadv_mcast_mla_update(bat_priv);
++	batadv_mcast_start_timer(bat_priv);
++}
++
++/**
+  * batadv_mcast_is_report_ipv4 - check for IGMP reports
+  * @skb: the ethernet frame destined for the mesh
+  *
+@@ -1128,6 +1174,9 @@ void batadv_mcast_init(struct batadv_priv *bat_priv)
+ 	batadv_tvlv_handler_register(bat_priv, batadv_mcast_tvlv_ogm_handler,
+ 				     NULL, BATADV_TVLV_MCAST, 2,
+ 				     BATADV_TVLV_HANDLER_OGM_CIFNOTFND);
++
++	INIT_DELAYED_WORK(&bat_priv->mcast.work, batadv_mcast_mla_update);
++	batadv_mcast_start_timer(bat_priv);
+ }
+ 
+ #ifdef CONFIG_BATMAN_ADV_DEBUGFS
+@@ -1239,12 +1288,13 @@ int batadv_mcast_flags_seq_print_text(struct seq_file *seq, void *offset)
+  */
+ void batadv_mcast_free(struct batadv_priv *bat_priv)
+ {
++	cancel_delayed_work_sync(&bat_priv->mcast.work);
++
+ 	batadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_MCAST, 2);
+ 	batadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_MCAST, 2);
+ 
+-	spin_lock_bh(&bat_priv->tt.commit_lock);
++	/* safely calling outside of worker, as worker was canceled above */
+ 	batadv_mcast_mla_tt_retract(bat_priv, NULL);
+-	spin_unlock_bh(&bat_priv->tt.commit_lock);
+ }
+ 
+ /**
+diff --git a/net/batman-adv/multicast.h b/net/batman-adv/multicast.h
+index 1fb00ba..2cddaf5 100644
+--- a/net/batman-adv/multicast.h
++++ b/net/batman-adv/multicast.h
+@@ -39,8 +39,6 @@ enum batadv_forw_mode {
+ 
+ #ifdef CONFIG_BATMAN_ADV_MCAST
+ 
+-void batadv_mcast_mla_update(struct batadv_priv *bat_priv);
+-
+ enum batadv_forw_mode
+ batadv_mcast_forw_mode(struct batadv_priv *bat_priv, struct sk_buff *skb,
+ 		       struct batadv_orig_node **mcast_single_orig);
+@@ -55,10 +53,6 @@ void batadv_mcast_purge_orig(struct batadv_orig_node *orig_node);
+ 
+ #else
+ 
+-static inline void batadv_mcast_mla_update(struct batadv_priv *bat_priv)
+-{
+-}
+-
+ static inline enum batadv_forw_mode
+ batadv_mcast_forw_mode(struct batadv_priv *bat_priv, struct sk_buff *skb,
+ 		       struct batadv_orig_node **mcast_single_orig)
+diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
+index 956950a..f97d5a8 100644
+--- a/net/batman-adv/translation-table.c
++++ b/net/batman-adv/translation-table.c
+@@ -56,7 +56,6 @@
+ #include "hard-interface.h"
+ #include "hash.h"
+ #include "log.h"
+-#include "multicast.h"
+ #include "netlink.h"
+ #include "originator.h"
+ #include "packet.h"
+@@ -3795,9 +3794,6 @@ static void batadv_tt_local_commit_changes_nolock(struct batadv_priv *bat_priv)
+ {
+ 	lockdep_assert_held(&bat_priv->tt.commit_lock);
+ 
+-	/* Update multicast addresses in local translation table */
+-	batadv_mcast_mla_update(bat_priv);
+-
+ 	if (atomic_read(&bat_priv->tt.local_changes) < 1) {
+ 		if (!batadv_atomic_dec_not_zero(&bat_priv->tt.ogm_append_cnt))
+ 			batadv_tt_tvlv_container_update(bat_priv);
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 673a22e..12c252d 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -785,9 +785,10 @@ struct batadv_mcast_querier_state {
+  * @num_want_all_ipv6: counter for items in want_all_ipv6_list
+  * @want_lists_lock: lock for protecting modifications to mcast want lists
+  *  (traversals are rcu-locked)
++ * @work: work queue callback item for multicast TT and TVLV updates
+  */
+ struct batadv_priv_mcast {
+-	struct hlist_head mla_list;
++	struct hlist_head mla_list; /* see __batadv_mcast_mla_update() */
+ 	struct hlist_head want_all_unsnoopables_list;
+ 	struct hlist_head want_all_ipv4_list;
+ 	struct hlist_head want_all_ipv6_list;
+@@ -802,6 +803,7 @@ struct batadv_priv_mcast {
+ 	atomic_t num_want_all_ipv6;
+ 	/* protects want_all_{unsnoopables,ipv4,ipv6}_list */
+ 	spinlock_t want_lists_lock;
++	struct delayed_work work;
+ };
+ #endif
+ 
diff --git a/batman-adv/patches/0030-batman-adv-Simple-re-broadcast-avoidance.patch b/batman-adv/patches/0030-batman-adv-Simple-re-broadcast-avoidance.patch
new file mode 100644
index 0000000..ebd2133
--- /dev/null
+++ b/batman-adv/patches/0030-batman-adv-Simple-re-broadcast-avoidance.patch
@@ -0,0 +1,456 @@
+From: Linus Lüssing <linus.luessing@c0d3.blue>
+Date: Sun, 7 Aug 2016 12:34:19 +0200
+Subject: [PATCH] batman-adv: Simple (re)broadcast avoidance
+
+With this patch, (re)broadcasting on a specific interfaces is avoided:
+
+* No neighbor: There is no need to broadcast on an interface if there
+  is no node behind it.
+
+* Single neighbor is source: If there is just one neighbor on an
+  interface and if this neighbor is the one we actually got this
+  broadcast packet from, then we do not need to echo it back.
+
+* Single neighbor is originator: If there is just one neighbor on
+  an interface and if this neighbor is the originator of this
+  broadcast packet, then we do not need to echo it back.
+
+Goodies for BATMAN V:
+
+("Upgrade your BATMAN IV network to V now to get these for free!")
+
+Thanks to the split of OGMv1 into two packet types, OGMv2 and ELP
+that is, we can now apply the same optimizations stated above to OGMv2
+packets, too.
+
+Furthermore, with BATMAN V, rebroadcasts can be reduced in certain
+multi interface cases, too, where BATMAN IV cannot. This is thanks to
+the removal of the "secondary interface originator" concept in BATMAN V.
+
+Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/bat_v_ogm.c      | 56 +++++++++++++++++++++++++++++++++++++++++
+ net/batman-adv/hard-interface.c | 52 ++++++++++++++++++++++++++++++++++++++
+ net/batman-adv/hard-interface.h | 16 ++++++++++++
+ net/batman-adv/originator.c     | 13 +++++++---
+ net/batman-adv/routing.c        |  2 +-
+ net/batman-adv/send.c           | 55 +++++++++++++++++++++++++++++++++++++++-
+ net/batman-adv/send.h           |  3 ++-
+ net/batman-adv/soft-interface.c |  2 +-
+ net/batman-adv/types.h          |  2 ++
+ 9 files changed, 193 insertions(+), 8 deletions(-)
+
+diff --git a/net/batman-adv/bat_v_ogm.c b/net/batman-adv/bat_v_ogm.c
+index 61ff5f8..9922ccd 100644
+--- a/net/batman-adv/bat_v_ogm.c
++++ b/net/batman-adv/bat_v_ogm.c
+@@ -140,6 +140,7 @@ static void batadv_v_ogm_send(struct work_struct *work)
+ 	unsigned char *ogm_buff, *pkt_buff;
+ 	int ogm_buff_len;
+ 	u16 tvlv_len = 0;
++	int ret;
+ 
+ 	bat_v = container_of(work, struct batadv_priv_bat_v, ogm_wq.work);
+ 	bat_priv = container_of(bat_v, struct batadv_priv, bat_v);
+@@ -182,6 +183,31 @@ static void batadv_v_ogm_send(struct work_struct *work)
+ 		if (!kref_get_unless_zero(&hard_iface->refcount))
+ 			continue;
+ 
++		ret = batadv_hardif_no_broadcast(hard_iface, NULL, NULL);
++		if (ret) {
++			char *type;
++
++			switch (ret) {
++			case BATADV_HARDIF_BCAST_NORECIPIENT:
++				type = "no neighbor";
++				break;
++			case BATADV_HARDIF_BCAST_DUPFWD:
++				type = "single neighbor is source";
++				break;
++			case BATADV_HARDIF_BCAST_DUPORIG:
++				type = "single neighbor is originator";
++				break;
++			default:
++				type = "unknown";
++			}
++
++			batadv_dbg(BATADV_DBG_BATMAN, bat_priv, "OGM2 from ourselve on %s surpressed: %s\n",
++				   hard_iface->net_dev->name, type);
++
++			batadv_hardif_put(hard_iface);
++			continue;
++		}
++
+ 		batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
+ 			   "Sending own OGM2 packet (originator %pM, seqno %u, throughput %u, TTL %d) on interface %s [%pM]\n",
+ 			   ogm_packet->orig, ntohl(ogm_packet->seqno),
+@@ -651,6 +677,7 @@ static void batadv_v_ogm_process(const struct sk_buff *skb, int ogm_offset,
+ 	struct batadv_hard_iface *hard_iface;
+ 	struct batadv_ogm2_packet *ogm_packet;
+ 	u32 ogm_throughput, link_throughput, path_throughput;
++	int ret;
+ 
+ 	ethhdr = eth_hdr(skb);
+ 	ogm_packet = (struct batadv_ogm2_packet *)(skb->data + ogm_offset);
+@@ -716,6 +743,35 @@ static void batadv_v_ogm_process(const struct sk_buff *skb, int ogm_offset,
+ 		if (!kref_get_unless_zero(&hard_iface->refcount))
+ 			continue;
+ 
++		ret = batadv_hardif_no_broadcast(hard_iface,
++						 ogm_packet->orig,
++						 hardif_neigh->orig);
++
++		if (ret) {
++			char *type;
++
++			switch (ret) {
++			case BATADV_HARDIF_BCAST_NORECIPIENT:
++				type = "no neighbor";
++				break;
++			case BATADV_HARDIF_BCAST_DUPFWD:
++				type = "single neighbor is source";
++				break;
++			case BATADV_HARDIF_BCAST_DUPORIG:
++				type = "single neighbor is originator";
++				break;
++			default:
++				type = "unknown";
++			}
++
++			batadv_dbg(BATADV_DBG_BATMAN, bat_priv, "OGM2 packet from %pM on %s surpressed: %s\n",
++				   ogm_packet->orig, hard_iface->net_dev->name,
++				   type);
++
++			batadv_hardif_put(hard_iface);
++			continue;
++		}
++
+ 		batadv_v_ogm_process_per_outif(bat_priv, ethhdr, ogm_packet,
+ 					       orig_node, neigh_node,
+ 					       if_incoming, hard_iface);
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index 08ce361..a7a462e 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -228,6 +228,58 @@ bool batadv_is_wifi_netdev(struct net_device *net_device)
+ 	return false;
+ }
+ 
++/**
++ * batadv_hardif_no_broadcast - check whether (re)broadcast is necessary
++ * @if_outgoing: the outgoing interface checked and considered for (re)broadcast
++ * @orig_addr: the originator of this packet
++ * @orig_neigh: originator address of the forwarder we just got the packet from
++ *  (NULL if we originated)
++ *
++ * Checks whether a packet needs to be (re)broadcasted on the given interface.
++ *
++ * Return:
++ *	BATADV_HARDIF_BCAST_NORECIPIENT: No neighbor on interface
++ *	BATADV_HARDIF_BCAST_DUPFWD: Just one neighbor, but it is the forwarder
++ *	BATADV_HARDIF_BCAST_DUPORIG: Just one neighbor, but it is the originator
++ *	BATADV_HARDIF_BCAST_OK: Several neighbors, must broadcast
++ */
++int batadv_hardif_no_broadcast(struct batadv_hard_iface *if_outgoing,
++			       u8 *orig_addr, u8 *orig_neigh)
++{
++	struct batadv_hardif_neigh_node *hardif_neigh;
++	struct hlist_node *first;
++	int ret = BATADV_HARDIF_BCAST_OK;
++
++	rcu_read_lock();
++
++	/* 0 neighbors -> no (re)broadcast */
++	first = rcu_dereference(hlist_first_rcu(&if_outgoing->neigh_list));
++	if (!first) {
++		ret = BATADV_HARDIF_BCAST_NORECIPIENT;
++		goto out;
++	}
++
++	/* >1 neighbors -> (re)brodcast */
++	if (rcu_dereference(hlist_next_rcu(first)))
++		goto out;
++
++	hardif_neigh = hlist_entry(first, struct batadv_hardif_neigh_node,
++				   list);
++
++	/* 1 neighbor, is the originator -> no rebroadcast */
++	if (orig_addr && batadv_compare_eth(hardif_neigh->orig, orig_addr)) {
++		ret = BATADV_HARDIF_BCAST_DUPORIG;
++	/* 1 neighbor, is the one we received from -> no rebroadcast */
++	} else if (orig_neigh &&
++		   batadv_compare_eth(hardif_neigh->orig, orig_neigh)) {
++		ret = BATADV_HARDIF_BCAST_DUPFWD;
++	}
++
++out:
++	rcu_read_unlock();
++	return ret;
++}
++
+ static struct batadv_hard_iface *
+ batadv_hardif_get_active(const struct net_device *soft_iface)
+ {
+diff --git a/net/batman-adv/hard-interface.h b/net/batman-adv/hard-interface.h
+index a76724d..a043182 100644
+--- a/net/batman-adv/hard-interface.h
++++ b/net/batman-adv/hard-interface.h
+@@ -40,6 +40,20 @@ enum batadv_hard_if_state {
+ };
+ 
+ /**
++ * enum batadv_hard_if_bcast - broadcast avoidance options
++ * @BATADV_HARDIF_BCAST_OK: Do broadcast on according hard interface
++ * @BATADV_HARDIF_BCAST_NORECIPIENT: Broadcast not needed, there is no recipient
++ * @BATADV_HARDIF_BCAST_DUPFWD: There is just the neighbor we got it from
++ * @BATADV_HARDIF_BCAST_DUPORIG: There is just the originator
++ */
++enum batadv_hard_if_bcast {
++	BATADV_HARDIF_BCAST_OK = 0,
++	BATADV_HARDIF_BCAST_NORECIPIENT,
++	BATADV_HARDIF_BCAST_DUPFWD,
++	BATADV_HARDIF_BCAST_DUPORIG,
++};
++
++/**
+  * enum batadv_hard_if_cleanup - Cleanup modi for soft_iface after slave removal
+  * @BATADV_IF_CLEANUP_KEEP: Don't automatically delete soft-interface
+  * @BATADV_IF_CLEANUP_AUTO: Delete soft-interface after last slave was removed
+@@ -63,6 +77,8 @@ void batadv_hardif_remove_interfaces(void);
+ int batadv_hardif_min_mtu(struct net_device *soft_iface);
+ void batadv_update_min_mtu(struct net_device *soft_iface);
+ void batadv_hardif_release(struct kref *ref);
++int batadv_hardif_no_broadcast(struct batadv_hard_iface *if_outgoing,
++			       u8 *orig_addr, u8 *orig_neigh);
+ 
+ /**
+  * batadv_hardif_put - decrement the hard interface refcounter and possibly
+diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
+index c6e7e1e..8f3b296 100644
+--- a/net/batman-adv/originator.c
++++ b/net/batman-adv/originator.c
+@@ -512,12 +512,14 @@ batadv_neigh_node_get(const struct batadv_orig_node *orig_node,
+  * batadv_hardif_neigh_create - create a hardif neighbour node
+  * @hard_iface: the interface this neighbour is connected to
+  * @neigh_addr: the interface address of the neighbour to retrieve
++ * @orig_node: originator object representing the neighbour
+  *
+  * Return: the hardif neighbour node if found or created or NULL otherwise.
+  */
+ static struct batadv_hardif_neigh_node *
+ batadv_hardif_neigh_create(struct batadv_hard_iface *hard_iface,
+-			   const u8 *neigh_addr)
++			   const u8 *neigh_addr,
++			   struct batadv_orig_node *orig_node)
+ {
+ 	struct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);
+ 	struct batadv_hardif_neigh_node *hardif_neigh;
+@@ -536,6 +538,7 @@ batadv_hardif_neigh_create(struct batadv_hard_iface *hard_iface,
+ 	kref_get(&hard_iface->refcount);
+ 	INIT_HLIST_NODE(&hardif_neigh->list);
+ 	ether_addr_copy(hardif_neigh->addr, neigh_addr);
++	ether_addr_copy(hardif_neigh->orig, orig_node->orig);
+ 	hardif_neigh->if_incoming = hard_iface;
+ 	hardif_neigh->last_seen = jiffies;
+ 
+@@ -556,12 +559,14 @@ out:
+  *  node
+  * @hard_iface: the interface this neighbour is connected to
+  * @neigh_addr: the interface address of the neighbour to retrieve
++ * @orig_node: originator object representing the neighbour
+  *
+  * Return: the hardif neighbour node if found or created or NULL otherwise.
+  */
+ static struct batadv_hardif_neigh_node *
+ batadv_hardif_neigh_get_or_create(struct batadv_hard_iface *hard_iface,
+-				  const u8 *neigh_addr)
++				  const u8 *neigh_addr,
++				  struct batadv_orig_node *orig_node)
+ {
+ 	struct batadv_hardif_neigh_node *hardif_neigh;
+ 
+@@ -570,7 +575,7 @@ batadv_hardif_neigh_get_or_create(struct batadv_hard_iface *hard_iface,
+ 	if (hardif_neigh)
+ 		return hardif_neigh;
+ 
+-	return batadv_hardif_neigh_create(hard_iface, neigh_addr);
++	return batadv_hardif_neigh_create(hard_iface, neigh_addr, orig_node);
+ }
+ 
+ /**
+@@ -630,7 +635,7 @@ batadv_neigh_node_create(struct batadv_orig_node *orig_node,
+ 		goto out;
+ 
+ 	hardif_neigh = batadv_hardif_neigh_get_or_create(hard_iface,
+-							 neigh_addr);
++							 neigh_addr, orig_node);
+ 	if (!hardif_neigh)
+ 		goto out;
+ 
+diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c
+index 7e8dc64..a4cb157 100644
+--- a/net/batman-adv/routing.c
++++ b/net/batman-adv/routing.c
+@@ -1170,7 +1170,7 @@ int batadv_recv_bcast_packet(struct sk_buff *skb,
+ 	batadv_skb_set_priority(skb, sizeof(struct batadv_bcast_packet));
+ 
+ 	/* rebroadcast packet */
+-	batadv_add_bcast_packet_to_list(bat_priv, skb, 1);
++	batadv_add_bcast_packet_to_list(bat_priv, skb, 1, false);
+ 
+ 	/* don't hand the broadcast up if it is from an originator
+ 	 * from the same backbone.
+diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
+index be3f6d7..d9bbb00 100644
+--- a/net/batman-adv/send.c
++++ b/net/batman-adv/send.c
+@@ -549,6 +549,7 @@ _batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+  * @bat_priv: the bat priv with all the soft interface information
+  * @skb: broadcast packet to add
+  * @delay: number of jiffies to wait before sending
++ * @own_packet: true if it is a self-generated broadcast packet
+  *
+  * add a broadcast packet to the queue and setup timers. broadcast packets
+  * are sent multiple times to increase probability for being received.
+@@ -560,7 +561,8 @@ _batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+  */
+ int batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+ 				    const struct sk_buff *skb,
+-				    unsigned long delay)
++				    unsigned long delay,
++				    bool own_packet)
+ {
+ 	struct batadv_hard_iface *primary_if;
+ 	struct batadv_forw_packet *forw_packet;
+@@ -587,6 +589,7 @@ int batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+ 	bcast_packet->ttl--;
+ 
+ 	forw_packet->skb = newskb;
++	forw_packet->own = own_packet;
+ 
+ 	INIT_DELAYED_WORK(&forw_packet->delayed_work,
+ 			  batadv_send_outstanding_bcast_packet);
+@@ -603,11 +606,16 @@ err:
+ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+ {
+ 	struct batadv_hard_iface *hard_iface;
++	struct batadv_hardif_neigh_node *neigh_node;
+ 	struct delayed_work *delayed_work;
+ 	struct batadv_forw_packet *forw_packet;
++	struct batadv_bcast_packet *bcast_packet;
+ 	struct sk_buff *skb1;
+ 	struct net_device *soft_iface;
+ 	struct batadv_priv *bat_priv;
++	u8 *neigh_addr;
++	u8 *orig_neigh;
++	int ret = 0;
+ 
+ 	delayed_work = to_delayed_work(work);
+ 	forw_packet = container_of(delayed_work, struct batadv_forw_packet,
+@@ -625,6 +633,8 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+ 	if (batadv_dat_drop_broadcast_packet(bat_priv, forw_packet))
+ 		goto out;
+ 
++	bcast_packet = (struct batadv_bcast_packet *)forw_packet->skb->data;
++
+ 	/* rebroadcast packet */
+ 	rcu_read_lock();
+ 	list_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {
+@@ -634,6 +644,49 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+ 		if (forw_packet->num_packets >= hard_iface->num_bcasts)
+ 			continue;
+ 
++		if (forw_packet->own) {
++			neigh_node = NULL;
++		} else {
++			neigh_addr = eth_hdr(forw_packet->skb)->h_source;
++			neigh_node = batadv_hardif_neigh_get(hard_iface,
++							     neigh_addr);
++		}
++
++		orig_neigh = neigh_node ? neigh_node->orig : NULL;
++
++		ret = batadv_hardif_no_broadcast(hard_iface, bcast_packet->orig,
++						 orig_neigh);
++
++		if (ret) {
++			char *type;
++
++			switch (ret) {
++			case BATADV_HARDIF_BCAST_NORECIPIENT:
++				type = "no neighbor";
++				break;
++			case BATADV_HARDIF_BCAST_DUPFWD:
++				type = "single neighbor is source";
++				break;
++			case BATADV_HARDIF_BCAST_DUPORIG:
++				type = "single neighbor is originator";
++				break;
++			default:
++				type = "unknown";
++			}
++
++			batadv_dbg(BATADV_DBG_BATMAN, bat_priv, "BCAST packet from orig %pM on %s surpressed: %s\n",
++				   bcast_packet->orig,
++				   hard_iface->net_dev->name, type);
++
++			if (neigh_node)
++				batadv_hardif_neigh_put(neigh_node);
++
++			continue;
++		}
++
++		if (neigh_node)
++			batadv_hardif_neigh_put(neigh_node);
++
+ 		if (!kref_get_unless_zero(&hard_iface->refcount))
+ 			continue;
+ 
+diff --git a/net/batman-adv/send.h b/net/batman-adv/send.h
+index 999f786..86009b5 100644
+--- a/net/batman-adv/send.h
++++ b/net/batman-adv/send.h
+@@ -46,7 +46,8 @@ int batadv_send_unicast_skb(struct sk_buff *skb,
+ 			    struct batadv_neigh_node *neigh_node);
+ int batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+ 				    const struct sk_buff *skb,
+-				    unsigned long delay);
++				    unsigned long delay,
++				    bool own_packet);
+ void
+ batadv_purge_outstanding_packets(struct batadv_priv *bat_priv,
+ 				 const struct batadv_hard_iface *hard_iface);
+diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
+index f37c1c7..109f53b 100644
+--- a/net/batman-adv/soft-interface.c
++++ b/net/batman-adv/soft-interface.c
+@@ -357,7 +357,7 @@ send:
+ 		seqno = atomic_inc_return(&bat_priv->bcast_seqno);
+ 		bcast_packet->seqno = htonl(seqno);
+ 
+-		batadv_add_bcast_packet_to_list(bat_priv, skb, brd_delay);
++		batadv_add_bcast_packet_to_list(bat_priv, skb, brd_delay, true);
+ 
+ 		/* a copy is stored in the bcast list, therefore removing
+ 		 * the original skb.
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 12c252d..05cbf39 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -408,6 +408,7 @@ struct batadv_hardif_neigh_node_bat_v {
+  * struct batadv_hardif_neigh_node - unique neighbor per hard-interface
+  * @list: list node for batadv_hard_iface::neigh_list
+  * @addr: the MAC address of the neighboring interface
++ * @orig: the address of the originator this neighbor node belongs to
+  * @if_incoming: pointer to incoming hard-interface
+  * @last_seen: when last packet via this neighbor was received
+  * @bat_v: B.A.T.M.A.N. V private data
+@@ -417,6 +418,7 @@ struct batadv_hardif_neigh_node_bat_v {
+ struct batadv_hardif_neigh_node {
+ 	struct hlist_node list;
+ 	u8 addr[ETH_ALEN];
++	u8 orig[ETH_ALEN];
+ 	struct batadv_hard_iface *if_incoming;
+ 	unsigned long last_seen;
+ #ifdef CONFIG_BATMAN_ADV_BATMAN_V
diff --git a/batman-adv/patches/0031-batman-adv-use-consume_skb-for-non-dropped-packets.patch b/batman-adv/patches/0031-batman-adv-use-consume_skb-for-non-dropped-packets.patch
new file mode 100644
index 0000000..21b43a9
--- /dev/null
+++ b/batman-adv/patches/0031-batman-adv-use-consume_skb-for-non-dropped-packets.patch
@@ -0,0 +1,359 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 17 Jul 2016 21:04:00 +0200
+Subject: [PATCH] batman-adv: use consume_skb for non-dropped packets
+
+kfree_skb assumes that an skb is dropped after an failure and notes that.
+consume_skb should be used in non-failure situations. Such information is
+important for dropmonitor netlink which tells how many packets were dropped
+and where this drop happened.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/bat_iv_ogm.c     | 13 ++++++++-----
+ net/batman-adv/fragmentation.c  | 20 ++++++++++++++------
+ net/batman-adv/network-coding.c | 24 +++++++++++++++---------
+ net/batman-adv/send.c           | 27 +++++++++++++++++++--------
+ net/batman-adv/send.h           |  3 ++-
+ net/batman-adv/soft-interface.c |  2 +-
+ 6 files changed, 59 insertions(+), 30 deletions(-)
+
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index 0b9be62..310f391 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -698,7 +698,7 @@ static void batadv_iv_ogm_aggregate_new(const unsigned char *packet_buff,
+ 
+ 	forw_packet_aggr->skb = netdev_alloc_skb_ip_align(NULL, skb_size);
+ 	if (!forw_packet_aggr->skb) {
+-		batadv_forw_packet_free(forw_packet_aggr);
++		batadv_forw_packet_free(forw_packet_aggr, true);
+ 		return;
+ 	}
+ 
+@@ -1611,7 +1611,7 @@ out:
+ 	if (hardif_neigh)
+ 		batadv_hardif_neigh_put(hardif_neigh);
+ 
+-	kfree_skb(skb_priv);
++	consume_skb(skb_priv);
+ }
+ 
+ /**
+@@ -1783,6 +1783,7 @@ static void batadv_iv_send_outstanding_bat_ogm_packet(struct work_struct *work)
+ 	struct delayed_work *delayed_work;
+ 	struct batadv_forw_packet *forw_packet;
+ 	struct batadv_priv *bat_priv;
++	bool dropped = false;
+ 
+ 	delayed_work = to_delayed_work(work);
+ 	forw_packet = container_of(delayed_work, struct batadv_forw_packet,
+@@ -1792,8 +1793,10 @@ static void batadv_iv_send_outstanding_bat_ogm_packet(struct work_struct *work)
+ 	hlist_del(&forw_packet->list);
+ 	spin_unlock_bh(&bat_priv->forw_bat_list_lock);
+ 
+-	if (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING)
++	if (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING) {
++		dropped = true;
+ 		goto out;
++	}
+ 
+ 	batadv_iv_ogm_emit(forw_packet);
+ 
+@@ -1810,7 +1813,7 @@ static void batadv_iv_send_outstanding_bat_ogm_packet(struct work_struct *work)
+ 		batadv_iv_ogm_schedule(forw_packet->if_incoming);
+ 
+ out:
+-	batadv_forw_packet_free(forw_packet);
++	batadv_forw_packet_free(forw_packet, dropped);
+ }
+ 
+ static int batadv_iv_ogm_receive(struct sk_buff *skb,
+@@ -1851,7 +1854,7 @@ static int batadv_iv_ogm_receive(struct sk_buff *skb,
+ 		ogm_packet = (struct batadv_ogm_packet *)packet_pos;
+ 	}
+ 
+-	kfree_skb(skb);
++	consume_skb(skb);
+ 	return NET_RX_SUCCESS;
+ }
+ 
+diff --git a/net/batman-adv/fragmentation.c b/net/batman-adv/fragmentation.c
+index 2b967a3..a2e28a1 100644
+--- a/net/batman-adv/fragmentation.c
++++ b/net/batman-adv/fragmentation.c
+@@ -42,17 +42,23 @@
+ /**
+  * batadv_frag_clear_chain - delete entries in the fragment buffer chain
+  * @head: head of chain with entries.
++ * @dropped: whether the chain is cleared because all fragments are dropped
+  *
+  * Free fragments in the passed hlist. Should be called with appropriate lock.
+  */
+-static void batadv_frag_clear_chain(struct hlist_head *head)
++static void batadv_frag_clear_chain(struct hlist_head *head, bool dropped)
+ {
+ 	struct batadv_frag_list_entry *entry;
+ 	struct hlist_node *node;
+ 
+ 	hlist_for_each_entry_safe(entry, node, head, list) {
+ 		hlist_del(&entry->list);
+-		kfree_skb(entry->skb);
++
++		if (dropped)
++			kfree_skb(entry->skb);
++		else
++			consume_skb(entry->skb);
++
+ 		kfree(entry);
+ 	}
+ }
+@@ -73,7 +79,7 @@ void batadv_frag_purge_orig(struct batadv_orig_node *orig_node,
+ 		spin_lock_bh(&chain->lock);
+ 
+ 		if (!check_cb || check_cb(chain)) {
+-			batadv_frag_clear_chain(&chain->fragment_list);
++			batadv_frag_clear_chain(&chain->fragment_list, true);
+ 			chain->size = 0;
+ 		}
+ 
+@@ -118,7 +124,7 @@ static bool batadv_frag_init_chain(struct batadv_frag_table_entry *chain,
+ 		return false;
+ 
+ 	if (!hlist_empty(&chain->fragment_list))
+-		batadv_frag_clear_chain(&chain->fragment_list);
++		batadv_frag_clear_chain(&chain->fragment_list, true);
+ 
+ 	chain->size = 0;
+ 	chain->seqno = seqno;
+@@ -220,7 +226,7 @@ out:
+ 		 * exceeds the maximum size of one merged packet. Don't allow
+ 		 * packets to have different total_size.
+ 		 */
+-		batadv_frag_clear_chain(&chain->fragment_list);
++		batadv_frag_clear_chain(&chain->fragment_list, true);
+ 		chain->size = 0;
+ 	} else if (ntohs(frag_packet->total_size) == chain->size) {
+ 		/* All fragments received. Hand over chain to caller. */
+@@ -254,6 +260,7 @@ batadv_frag_merge_packets(struct hlist_head *chain)
+ 	struct batadv_frag_list_entry *entry;
+ 	struct sk_buff *skb_out;
+ 	int size, hdr_size = sizeof(struct batadv_frag_packet);
++	bool dropped = false;
+ 
+ 	/* Remove first entry, as this is the destination for the rest of the
+ 	 * fragments.
+@@ -270,6 +277,7 @@ batadv_frag_merge_packets(struct hlist_head *chain)
+ 	if (pskb_expand_head(skb_out, 0, size - skb_out->len, GFP_ATOMIC) < 0) {
+ 		kfree_skb(skb_out);
+ 		skb_out = NULL;
++		dropped = true;
+ 		goto free;
+ 	}
+ 
+@@ -291,7 +299,7 @@ batadv_frag_merge_packets(struct hlist_head *chain)
+ 
+ free:
+ 	/* Locking is not needed, because 'chain' is not part of any orig. */
+-	batadv_frag_clear_chain(chain);
++	batadv_frag_clear_chain(chain, dropped);
+ 	return skb_out;
+ }
+ 
+diff --git a/net/batman-adv/network-coding.c b/net/batman-adv/network-coding.c
+index c213dde..3af66d3 100644
+--- a/net/batman-adv/network-coding.c
++++ b/net/batman-adv/network-coding.c
+@@ -260,10 +260,16 @@ static void batadv_nc_path_put(struct batadv_nc_path *nc_path)
+ /**
+  * batadv_nc_packet_free - frees nc packet
+  * @nc_packet: the nc packet to free
++ * @dropped: whether the packet is freed because is is dropped
+  */
+-static void batadv_nc_packet_free(struct batadv_nc_packet *nc_packet)
++static void batadv_nc_packet_free(struct batadv_nc_packet *nc_packet,
++				  bool dropped)
+ {
+-	kfree_skb(nc_packet->skb);
++	if (dropped)
++		kfree_skb(nc_packet->skb);
++	else
++		consume_skb(nc_packet->skb);
++
+ 	batadv_nc_path_put(nc_packet->nc_path);
+ 	kfree(nc_packet);
+ }
+@@ -576,7 +582,7 @@ static void batadv_nc_send_packet(struct batadv_nc_packet *nc_packet)
+ {
+ 	batadv_send_unicast_skb(nc_packet->skb, nc_packet->neigh_node);
+ 	nc_packet->skb = NULL;
+-	batadv_nc_packet_free(nc_packet);
++	batadv_nc_packet_free(nc_packet, false);
+ }
+ 
+ /**
+@@ -610,7 +616,7 @@ static bool batadv_nc_sniffed_purge(struct batadv_priv *bat_priv,
+ 
+ 	/* purge nc packet */
+ 	list_del(&nc_packet->list);
+-	batadv_nc_packet_free(nc_packet);
++	batadv_nc_packet_free(nc_packet, true);
+ 
+ 	res = true;
+ 
+@@ -1208,11 +1214,11 @@ static bool batadv_nc_code_packets(struct batadv_priv *bat_priv,
+ 	}
+ 
+ 	/* skb_src is now coded into skb_dest, so free it */
+-	kfree_skb(skb_src);
++	consume_skb(skb_src);
+ 
+ 	/* avoid duplicate free of skb from nc_packet */
+ 	nc_packet->skb = NULL;
+-	batadv_nc_packet_free(nc_packet);
++	batadv_nc_packet_free(nc_packet, false);
+ 
+ 	/* Send the coded packet and return true */
+ 	batadv_send_unicast_skb(skb_dest, first_dest);
+@@ -1399,7 +1405,7 @@ static void batadv_nc_skb_store_before_coding(struct batadv_priv *bat_priv,
+ 	/* batadv_nc_skb_store_for_decoding() clones the skb, so we must free
+ 	 * our ref
+ 	 */
+-	kfree_skb(skb);
++	consume_skb(skb);
+ }
+ 
+ /**
+@@ -1723,7 +1729,7 @@ batadv_nc_skb_decode_packet(struct batadv_priv *bat_priv, struct sk_buff *skb,
+ 	ether_addr_copy(unicast_packet->dest, orig_dest);
+ 	unicast_packet->ttvn = ttvn;
+ 
+-	batadv_nc_packet_free(nc_packet);
++	batadv_nc_packet_free(nc_packet, false);
+ 	return unicast_packet;
+ }
+ 
+@@ -1860,7 +1866,7 @@ static int batadv_nc_recv_coded_packet(struct sk_buff *skb,
+ 	return batadv_recv_unicast_packet(skb, recv_if);
+ 
+ free_nc_packet:
+-	batadv_nc_packet_free(nc_packet);
++	batadv_nc_packet_free(nc_packet, true);
+ 	return NET_RX_DROP;
+ }
+ 
+diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
+index d9bbb00..0f86293 100644
+--- a/net/batman-adv/send.c
++++ b/net/batman-adv/send.c
+@@ -451,13 +451,19 @@ int batadv_send_skb_via_gw(struct batadv_priv *bat_priv, struct sk_buff *skb,
+ /**
+  * batadv_forw_packet_free - free a forwarding packet
+  * @forw_packet: The packet to free
++ * @dropped: whether the packet is freed because is is dropped
+  *
+  * This frees a forwarding packet and releases any resources it might
+  * have claimed.
+  */
+-void batadv_forw_packet_free(struct batadv_forw_packet *forw_packet)
++void batadv_forw_packet_free(struct batadv_forw_packet *forw_packet,
++			     bool dropped)
+ {
+-	kfree_skb(forw_packet->skb);
++	if (dropped)
++		kfree_skb(forw_packet->skb);
++	else
++		consume_skb(forw_packet->skb);
++
+ 	if (forw_packet->if_incoming)
+ 		batadv_hardif_put(forw_packet->if_incoming);
+ 	if (forw_packet->if_outgoing)
+@@ -598,7 +604,7 @@ int batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+ 	return NETDEV_TX_OK;
+ 
+ err_packet_free:
+-	batadv_forw_packet_free(forw_packet);
++	batadv_forw_packet_free(forw_packet, true);
+ err:
+ 	return NETDEV_TX_BUSY;
+ }
+@@ -613,6 +619,7 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+ 	struct sk_buff *skb1;
+ 	struct net_device *soft_iface;
+ 	struct batadv_priv *bat_priv;
++	bool dropped = false;
+ 	u8 *neigh_addr;
+ 	u8 *orig_neigh;
+ 	int ret = 0;
+@@ -627,11 +634,15 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+ 	hlist_del(&forw_packet->list);
+ 	spin_unlock_bh(&bat_priv->forw_bcast_list_lock);
+ 
+-	if (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING)
++	if (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING) {
++		dropped = true;
+ 		goto out;
++	}
+ 
+-	if (batadv_dat_drop_broadcast_packet(bat_priv, forw_packet))
++	if (batadv_dat_drop_broadcast_packet(bat_priv, forw_packet)) {
++		dropped = true;
+ 		goto out;
++	}
+ 
+ 	bcast_packet = (struct batadv_bcast_packet *)forw_packet->skb->data;
+ 
+@@ -709,7 +720,7 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+ 	}
+ 
+ out:
+-	batadv_forw_packet_free(forw_packet);
++	batadv_forw_packet_free(forw_packet, dropped);
+ }
+ 
+ void
+@@ -750,7 +761,7 @@ batadv_purge_outstanding_packets(struct batadv_priv *bat_priv,
+ 
+ 		if (pending) {
+ 			hlist_del(&forw_packet->list);
+-			batadv_forw_packet_free(forw_packet);
++			batadv_forw_packet_free(forw_packet, true);
+ 		}
+ 	}
+ 	spin_unlock_bh(&bat_priv->forw_bcast_list_lock);
+@@ -777,7 +788,7 @@ batadv_purge_outstanding_packets(struct batadv_priv *bat_priv,
+ 
+ 		if (pending) {
+ 			hlist_del(&forw_packet->list);
+-			batadv_forw_packet_free(forw_packet);
++			batadv_forw_packet_free(forw_packet, true);
+ 		}
+ 	}
+ 	spin_unlock_bh(&bat_priv->forw_bat_list_lock);
+diff --git a/net/batman-adv/send.h b/net/batman-adv/send.h
+index 86009b5..c580194 100644
+--- a/net/batman-adv/send.h
++++ b/net/batman-adv/send.h
+@@ -27,7 +27,8 @@
+ 
+ struct sk_buff;
+ 
+-void batadv_forw_packet_free(struct batadv_forw_packet *forw_packet);
++void batadv_forw_packet_free(struct batadv_forw_packet *forw_packet,
++			     bool dropped);
+ struct batadv_forw_packet *
+ batadv_forw_packet_alloc(struct batadv_hard_iface *if_incoming,
+ 			 struct batadv_hard_iface *if_outgoing,
+diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
+index 109f53b..2f0304e 100644
+--- a/net/batman-adv/soft-interface.c
++++ b/net/batman-adv/soft-interface.c
+@@ -362,7 +362,7 @@ send:
+ 		/* a copy is stored in the bcast list, therefore removing
+ 		 * the original skb.
+ 		 */
+-		kfree_skb(skb);
++		consume_skb(skb);
+ 
+ 	/* unicast packet */
+ 	} else {
diff --git a/batman-adv/patches/0032-batman-adv-Count-all-non-success-TX-packets-as-dropp.patch b/batman-adv/patches/0032-batman-adv-Count-all-non-success-TX-packets-as-dropp.patch
new file mode 100644
index 0000000..7b0bf95
--- /dev/null
+++ b/batman-adv/patches/0032-batman-adv-Count-all-non-success-TX-packets-as-dropp.patch
@@ -0,0 +1,27 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 17 Jul 2016 21:04:01 +0200
+Subject: [PATCH] batman-adv: Count all non-success TX packets as dropped
+
+A failure during the submission also causes dropped packets.
+batadv_interface_tx should therefore also increase the DROPPED counter for
+these returns.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/soft-interface.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
+index 2f0304e..7b3494a 100644
+--- a/net/batman-adv/soft-interface.c
++++ b/net/batman-adv/soft-interface.c
+@@ -386,7 +386,7 @@ send:
+ 			ret = batadv_send_skb_via_tt(bat_priv, skb, dst_hint,
+ 						     vid);
+ 		}
+-		if (ret == NET_XMIT_DROP)
++		if (ret != NET_XMIT_SUCCESS)
+ 			goto dropped_freed;
+ 	}
+ 
diff --git a/batman-adv/patches/0033-batman-adv-Consume-skb-in-batadv_frag_send_packet.patch b/batman-adv/patches/0033-batman-adv-Consume-skb-in-batadv_frag_send_packet.patch
new file mode 100644
index 0000000..2c62550
--- /dev/null
+++ b/batman-adv/patches/0033-batman-adv-Consume-skb-in-batadv_frag_send_packet.patch
@@ -0,0 +1,131 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 17 Jul 2016 21:04:02 +0200
+Subject: [PATCH] batman-adv: Consume skb in batadv_frag_send_packet
+
+Sending functions in Linux consume the supplied skbuff. Doing the same in
+batadv_frag_send_packet avoids the hack of returning -1 (-EPERM) to signal
+the caller that he is responsible for cleaning up the skb.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/fragmentation.c | 50 ++++++++++++++++++++++++------------------
+ 1 file changed, 29 insertions(+), 21 deletions(-)
+
+diff --git a/net/batman-adv/fragmentation.c b/net/batman-adv/fragmentation.c
+index a2e28a1..9c561e6 100644
+--- a/net/batman-adv/fragmentation.c
++++ b/net/batman-adv/fragmentation.c
+@@ -20,6 +20,7 @@
+ 
+ #include <linux/atomic.h>
+ #include <linux/byteorder/generic.h>
++#include <linux/errno.h>
+ #include <linux/etherdevice.h>
+ #include <linux/fs.h>
+ #include <linux/if_ether.h>
+@@ -441,8 +442,7 @@ err:
+  * @orig_node: final destination of the created fragments
+  * @neigh_node: next-hop of the created fragments
+  *
+- * Return: the netdev tx status or -1 in case of error.
+- * When -1 is returned the skb is not consumed.
++ * Return: the netdev tx status or a negative errno code on a failure
+  */
+ int batadv_frag_send_packet(struct sk_buff *skb,
+ 			    struct batadv_orig_node *orig_node,
+@@ -455,7 +455,7 @@ int batadv_frag_send_packet(struct sk_buff *skb,
+ 	unsigned int mtu = neigh_node->if_incoming->net_dev->mtu;
+ 	unsigned int header_size = sizeof(frag_header);
+ 	unsigned int max_fragment_size, max_packet_size;
+-	int ret = -1;
++	int ret;
+ 
+ 	/* To avoid merge and refragmentation at next-hops we never send
+ 	 * fragments larger than BATADV_FRAG_MAX_FRAG_SIZE
+@@ -465,13 +465,17 @@ int batadv_frag_send_packet(struct sk_buff *skb,
+ 	max_packet_size = max_fragment_size * BATADV_FRAG_MAX_FRAGMENTS;
+ 
+ 	/* Don't even try to fragment, if we need more than 16 fragments */
+-	if (skb->len > max_packet_size)
+-		goto out;
++	if (skb->len > max_packet_size) {
++		ret = -EAGAIN;
++		goto free_skb;
++	}
+ 
+ 	bat_priv = orig_node->bat_priv;
+ 	primary_if = batadv_primary_if_get_selected(bat_priv);
+-	if (!primary_if)
+-		goto out;
++	if (!primary_if) {
++		ret = -EINVAL;
++		goto put_primary_if;
++	}
+ 
+ 	/* Create one header to be copied to all fragments */
+ 	frag_header.packet_type = BATADV_UNICAST_FRAG;
+@@ -496,34 +500,35 @@ int batadv_frag_send_packet(struct sk_buff *skb,
+ 	/* Eat and send fragments from the tail of skb */
+ 	while (skb->len > max_fragment_size) {
+ 		skb_fragment = batadv_frag_create(skb, &frag_header, mtu);
+-		if (!skb_fragment)
+-			goto out;
++		if (!skb_fragment) {
++			ret = -ENOMEM;
++			goto free_skb;
++		}
+ 
+ 		batadv_inc_counter(bat_priv, BATADV_CNT_FRAG_TX);
+ 		batadv_add_counter(bat_priv, BATADV_CNT_FRAG_TX_BYTES,
+ 				   skb_fragment->len + ETH_HLEN);
+ 		ret = batadv_send_unicast_skb(skb_fragment, neigh_node);
+ 		if (ret != NET_XMIT_SUCCESS) {
+-			/* return -1 so that the caller can free the original
+-			 * skb
+-			 */
+-			ret = -1;
+-			goto out;
++			ret = NET_XMIT_DROP;
++			goto free_skb;
+ 		}
+ 
+ 		frag_header.no++;
+ 
+ 		/* The initial check in this function should cover this case */
+ 		if (frag_header.no == BATADV_FRAG_MAX_FRAGMENTS - 1) {
+-			ret = -1;
+-			goto out;
++			ret = -EINVAL;
++			goto free_skb;
+ 		}
+ 	}
+ 
+ 	/* Make room for the fragment header. */
+ 	if (batadv_skb_head_push(skb, header_size) < 0 ||
+-	    pskb_expand_head(skb, header_size + ETH_HLEN, 0, GFP_ATOMIC) < 0)
+-		goto out;
++	    pskb_expand_head(skb, header_size + ETH_HLEN, 0, GFP_ATOMIC) < 0) {
++		ret = -ENOMEM;
++		goto free_skb;
++	}
+ 
+ 	memcpy(skb->data, &frag_header, header_size);
+ 
+@@ -532,10 +537,13 @@ int batadv_frag_send_packet(struct sk_buff *skb,
+ 	batadv_add_counter(bat_priv, BATADV_CNT_FRAG_TX_BYTES,
+ 			   skb->len + ETH_HLEN);
+ 	ret = batadv_send_unicast_skb(skb, neigh_node);
++	/* skb was consumed */
++	skb = NULL;
+ 
+-out:
+-	if (primary_if)
+-		batadv_hardif_put(primary_if);
++put_primary_if:
++	batadv_hardif_put(primary_if);
++free_skb:
++	kfree_skb(skb);
+ 
+ 	return ret;
+ }
diff --git a/batman-adv/patches/0034-batman-adv-Consume-skb-in-batadv_send_skb_to_orig.patch b/batman-adv/patches/0034-batman-adv-Consume-skb-in-batadv_send_skb_to_orig.patch
new file mode 100644
index 0000000..912f20b
--- /dev/null
+++ b/batman-adv/patches/0034-batman-adv-Consume-skb-in-batadv_send_skb_to_orig.patch
@@ -0,0 +1,199 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 17 Jul 2016 21:04:03 +0200
+Subject: [PATCH] batman-adv: Consume skb in batadv_send_skb_to_orig
+
+Sending functions in Linux consume the supplied skbuff. Doing the same in
+batadv_send_skb_to_orig avoids the hack of returning -1 (-EPERM) to signal
+the caller that he is responsible for cleaning up the skb.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/routing.c  | 11 ++---------
+ net/batman-adv/send.c     | 39 ++++++++++++++++++++++-----------------
+ net/batman-adv/tp_meter.c |  6 ------
+ net/batman-adv/tvlv.c     |  5 +----
+ 4 files changed, 25 insertions(+), 36 deletions(-)
+
+diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c
+index a4cb157..4d2679a 100644
+--- a/net/batman-adv/routing.c
++++ b/net/batman-adv/routing.c
+@@ -262,9 +262,6 @@ static int batadv_recv_my_icmp_packet(struct batadv_priv *bat_priv,
+ 		icmph->ttl = BATADV_TTL;
+ 
+ 		res = batadv_send_skb_to_orig(skb, orig_node, NULL);
+-		if (res == -1)
+-			goto out;
+-
+ 		ret = NET_RX_SUCCESS;
+ 
+ 		break;
+@@ -325,8 +322,7 @@ static int batadv_recv_icmp_ttl_exceeded(struct batadv_priv *bat_priv,
+ 	icmp_packet->ttl = BATADV_TTL;
+ 
+ 	res = batadv_send_skb_to_orig(skb, orig_node, NULL);
+-	if (res != -1)
+-		ret = NET_RX_SUCCESS;
++	ret = NET_RX_SUCCESS;
+ 
+ out:
+ 	if (primary_if)
+@@ -413,8 +409,7 @@ int batadv_recv_icmp_packet(struct sk_buff *skb,
+ 
+ 	/* route it */
+ 	res = batadv_send_skb_to_orig(skb, orig_node, recv_if);
+-	if (res != -1)
+-		ret = NET_RX_SUCCESS;
++	ret = NET_RX_SUCCESS;
+ 
+ out:
+ 	if (orig_node)
+@@ -702,8 +697,6 @@ static int batadv_route_unicast_packet(struct sk_buff *skb,
+ 
+ 	len = skb->len;
+ 	res = batadv_send_skb_to_orig(skb, orig_node, recv_if);
+-	if (res == -1)
+-		goto out;
+ 
+ 	/* translate transmit result into receive result */
+ 	if (res == NET_XMIT_SUCCESS) {
+diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
+index 0f86293..b00aac7 100644
+--- a/net/batman-adv/send.c
++++ b/net/batman-adv/send.c
+@@ -165,11 +165,9 @@ int batadv_send_unicast_skb(struct sk_buff *skb,
+  * host, NULL can be passed as recv_if and no interface alternating is
+  * attempted.
+  *
+- * Return: -1 on failure (and the skb is not consumed), -EINPROGRESS if the
+- * skb is buffered for later transmit or the NET_XMIT status returned by the
++ * Return: negative errno code on a failure, -EINPROGRESS if the skb is
++ * buffered for later transmit or the NET_XMIT status returned by the
+  * lower routine if the packet has been passed down.
+- *
+- * If the returning value is not -1 the skb has been consumed.
+  */
+ int batadv_send_skb_to_orig(struct sk_buff *skb,
+ 			    struct batadv_orig_node *orig_node,
+@@ -177,12 +175,14 @@ int batadv_send_skb_to_orig(struct sk_buff *skb,
+ {
+ 	struct batadv_priv *bat_priv = orig_node->bat_priv;
+ 	struct batadv_neigh_node *neigh_node;
+-	int ret = -1;
++	int ret;
+ 
+ 	/* batadv_find_router() increases neigh_nodes refcount if found. */
+ 	neigh_node = batadv_find_router(bat_priv, orig_node, recv_if);
+-	if (!neigh_node)
+-		goto out;
++	if (!neigh_node) {
++		ret = -EINVAL;
++		goto free_skb;
++	}
+ 
+ 	/* Check if the skb is too large to send in one piece and fragment
+ 	 * it if needed.
+@@ -191,8 +191,10 @@ int batadv_send_skb_to_orig(struct sk_buff *skb,
+ 	    skb->len > neigh_node->if_incoming->net_dev->mtu) {
+ 		/* Fragment and send packet. */
+ 		ret = batadv_frag_send_packet(skb, orig_node, neigh_node);
++		/* skb was consumed */
++		skb = NULL;
+ 
+-		goto out;
++		goto put_neigh_node;
+ 	}
+ 
+ 	/* try to network code the packet, if it is received on an interface
+@@ -204,9 +206,13 @@ int batadv_send_skb_to_orig(struct sk_buff *skb,
+ 	else
+ 		ret = batadv_send_unicast_skb(skb, neigh_node);
+ 
+-out:
+-	if (neigh_node)
+-		batadv_neigh_node_put(neigh_node);
++	/* skb was consumed */
++	skb = NULL;
++
++put_neigh_node:
++	batadv_neigh_node_put(neigh_node);
++free_skb:
++	kfree_skb(skb);
+ 
+ 	return ret;
+ }
+@@ -327,7 +333,7 @@ int batadv_send_skb_unicast(struct batadv_priv *bat_priv,
+ {
+ 	struct batadv_unicast_packet *unicast_packet;
+ 	struct ethhdr *ethhdr;
+-	int res, ret = NET_XMIT_DROP;
++	int ret = NET_XMIT_DROP;
+ 
+ 	if (!orig_node)
+ 		goto out;
+@@ -364,13 +370,12 @@ int batadv_send_skb_unicast(struct batadv_priv *bat_priv,
+ 	if (batadv_tt_global_client_is_roaming(bat_priv, ethhdr->h_dest, vid))
+ 		unicast_packet->ttvn = unicast_packet->ttvn - 1;
+ 
+-	res = batadv_send_skb_to_orig(skb, orig_node, NULL);
+-	if (res != -1)
+-		ret = NET_XMIT_SUCCESS;
++	ret = batadv_send_skb_to_orig(skb, orig_node, NULL);
++	 /* skb was consumed */
++	skb = NULL;
+ 
+ out:
+-	if (ret == NET_XMIT_DROP)
+-		kfree_skb(skb);
++	kfree_skb(skb);
+ 	return ret;
+ }
+ 
+diff --git a/net/batman-adv/tp_meter.c b/net/batman-adv/tp_meter.c
+index 8af1611..981e8c5 100644
+--- a/net/batman-adv/tp_meter.c
++++ b/net/batman-adv/tp_meter.c
+@@ -615,9 +615,6 @@ static int batadv_tp_send_msg(struct batadv_tp_vars *tp_vars, const u8 *src,
+ 	batadv_tp_fill_prerandom(tp_vars, data, data_len);
+ 
+ 	r = batadv_send_skb_to_orig(skb, orig_node, NULL);
+-	if (r == -1)
+-		kfree_skb(skb);
+-
+ 	if (r == NET_XMIT_SUCCESS)
+ 		return 0;
+ 
+@@ -1207,9 +1204,6 @@ static int batadv_tp_send_ack(struct batadv_priv *bat_priv, const u8 *dst,
+ 
+ 	/* send the ack */
+ 	r = batadv_send_skb_to_orig(skb, orig_node, NULL);
+-	if (r == -1)
+-		kfree_skb(skb);
+-
+ 	if (unlikely(r < 0) || (r == NET_XMIT_DROP)) {
+ 		ret = BATADV_TP_REASON_DST_UNREACHABLE;
+ 		goto out;
+diff --git a/net/batman-adv/tvlv.c b/net/batman-adv/tvlv.c
+index 77654f0..a783420 100644
+--- a/net/batman-adv/tvlv.c
++++ b/net/batman-adv/tvlv.c
+@@ -600,7 +600,6 @@ void batadv_tvlv_unicast_send(struct batadv_priv *bat_priv, u8 *src,
+ 	unsigned char *tvlv_buff;
+ 	unsigned int tvlv_len;
+ 	ssize_t hdr_len = sizeof(*unicast_tvlv_packet);
+-	int res;
+ 
+ 	orig_node = batadv_orig_hash_find(bat_priv, dst);
+ 	if (!orig_node)
+@@ -633,9 +632,7 @@ void batadv_tvlv_unicast_send(struct batadv_priv *bat_priv, u8 *src,
+ 	tvlv_buff += sizeof(*tvlv_hdr);
+ 	memcpy(tvlv_buff, tvlv_value, tvlv_value_len);
+ 
+-	res = batadv_send_skb_to_orig(skb, orig_node, NULL);
+-	if (res == -1)
+-		kfree_skb(skb);
++	batadv_send_skb_to_orig(skb, orig_node, NULL);
+ out:
+ 	batadv_orig_node_put(orig_node);
+ }
diff --git a/batman-adv/patches/0035-batman-adv-Consume-skb-in-receive-handlers.patch b/batman-adv/patches/0035-batman-adv-Consume-skb-in-receive-handlers.patch
new file mode 100644
index 0000000..5be95ed
--- /dev/null
+++ b/batman-adv/patches/0035-batman-adv-Consume-skb-in-receive-handlers.patch
@@ -0,0 +1,665 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 17 Jul 2016 21:04:04 +0200
+Subject: [PATCH] batman-adv: Consume skb in receive handlers
+
+Receiving functions in Linux consume the supplied skbuff. Doing the same in
+the batadv_rx_handler functions makes the behavior more similar to the rest
+of the Linux network code.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/bat_iv_ogm.c     |  22 ++++--
+ net/batman-adv/bat_v_elp.c      |  30 ++++----
+ net/batman-adv/bat_v_ogm.c      |  15 ++--
+ net/batman-adv/main.c           |  11 +--
+ net/batman-adv/network-coding.c |  11 +--
+ net/batman-adv/routing.c        | 149 +++++++++++++++++++++++++++-------------
+ 6 files changed, 153 insertions(+), 85 deletions(-)
+
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index 310f391..bd39247 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -1823,17 +1823,18 @@ static int batadv_iv_ogm_receive(struct sk_buff *skb,
+ 	struct batadv_ogm_packet *ogm_packet;
+ 	u8 *packet_pos;
+ 	int ogm_offset;
+-	bool ret;
++	bool res;
++	int ret = NET_RX_DROP;
+ 
+-	ret = batadv_check_management_packet(skb, if_incoming, BATADV_OGM_HLEN);
+-	if (!ret)
+-		return NET_RX_DROP;
++	res = batadv_check_management_packet(skb, if_incoming, BATADV_OGM_HLEN);
++	if (!res)
++		goto free_skb;
+ 
+ 	/* did we receive a B.A.T.M.A.N. IV OGM packet on an interface
+ 	 * that does not have B.A.T.M.A.N. IV enabled ?
+ 	 */
+ 	if (bat_priv->algo_ops->iface.enable != batadv_iv_ogm_iface_enable)
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	batadv_inc_counter(bat_priv, BATADV_CNT_MGMT_RX);
+ 	batadv_add_counter(bat_priv, BATADV_CNT_MGMT_RX_BYTES,
+@@ -1854,8 +1855,15 @@ static int batadv_iv_ogm_receive(struct sk_buff *skb,
+ 		ogm_packet = (struct batadv_ogm_packet *)packet_pos;
+ 	}
+ 
+-	consume_skb(skb);
+-	return NET_RX_SUCCESS;
++	ret = NET_RX_SUCCESS;
++
++free_skb:
++	if (ret == NET_RX_SUCCESS)
++		consume_skb(skb);
++	else
++		kfree_skb(skb);
++
++	return ret;
+ }
+ 
+ #ifdef CONFIG_BATMAN_ADV_DEBUGFS
+diff --git a/net/batman-adv/bat_v_elp.c b/net/batman-adv/bat_v_elp.c
+index ee08540..54bdd41 100644
+--- a/net/batman-adv/bat_v_elp.c
++++ b/net/batman-adv/bat_v_elp.c
+@@ -492,20 +492,21 @@ int batadv_v_elp_packet_recv(struct sk_buff *skb,
+ 	struct batadv_elp_packet *elp_packet;
+ 	struct batadv_hard_iface *primary_if;
+ 	struct ethhdr *ethhdr = (struct ethhdr *)skb_mac_header(skb);
+-	bool ret;
++	bool res;
++	int ret = NET_RX_DROP;
+ 
+-	ret = batadv_check_management_packet(skb, if_incoming, BATADV_ELP_HLEN);
+-	if (!ret)
+-		return NET_RX_DROP;
++	res = batadv_check_management_packet(skb, if_incoming, BATADV_ELP_HLEN);
++	if (!res)
++		goto free_skb;
+ 
+ 	if (batadv_is_my_mac(bat_priv, ethhdr->h_source))
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	/* did we receive a B.A.T.M.A.N. V ELP packet on an interface
+ 	 * that does not have B.A.T.M.A.N. V ELP enabled ?
+ 	 */
+ 	if (strcmp(bat_priv->algo_ops->name, "BATMAN_V") != 0)
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	elp_packet = (struct batadv_elp_packet *)skb->data;
+ 
+@@ -516,14 +517,19 @@ int batadv_v_elp_packet_recv(struct sk_buff *skb,
+ 
+ 	primary_if = batadv_primary_if_get_selected(bat_priv);
+ 	if (!primary_if)
+-		goto out;
++		goto free_skb;
+ 
+ 	batadv_v_elp_neigh_update(bat_priv, ethhdr->h_source, if_incoming,
+ 				  elp_packet);
+ 
+-out:
+-	if (primary_if)
+-		batadv_hardif_put(primary_if);
+-	consume_skb(skb);
+-	return NET_RX_SUCCESS;
++	ret = NET_RX_SUCCESS;
++	batadv_hardif_put(primary_if);
++
++free_skb:
++	if (ret == NET_RX_SUCCESS)
++		consume_skb(skb);
++	else
++		kfree_skb(skb);
++
++	return ret;
+ }
+diff --git a/net/batman-adv/bat_v_ogm.c b/net/batman-adv/bat_v_ogm.c
+index 9922ccd..38b9aab 100644
+--- a/net/batman-adv/bat_v_ogm.c
++++ b/net/batman-adv/bat_v_ogm.c
+@@ -810,18 +810,18 @@ int batadv_v_ogm_packet_recv(struct sk_buff *skb,
+ 	 * B.A.T.M.A.N. V enabled ?
+ 	 */
+ 	if (strcmp(bat_priv->algo_ops->name, "BATMAN_V") != 0)
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	if (!batadv_check_management_packet(skb, if_incoming, BATADV_OGM2_HLEN))
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	if (batadv_is_my_mac(bat_priv, ethhdr->h_source))
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	ogm_packet = (struct batadv_ogm2_packet *)skb->data;
+ 
+ 	if (batadv_is_my_mac(bat_priv, ogm_packet->orig))
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	batadv_inc_counter(bat_priv, BATADV_CNT_MGMT_RX);
+ 	batadv_add_counter(bat_priv, BATADV_CNT_MGMT_RX_BYTES,
+@@ -842,7 +842,12 @@ int batadv_v_ogm_packet_recv(struct sk_buff *skb,
+ 	}
+ 
+ 	ret = NET_RX_SUCCESS;
+-	consume_skb(skb);
++
++free_skb:
++	if (ret == NET_RX_SUCCESS)
++		consume_skb(skb);
++	else
++		kfree_skb(skb);
+ 
+ 	return ret;
+ }
+diff --git a/net/batman-adv/main.c b/net/batman-adv/main.c
+index 5e4e818..6b5dae6 100644
+--- a/net/batman-adv/main.c
++++ b/net/batman-adv/main.c
+@@ -402,6 +402,8 @@ void batadv_skb_set_priority(struct sk_buff *skb, int offset)
+ static int batadv_recv_unhandled_packet(struct sk_buff *skb,
+ 					struct batadv_hard_iface *recv_if)
+ {
++	kfree_skb(skb);
++
+ 	return NET_RX_DROP;
+ }
+ 
+@@ -416,7 +418,6 @@ int batadv_batman_skb_recv(struct sk_buff *skb, struct net_device *dev,
+ 	struct batadv_ogm_packet *batadv_ogm_packet;
+ 	struct batadv_hard_iface *hard_iface;
+ 	u8 idx;
+-	int ret;
+ 
+ 	hard_iface = container_of(ptype, struct batadv_hard_iface,
+ 				  batman_adv_ptype);
+@@ -466,14 +467,8 @@ int batadv_batman_skb_recv(struct sk_buff *skb, struct net_device *dev,
+ 	/* reset control block to avoid left overs from previous users */
+ 	memset(skb->cb, 0, sizeof(struct batadv_skb_cb));
+ 
+-	/* all receive handlers return whether they received or reused
+-	 * the supplied skb. if not, we have to free the skb.
+-	 */
+ 	idx = batadv_ogm_packet->packet_type;
+-	ret = (*batadv_rx_handler[idx])(skb, hard_iface);
+-
+-	if (ret == NET_RX_DROP)
+-		kfree_skb(skb);
++	(*batadv_rx_handler[idx])(skb, hard_iface);
+ 
+ 	batadv_hardif_put(hard_iface);
+ 
+diff --git a/net/batman-adv/network-coding.c b/net/batman-adv/network-coding.c
+index 3af66d3..ab5a3bf 100644
+--- a/net/batman-adv/network-coding.c
++++ b/net/batman-adv/network-coding.c
+@@ -1819,11 +1819,11 @@ static int batadv_nc_recv_coded_packet(struct sk_buff *skb,
+ 
+ 	/* Check if network coding is enabled */
+ 	if (!atomic_read(&bat_priv->network_coding))
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	/* Make sure we can access (and remove) header */
+ 	if (unlikely(!pskb_may_pull(skb, hdr_size)))
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	coded_packet = (struct batadv_coded_packet *)skb->data;
+ 	ethhdr = eth_hdr(skb);
+@@ -1831,7 +1831,7 @@ static int batadv_nc_recv_coded_packet(struct sk_buff *skb,
+ 	/* Verify frame is destined for us */
+ 	if (!batadv_is_my_mac(bat_priv, ethhdr->h_dest) &&
+ 	    !batadv_is_my_mac(bat_priv, coded_packet->second_dest))
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	/* Update stat counter */
+ 	if (batadv_is_my_mac(bat_priv, coded_packet->second_dest))
+@@ -1841,7 +1841,7 @@ static int batadv_nc_recv_coded_packet(struct sk_buff *skb,
+ 						   coded_packet);
+ 	if (!nc_packet) {
+ 		batadv_inc_counter(bat_priv, BATADV_CNT_NC_DECODE_FAILED);
+-		return NET_RX_DROP;
++		goto free_skb;
+ 	}
+ 
+ 	/* Make skb's linear, because decoding accesses the entire buffer */
+@@ -1867,6 +1867,9 @@ static int batadv_nc_recv_coded_packet(struct sk_buff *skb,
+ 
+ free_nc_packet:
+ 	batadv_nc_packet_free(nc_packet, true);
++free_skb:
++	kfree_skb(skb);
++
+ 	return NET_RX_DROP;
+ }
+ 
+diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c
+index 4d2679a..105d4fc 100644
+--- a/net/batman-adv/routing.c
++++ b/net/batman-adv/routing.c
+@@ -262,8 +262,11 @@ static int batadv_recv_my_icmp_packet(struct batadv_priv *bat_priv,
+ 		icmph->ttl = BATADV_TTL;
+ 
+ 		res = batadv_send_skb_to_orig(skb, orig_node, NULL);
+-		ret = NET_RX_SUCCESS;
++		if (res == NET_XMIT_SUCCESS)
++			ret = NET_RX_SUCCESS;
+ 
++		/* skb was consumed */
++		skb = NULL;
+ 		break;
+ 	case BATADV_TP:
+ 		if (!pskb_may_pull(skb, sizeof(struct batadv_icmp_tp_packet)))
+@@ -271,6 +274,8 @@ static int batadv_recv_my_icmp_packet(struct batadv_priv *bat_priv,
+ 
+ 		batadv_tp_meter_recv(bat_priv, skb);
+ 		ret = NET_RX_SUCCESS;
++		/* skb was consumed */
++		skb = NULL;
+ 		goto out;
+ 	default:
+ 		/* drop unknown type */
+@@ -281,6 +286,9 @@ out:
+ 		batadv_hardif_put(primary_if);
+ 	if (orig_node)
+ 		batadv_orig_node_put(orig_node);
++
++	kfree_skb(skb);
++
+ 	return ret;
+ }
+ 
+@@ -322,13 +330,20 @@ static int batadv_recv_icmp_ttl_exceeded(struct batadv_priv *bat_priv,
+ 	icmp_packet->ttl = BATADV_TTL;
+ 
+ 	res = batadv_send_skb_to_orig(skb, orig_node, NULL);
+-	ret = NET_RX_SUCCESS;
++	if (res == NET_RX_SUCCESS)
++		ret = NET_XMIT_SUCCESS;
++
++	/* skb was consumed */
++	skb = NULL;
+ 
+ out:
+ 	if (primary_if)
+ 		batadv_hardif_put(primary_if);
+ 	if (orig_node)
+ 		batadv_orig_node_put(orig_node);
++
++	kfree_skb(skb);
++
+ 	return ret;
+ }
+ 
+@@ -345,21 +360,21 @@ int batadv_recv_icmp_packet(struct sk_buff *skb,
+ 
+ 	/* drop packet if it has not necessary minimum size */
+ 	if (unlikely(!pskb_may_pull(skb, hdr_size)))
+-		goto out;
++		goto free_skb;
+ 
+ 	ethhdr = eth_hdr(skb);
+ 
+ 	/* packet with unicast indication but broadcast recipient */
+ 	if (is_broadcast_ether_addr(ethhdr->h_dest))
+-		goto out;
++		goto free_skb;
+ 
+ 	/* packet with broadcast sender address */
+ 	if (is_broadcast_ether_addr(ethhdr->h_source))
+-		goto out;
++		goto free_skb;
+ 
+ 	/* not for me */
+ 	if (!batadv_is_my_mac(bat_priv, ethhdr->h_dest))
+-		goto out;
++		goto free_skb;
+ 
+ 	icmph = (struct batadv_icmp_header *)skb->data;
+ 
+@@ -368,17 +383,17 @@ int batadv_recv_icmp_packet(struct sk_buff *skb,
+ 	     icmph->msg_type == BATADV_ECHO_REQUEST) &&
+ 	    (skb->len >= sizeof(struct batadv_icmp_packet_rr))) {
+ 		if (skb_linearize(skb) < 0)
+-			goto out;
++			goto free_skb;
+ 
+ 		/* create a copy of the skb, if needed, to modify it. */
+ 		if (skb_cow(skb, ETH_HLEN) < 0)
+-			goto out;
++			goto free_skb;
+ 
+ 		ethhdr = eth_hdr(skb);
+ 		icmph = (struct batadv_icmp_header *)skb->data;
+ 		icmp_packet_rr = (struct batadv_icmp_packet_rr *)icmph;
+ 		if (icmp_packet_rr->rr_cur >= BATADV_RR_LEN)
+-			goto out;
++			goto free_skb;
+ 
+ 		ether_addr_copy(icmp_packet_rr->rr[icmp_packet_rr->rr_cur],
+ 				ethhdr->h_dest);
+@@ -396,11 +411,11 @@ int batadv_recv_icmp_packet(struct sk_buff *skb,
+ 	/* get routing information */
+ 	orig_node = batadv_orig_hash_find(bat_priv, icmph->dst);
+ 	if (!orig_node)
+-		goto out;
++		goto free_skb;
+ 
+ 	/* create a copy of the skb, if needed, to modify it. */
+ 	if (skb_cow(skb, ETH_HLEN) < 0)
+-		goto out;
++		goto put_orig_node;
+ 
+ 	icmph = (struct batadv_icmp_header *)skb->data;
+ 
+@@ -409,11 +424,18 @@ int batadv_recv_icmp_packet(struct sk_buff *skb,
+ 
+ 	/* route it */
+ 	res = batadv_send_skb_to_orig(skb, orig_node, recv_if);
+-	ret = NET_RX_SUCCESS;
++	if (res == NET_XMIT_SUCCESS)
++		ret = NET_RX_SUCCESS;
+ 
+-out:
++	/* skb was consumed */
++	skb = NULL;
++
++put_orig_node:
+ 	if (orig_node)
+ 		batadv_orig_node_put(orig_node);
++free_skb:
++	kfree_skb(skb);
++
+ 	return ret;
+ }
+ 
+@@ -662,18 +684,18 @@ static int batadv_route_unicast_packet(struct sk_buff *skb,
+ 	if (unicast_packet->ttl < 2) {
+ 		pr_debug("Warning - can't forward unicast packet from %pM to %pM: ttl exceeded\n",
+ 			 ethhdr->h_source, unicast_packet->dest);
+-		goto out;
++		goto free_skb;
+ 	}
+ 
+ 	/* get routing information */
+ 	orig_node = batadv_orig_hash_find(bat_priv, unicast_packet->dest);
+ 
+ 	if (!orig_node)
+-		goto out;
++		goto free_skb;
+ 
+ 	/* create a copy of the skb, if needed, to modify it. */
+ 	if (skb_cow(skb, ETH_HLEN) < 0)
+-		goto out;
++		goto put_orig_node;
+ 
+ 	/* decrement ttl */
+ 	unicast_packet = (struct batadv_unicast_packet *)skb->data;
+@@ -697,6 +719,11 @@ static int batadv_route_unicast_packet(struct sk_buff *skb,
+ 
+ 	len = skb->len;
+ 	res = batadv_send_skb_to_orig(skb, orig_node, recv_if);
++	if (res == NET_XMIT_SUCCESS)
++		ret = NET_RX_SUCCESS;
++
++	/* skb was consumed */
++	skb = NULL;
+ 
+ 	/* translate transmit result into receive result */
+ 	if (res == NET_XMIT_SUCCESS) {
+@@ -706,11 +733,11 @@ static int batadv_route_unicast_packet(struct sk_buff *skb,
+ 				   len + ETH_HLEN);
+ 	}
+ 
+-	ret = NET_RX_SUCCESS;
++put_orig_node:
++	batadv_orig_node_put(orig_node);
++free_skb:
++	kfree_skb(skb);
+ 
+-out:
+-	if (orig_node)
+-		batadv_orig_node_put(orig_node);
+ 	return ret;
+ }
+ 
+@@ -895,14 +922,18 @@ int batadv_recv_unhandled_unicast_packet(struct sk_buff *skb,
+ 
+ 	check = batadv_check_unicast_packet(bat_priv, skb, hdr_size);
+ 	if (check < 0)
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	/* we don't know about this type, drop it. */
+ 	unicast_packet = (struct batadv_unicast_packet *)skb->data;
+ 	if (batadv_is_my_mac(bat_priv, unicast_packet->dest))
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	return batadv_route_unicast_packet(skb, recv_if);
++
++free_skb:
++	kfree_skb(skb);
++	return NET_RX_DROP;
+ }
+ 
+ int batadv_recv_unicast_packet(struct sk_buff *skb,
+@@ -916,6 +947,7 @@ int batadv_recv_unicast_packet(struct sk_buff *skb,
+ 	int check, hdr_size = sizeof(*unicast_packet);
+ 	enum batadv_subtype subtype;
+ 	bool is4addr;
++	int ret = NET_RX_DROP;
+ 
+ 	unicast_packet = (struct batadv_unicast_packet *)skb->data;
+ 	unicast_4addr_packet = (struct batadv_unicast_4addr_packet *)skb->data;
+@@ -935,9 +967,9 @@ int batadv_recv_unicast_packet(struct sk_buff *skb,
+ 		batadv_nc_skb_store_sniffed_unicast(bat_priv, skb);
+ 
+ 	if (check < 0)
+-		return NET_RX_DROP;
++		goto free_skb;
+ 	if (!batadv_check_unicast_ttvn(bat_priv, skb, hdr_size))
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	/* packet for me */
+ 	if (batadv_is_my_mac(bat_priv, unicast_packet->dest)) {
+@@ -975,7 +1007,14 @@ rx_success:
+ 		return NET_RX_SUCCESS;
+ 	}
+ 
+-	return batadv_route_unicast_packet(skb, recv_if);
++	ret = batadv_route_unicast_packet(skb, recv_if);
++	/* skb was consumed */
++	skb = NULL;
++
++free_skb:
++	kfree_skb(skb);
++
++	return ret;
+ }
+ 
+ /**
+@@ -997,15 +1036,15 @@ int batadv_recv_unicast_tvlv(struct sk_buff *skb,
+ 	int ret = NET_RX_DROP;
+ 
+ 	if (batadv_check_unicast_packet(bat_priv, skb, hdr_size) < 0)
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	/* the header is likely to be modified while forwarding */
+ 	if (skb_cow(skb, hdr_size) < 0)
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	/* packet needs to be linearized to access the tvlv content */
+ 	if (skb_linearize(skb) < 0)
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	unicast_tvlv_packet = (struct batadv_unicast_tvlv_packet *)skb->data;
+ 
+@@ -1013,17 +1052,21 @@ int batadv_recv_unicast_tvlv(struct sk_buff *skb,
+ 	tvlv_buff_len = ntohs(unicast_tvlv_packet->tvlv_len);
+ 
+ 	if (tvlv_buff_len > skb->len - hdr_size)
+-		return NET_RX_DROP;
++		goto free_skb;
+ 
+ 	ret = batadv_tvlv_containers_process(bat_priv, false, NULL,
+ 					     unicast_tvlv_packet->src,
+ 					     unicast_tvlv_packet->dst,
+ 					     tvlv_buff, tvlv_buff_len);
+ 
+-	if (ret != NET_RX_SUCCESS)
++	if (ret != NET_RX_SUCCESS) {
+ 		ret = batadv_route_unicast_packet(skb, recv_if);
+-	else
+-		consume_skb(skb);
++		/* skb was consumed */
++		skb = NULL;
++	}
++
++free_skb:
++	kfree_skb(skb);
+ 
+ 	return ret;
+ }
+@@ -1049,20 +1092,22 @@ int batadv_recv_frag_packet(struct sk_buff *skb,
+ 
+ 	if (batadv_check_unicast_packet(bat_priv, skb,
+ 					sizeof(*frag_packet)) < 0)
+-		goto out;
++		goto free_skb;
+ 
+ 	frag_packet = (struct batadv_frag_packet *)skb->data;
+ 	orig_node_src = batadv_orig_hash_find(bat_priv, frag_packet->orig);
+ 	if (!orig_node_src)
+-		goto out;
++		goto free_skb;
+ 
+ 	skb->priority = frag_packet->priority + 256;
+ 
+ 	/* Route the fragment if it is not for us and too big to be merged. */
+ 	if (!batadv_is_my_mac(bat_priv, frag_packet->dest) &&
+ 	    batadv_frag_skb_fwd(skb, recv_if, orig_node_src)) {
++		/* skb was consumed */
++		skb = NULL;
+ 		ret = NET_RX_SUCCESS;
+-		goto out;
++		goto put_orig_node;
+ 	}
+ 
+ 	batadv_inc_counter(bat_priv, BATADV_CNT_FRAG_RX);
+@@ -1070,20 +1115,24 @@ int batadv_recv_frag_packet(struct sk_buff *skb,
+ 
+ 	/* Add fragment to buffer and merge if possible. */
+ 	if (!batadv_frag_skb_buffer(&skb, orig_node_src))
+-		goto out;
++		goto put_orig_node;
+ 
+ 	/* Deliver merged packet to the appropriate handler, if it was
+ 	 * merged
+ 	 */
+-	if (skb)
++	if (skb) {
+ 		batadv_batman_skb_recv(skb, recv_if->net_dev,
+ 				       &recv_if->batman_adv_ptype, NULL);
++		/* skb was consumed */
++		skb = NULL;
++	}
+ 
+ 	ret = NET_RX_SUCCESS;
+ 
+-out:
+-	if (orig_node_src)
+-		batadv_orig_node_put(orig_node_src);
++put_orig_node:
++	batadv_orig_node_put(orig_node_src);
++free_skb:
++	kfree_skb(skb);
+ 
+ 	return ret;
+ }
+@@ -1102,35 +1151,35 @@ int batadv_recv_bcast_packet(struct sk_buff *skb,
+ 
+ 	/* drop packet if it has not necessary minimum size */
+ 	if (unlikely(!pskb_may_pull(skb, hdr_size)))
+-		goto out;
++		goto free_skb;
+ 
+ 	ethhdr = eth_hdr(skb);
+ 
+ 	/* packet with broadcast indication but unicast recipient */
+ 	if (!is_broadcast_ether_addr(ethhdr->h_dest))
+-		goto out;
++		goto free_skb;
+ 
+ 	/* packet with broadcast sender address */
+ 	if (is_broadcast_ether_addr(ethhdr->h_source))
+-		goto out;
++		goto free_skb;
+ 
+ 	/* ignore broadcasts sent by myself */
+ 	if (batadv_is_my_mac(bat_priv, ethhdr->h_source))
+-		goto out;
++		goto free_skb;
+ 
+ 	bcast_packet = (struct batadv_bcast_packet *)skb->data;
+ 
+ 	/* ignore broadcasts originated by myself */
+ 	if (batadv_is_my_mac(bat_priv, bcast_packet->orig))
+-		goto out;
++		goto free_skb;
+ 
+ 	if (bcast_packet->ttl < 2)
+-		goto out;
++		goto free_skb;
+ 
+ 	orig_node = batadv_orig_hash_find(bat_priv, bcast_packet->orig);
+ 
+ 	if (!orig_node)
+-		goto out;
++		goto free_skb;
+ 
+ 	spin_lock_bh(&orig_node->bcast_seqno_lock);
+ 
+@@ -1158,7 +1207,7 @@ int batadv_recv_bcast_packet(struct sk_buff *skb,
+ 
+ 	/* check whether this has been sent by another originator before */
+ 	if (batadv_bla_check_bcast_duplist(bat_priv, skb))
+-		goto out;
++		goto free_skb;
+ 
+ 	batadv_skb_set_priority(skb, sizeof(struct batadv_bcast_packet));
+ 
+@@ -1169,7 +1218,7 @@ int batadv_recv_bcast_packet(struct sk_buff *skb,
+ 	 * from the same backbone.
+ 	 */
+ 	if (batadv_bla_is_backbone_gw(skb, orig_node, hdr_size))
+-		goto out;
++		goto free_skb;
+ 
+ 	if (batadv_dat_snoop_incoming_arp_request(bat_priv, skb, hdr_size))
+ 		goto rx_success;
+@@ -1185,6 +1234,8 @@ rx_success:
+ 
+ spin_unlock:
+ 	spin_unlock_bh(&orig_node->bcast_seqno_lock);
++free_skb:
++	kfree_skb(skb);
+ out:
+ 	if (orig_node)
+ 		batadv_orig_node_put(orig_node);
diff --git a/batman-adv/patches/0036-batman-adv-Remove-dev_queue_xmit-return-code-excepti.patch b/batman-adv/patches/0036-batman-adv-Remove-dev_queue_xmit-return-code-excepti.patch
new file mode 100644
index 0000000..d020389
--- /dev/null
+++ b/batman-adv/patches/0036-batman-adv-Remove-dev_queue_xmit-return-code-excepti.patch
@@ -0,0 +1,58 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 17 Jul 2016 21:04:05 +0200
+Subject: [PATCH] batman-adv: Remove dev_queue_xmit return code exception
+
+No caller of batadv_send_skb_to_orig is expecting the results to be -1
+(-EPERM) anymore when the skbuff was not consumed. They will instead expect
+that the skbuff is always consumed. Having such return code filter is
+therefore not needed anymore.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/send.c | 17 ++++++-----------
+ 1 file changed, 6 insertions(+), 11 deletions(-)
+
+diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
+index b00aac7..9ea272e 100644
+--- a/net/batman-adv/send.c
++++ b/net/batman-adv/send.c
+@@ -64,8 +64,11 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work);
+  * If neigh_node is NULL, then the packet is broadcasted using hard_iface,
+  * otherwise it is sent as unicast to the given neighbor.
+  *
+- * Return: NET_TX_DROP in case of error or the result of dev_queue_xmit(skb)
+- * otherwise
++ * Regardless of the return value, the skb is consumed.
++ *
++ * Return: A negative errno code is returned on a failure. A success does not
++ * guarantee the frame will be transmitted as it may be dropped due
++ * to congestion or traffic shaping.
+  */
+ int batadv_send_skb_packet(struct sk_buff *skb,
+ 			   struct batadv_hard_iface *hard_iface,
+@@ -73,7 +76,6 @@ int batadv_send_skb_packet(struct sk_buff *skb,
+ {
+ 	struct batadv_priv *bat_priv;
+ 	struct ethhdr *ethhdr;
+-	int ret;
+ 
+ 	bat_priv = netdev_priv(hard_iface->soft_iface);
+ 
+@@ -111,15 +113,8 @@ int batadv_send_skb_packet(struct sk_buff *skb,
+ 	/* dev_queue_xmit() returns a negative result on error.	 However on
+ 	 * congestion and traffic shaping, it drops and returns NET_XMIT_DROP
+ 	 * (which is > 0). This will not be treated as an error.
+-	 *
+-	 * a negative value cannot be returned because it could be interepreted
+-	 * as not consumed skb by callers of batadv_send_skb_to_orig.
+ 	 */
+-	ret = dev_queue_xmit(skb);
+-	if (ret < 0)
+-		ret = NET_XMIT_DROP;
+-
+-	return ret;
++	return dev_queue_xmit(skb);
+ send_skb_err:
+ 	kfree_skb(skb);
+ 	return NET_XMIT_DROP;
diff --git a/batman-adv/patches/0037-batman-adv-Disallow-mcast-src-address-for-data-frame.patch b/batman-adv/patches/0037-batman-adv-Disallow-mcast-src-address-for-data-frame.patch
new file mode 100644
index 0000000..0f1ae1c
--- /dev/null
+++ b/batman-adv/patches/0037-batman-adv-Disallow-mcast-src-address-for-data-frame.patch
@@ -0,0 +1,52 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 6 Aug 2016 17:04:21 +0200
+Subject: [PATCH] batman-adv: Disallow mcast src address for data frames
+
+The routing checks are validating the source mac address of the outer
+ethernet header. They reject every source mac address which is a broadcast
+address. But they also have to reject any multicast mac addresses.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+[sw@simonwunderlich.de: fix commit message typo]
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/routing.c | 12 ++++++------
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c
+index 105d4fc..c02897b 100644
+--- a/net/batman-adv/routing.c
++++ b/net/batman-adv/routing.c
+@@ -368,8 +368,8 @@ int batadv_recv_icmp_packet(struct sk_buff *skb,
+ 	if (is_broadcast_ether_addr(ethhdr->h_dest))
+ 		goto free_skb;
+ 
+-	/* packet with broadcast sender address */
+-	if (is_broadcast_ether_addr(ethhdr->h_source))
++	/* packet with broadcast/multicast sender address */
++	if (is_multicast_ether_addr(ethhdr->h_source))
+ 		goto free_skb;
+ 
+ 	/* not for me */
+@@ -466,8 +466,8 @@ static int batadv_check_unicast_packet(struct batadv_priv *bat_priv,
+ 	if (is_broadcast_ether_addr(ethhdr->h_dest))
+ 		return -EBADR;
+ 
+-	/* packet with broadcast sender address */
+-	if (is_broadcast_ether_addr(ethhdr->h_source))
++	/* packet with broadcast/multicast sender address */
++	if (is_multicast_ether_addr(ethhdr->h_source))
+ 		return -EBADR;
+ 
+ 	/* not for me */
+@@ -1159,8 +1159,8 @@ int batadv_recv_bcast_packet(struct sk_buff *skb,
+ 	if (!is_broadcast_ether_addr(ethhdr->h_dest))
+ 		goto free_skb;
+ 
+-	/* packet with broadcast sender address */
+-	if (is_broadcast_ether_addr(ethhdr->h_source))
++	/* packet with broadcast/multicast sender address */
++	if (is_multicast_ether_addr(ethhdr->h_source))
+ 		goto free_skb;
+ 
+ 	/* ignore broadcasts sent by myself */
diff --git a/batman-adv/patches/0038-batman-adv-Disallow-zero-and-mcast-src-address-for-m.patch b/batman-adv/patches/0038-batman-adv-Disallow-zero-and-mcast-src-address-for-m.patch
new file mode 100644
index 0000000..ee9f6ba
--- /dev/null
+++ b/batman-adv/patches/0038-batman-adv-Disallow-zero-and-mcast-src-address-for-m.patch
@@ -0,0 +1,30 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 6 Aug 2016 17:04:22 +0200
+Subject: [PATCH] batman-adv: Disallow zero and mcast src address for mgmt frames
+
+The routing check for management frames is validating the source mac
+address in the outer ethernet header. It rejects every source mac address
+which is a broadcast address. But it also has to reject the zero-mac
+address and multicast mac addresses.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/routing.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c
+index c02897b..4f034df 100644
+--- a/net/batman-adv/routing.c
++++ b/net/batman-adv/routing.c
+@@ -196,8 +196,8 @@ bool batadv_check_management_packet(struct sk_buff *skb,
+ 	if (!is_broadcast_ether_addr(ethhdr->h_dest))
+ 		return false;
+ 
+-	/* packet with broadcast sender address */
+-	if (is_broadcast_ether_addr(ethhdr->h_source))
++	/* packet with invalid sender address */
++	if (!is_valid_ether_addr(ethhdr->h_source))
+ 		return false;
+ 
+ 	/* create a copy of the skb, if needed, to modify it. */
diff --git a/batman-adv/patches/0039-batman-adv-Reject-unicast-packet-with-zero-mcast-dst.patch b/batman-adv/patches/0039-batman-adv-Reject-unicast-packet-with-zero-mcast-dst.patch
new file mode 100644
index 0000000..469badf
--- /dev/null
+++ b/batman-adv/patches/0039-batman-adv-Reject-unicast-packet-with-zero-mcast-dst.patch
@@ -0,0 +1,40 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 6 Aug 2016 17:04:23 +0200
+Subject: [PATCH] batman-adv: Reject unicast packet with zero/mcast dst address
+
+An unicast batman-adv packet cannot be transmitted to a multicast or zero
+mac address. So reject incoming packets which still have these classes of
+addresses as destination mac address in the outer ethernet header.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/routing.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c
+index 4f034df..6713bdf 100644
+--- a/net/batman-adv/routing.c
++++ b/net/batman-adv/routing.c
+@@ -364,8 +364,8 @@ int batadv_recv_icmp_packet(struct sk_buff *skb,
+ 
+ 	ethhdr = eth_hdr(skb);
+ 
+-	/* packet with unicast indication but broadcast recipient */
+-	if (is_broadcast_ether_addr(ethhdr->h_dest))
++	/* packet with unicast indication but non-unicast recipient */
++	if (!is_valid_ether_addr(ethhdr->h_dest))
+ 		goto free_skb;
+ 
+ 	/* packet with broadcast/multicast sender address */
+@@ -462,8 +462,8 @@ static int batadv_check_unicast_packet(struct batadv_priv *bat_priv,
+ 
+ 	ethhdr = eth_hdr(skb);
+ 
+-	/* packet with unicast indication but broadcast recipient */
+-	if (is_broadcast_ether_addr(ethhdr->h_dest))
++	/* packet with unicast indication but non-unicast recipient */
++	if (!is_valid_ether_addr(ethhdr->h_dest))
+ 		return -EBADR;
+ 
+ 	/* packet with broadcast/multicast sender address */
diff --git a/batman-adv/patches/0040-batman-adv-Return-non-const-ptr-in-batadv_getlink_ne.patch b/batman-adv/patches/0040-batman-adv-Return-non-const-ptr-in-batadv_getlink_ne.patch
new file mode 100644
index 0000000..fc85143
--- /dev/null
+++ b/batman-adv/patches/0040-batman-adv-Return-non-const-ptr-in-batadv_getlink_ne.patch
@@ -0,0 +1,50 @@
+From: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Date: Fri, 30 Sep 2016 15:21:00 +0200
+Subject: [PATCH] batman-adv: Return non-const ptr in batadv_getlink_net
+
+The returned net_namespace of batadv_getlink_net may be used with functions
+that potentially modify the struct. Thus it must return the pointer as
+non-const like rtnl_link_ops::get_link_net does.
+
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/hard-interface.c | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index a7a462e..fdbb47e 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -92,8 +92,8 @@ out:
+  *
+  * Return: result of rtnl_link_ops->get_link_net or @fallback_net
+  */
+-static const struct net *batadv_getlink_net(const struct net_device *netdev,
+-					    const struct net *fallback_net)
++static struct net *batadv_getlink_net(const struct net_device *netdev,
++				      struct net *fallback_net)
+ {
+ 	if (!netdev->rtnl_link_ops)
+ 		return fallback_net;
+@@ -116,9 +116,9 @@ static const struct net *batadv_getlink_net(const struct net_device *netdev,
+  * Return: true if the devices are each others parent, otherwise false
+  */
+ static bool batadv_mutual_parents(const struct net_device *dev1,
+-				  const struct net *net1,
++				  struct net *net1,
+ 				  const struct net_device *dev2,
+-				  const struct net *net2)
++				  struct net *net2)
+ {
+ 	int dev1_parent_iflink = dev_get_iflink(dev1);
+ 	int dev2_parent_iflink = dev_get_iflink(dev2);
+@@ -154,7 +154,7 @@ static bool batadv_is_on_batman_iface(const struct net_device *net_dev)
+ {
+ 	struct net *net = dev_net(net_dev);
+ 	struct net_device *parent_dev;
+-	const struct net *parent_net;
++	struct net *parent_net;
+ 	bool ret;
+ 
+ 	/* check if this is a batman-adv mesh interface */
diff --git a/batman-adv/patches/0041-batman-adv-Close-two-alignment-holes-in-batadv_hard_.patch b/batman-adv/patches/0041-batman-adv-Close-two-alignment-holes-in-batadv_hard_.patch
new file mode 100644
index 0000000..e099818
--- /dev/null
+++ b/batman-adv/patches/0041-batman-adv-Close-two-alignment-holes-in-batadv_hard_.patch
@@ -0,0 +1,34 @@
+From: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Date: Fri, 30 Sep 2016 15:21:01 +0200
+Subject: [PATCH] batman-adv: Close two alignment holes in batadv_hard_iface
+
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/types.h | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 05cbf39..98ebac0 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -123,8 +123,8 @@ struct batadv_hard_iface_bat_v {
+  * @list: list node for batadv_hardif_list
+  * @if_num: identificator of the interface
+  * @if_status: status of the interface for batman-adv
+- * @net_dev: pointer to the net_device
+  * @num_bcasts: number of payload re-broadcasts on this interface (ARQ)
++ * @net_dev: pointer to the net_device
+  * @hardif_obj: kobject of the per interface sysfs "mesh" directory
+  * @refcount: number of contexts the object is used
+  * @batman_adv_ptype: packet type describing packets that should be processed by
+@@ -141,8 +141,8 @@ struct batadv_hard_iface {
+ 	struct list_head list;
+ 	s16 if_num;
+ 	char if_status;
+-	struct net_device *net_dev;
+ 	u8 num_bcasts;
++	struct net_device *net_dev;
+ 	struct kobject *hardif_obj;
+ 	struct kref refcount;
+ 	struct packet_type batman_adv_ptype;
diff --git a/batman-adv/patches/0042-batman-adv-refactor-wifi-interface-detection.patch b/batman-adv/patches/0042-batman-adv-refactor-wifi-interface-detection.patch
new file mode 100644
index 0000000..821414c
--- /dev/null
+++ b/batman-adv/patches/0042-batman-adv-refactor-wifi-interface-detection.patch
@@ -0,0 +1,114 @@
+From: Marek Lindner <mareklindner@neomailbox.ch>
+Date: Fri, 30 Sep 2016 15:21:02 +0200
+Subject: [PATCH] batman-adv: refactor wifi interface detection
+
+The ELP protocol requires cfg80211 to auto-detect the WiFi througput
+to a given neighbor. Use batadv_is_cfg80211_netdev() to determine
+whether or not an interface is eligible.
+
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/bat_v_elp.c      | 29 ++++++++++++++---------------
+ net/batman-adv/hard-interface.c | 26 +++++++++++++++++++++-----
+ net/batman-adv/hard-interface.h |  1 +
+ 3 files changed, 36 insertions(+), 20 deletions(-)
+
+diff --git a/net/batman-adv/bat_v_elp.c b/net/batman-adv/bat_v_elp.c
+index 54bdd41..e601def 100644
+--- a/net/batman-adv/bat_v_elp.c
++++ b/net/batman-adv/bat_v_elp.c
+@@ -90,22 +90,21 @@ static u32 batadv_v_elp_get_throughput(struct batadv_hardif_neigh_node *neigh)
+ 	 * cfg80211 API
+ 	 */
+ 	if (batadv_is_wifi_netdev(hard_iface->net_dev)) {
+-		if (hard_iface->net_dev->ieee80211_ptr) {
+-			ret = cfg80211_get_station(hard_iface->net_dev,
+-						   neigh->addr, &sinfo);
+-			if (ret == -ENOENT) {
+-				/* Node is not associated anymore! It would be
+-				 * possible to delete this neighbor. For now set
+-				 * the throughput metric to 0.
+-				 */
+-				return 0;
+-			}
+-			if (!ret)
+-				return sinfo.expected_throughput / 100;
+-		}
++		if (!batadv_is_cfg80211_netdev(hard_iface->net_dev))
++			/* unsupported WiFi driver version */
++			goto default_throughput;
+ 
+-		/* unsupported WiFi driver version */
+-		goto default_throughput;
++		ret = cfg80211_get_station(hard_iface->net_dev,
++					   neigh->addr, &sinfo);
++		if (ret == -ENOENT) {
++			/* Node is not associated anymore! It would be
++			 * possible to delete this neighbor. For now set
++			 * the throughput metric to 0.
++			 */
++			return 0;
++		}
++		if (!ret)
++			return sinfo.expected_throughput / 100;
+ 	}
+ 
+ 	/* if not a wifi interface, check if this device provides data via
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index fdbb47e..c3fbc1b 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -202,6 +202,26 @@ static bool batadv_is_valid_iface(const struct net_device *net_dev)
+ }
+ 
+ /**
++ * batadv_is_cfg80211_netdev - check if the given net_device struct is a
++ *  cfg80211 wifi interface
++ * @net_device: the device to check
++ *
++ * Return: true if the net device is a cfg80211 wireless device, false
++ *  otherwise.
++ */
++bool batadv_is_cfg80211_netdev(struct net_device *net_device)
++{
++	if (!net_device)
++		return false;
++
++	/* cfg80211 drivers have to set ieee80211_ptr */
++	if (net_device->ieee80211_ptr)
++		return true;
++
++	return false;
++}
++
++/**
+  * batadv_is_wifi_netdev - check if the given net_device struct is a wifi
+  *  interface
+  * @net_device: the device to check
+@@ -221,11 +241,7 @@ bool batadv_is_wifi_netdev(struct net_device *net_device)
+ 		return true;
+ #endif
+ 
+-	/* cfg80211 drivers have to set ieee80211_ptr */
+-	if (net_device->ieee80211_ptr)
+-		return true;
+-
+-	return false;
++	return batadv_is_cfg80211_netdev(net_device);
+ }
+ 
+ /**
+diff --git a/net/batman-adv/hard-interface.h b/net/batman-adv/hard-interface.h
+index a043182..7f9acab 100644
+--- a/net/batman-adv/hard-interface.h
++++ b/net/batman-adv/hard-interface.h
+@@ -65,6 +65,7 @@ enum batadv_hard_if_cleanup {
+ 
+ extern struct notifier_block batadv_hard_if_notifier;
+ 
++bool batadv_is_cfg80211_netdev(struct net_device *net_device);
+ bool batadv_is_wifi_netdev(struct net_device *net_device);
+ bool batadv_is_wifi_iface(int ifindex);
+ struct batadv_hard_iface*
diff --git a/batman-adv/patches/0043-batman-adv-Cache-the-type-of-wifi-device-for-each-ha.patch b/batman-adv/patches/0043-batman-adv-Cache-the-type-of-wifi-device-for-each-ha.patch
new file mode 100644
index 0000000..99365df
--- /dev/null
+++ b/batman-adv/patches/0043-batman-adv-Cache-the-type-of-wifi-device-for-each-ha.patch
@@ -0,0 +1,304 @@
+From: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Date: Fri, 30 Sep 2016 15:21:03 +0200
+Subject: [PATCH] batman-adv: Cache the type of wifi device for each hardif
+
+batman-adv is requiring the type of wifi device in different contexts. Some
+of them can take the rtnl semaphore and some of them already have the
+semaphore taken. But even others don't allow that the semaphore will be
+taken.
+
+The data has to be retrieved when the hardif is added to batman-adv because
+some of the wifi information for an hardif will only be available with rtnl
+lock. It can then be cached in the batadv_hard_iface and the functions
+is_wifi_netdev and is_cfg80211_netdev can just compare the correct bits
+without imposing extra locking requirements.
+
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/bat_iv_ogm.c        |   2 +-
+ net/batman-adv/bat_v_elp.c         |   8 +--
+ net/batman-adv/hard-interface.c    | 102 ++++++++++++++++++++++++++++---------
+ net/batman-adv/hard-interface.h    |   5 +-
+ net/batman-adv/translation-table.c |  10 +++-
+ net/batman-adv/types.h             |  13 +++++
+ 6 files changed, 105 insertions(+), 35 deletions(-)
+
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index bd39247..36d8818 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -1272,7 +1272,7 @@ static bool batadv_iv_ogm_calc_tq(struct batadv_orig_node *orig_node,
+ 	 */
+ 	tq_iface_penalty = BATADV_TQ_MAX_VALUE;
+ 	if (if_outgoing && (if_incoming == if_outgoing) &&
+-	    batadv_is_wifi_netdev(if_outgoing->net_dev))
++	    batadv_is_wifi_hardif(if_outgoing))
+ 		tq_iface_penalty = batadv_hop_penalty(BATADV_TQ_MAX_VALUE,
+ 						      bat_priv);
+ 
+diff --git a/net/batman-adv/bat_v_elp.c b/net/batman-adv/bat_v_elp.c
+index e601def..0d78689 100644
+--- a/net/batman-adv/bat_v_elp.c
++++ b/net/batman-adv/bat_v_elp.c
+@@ -89,8 +89,8 @@ static u32 batadv_v_elp_get_throughput(struct batadv_hardif_neigh_node *neigh)
+ 	/* if this is a wireless device, then ask its throughput through
+ 	 * cfg80211 API
+ 	 */
+-	if (batadv_is_wifi_netdev(hard_iface->net_dev)) {
+-		if (!batadv_is_cfg80211_netdev(hard_iface->net_dev))
++	if (batadv_is_wifi_hardif(hard_iface)) {
++		if (!batadv_is_cfg80211_hardif(hard_iface))
+ 			/* unsupported WiFi driver version */
+ 			goto default_throughput;
+ 
+@@ -186,7 +186,7 @@ batadv_v_elp_wifi_neigh_probe(struct batadv_hardif_neigh_node *neigh)
+ 	int elp_skb_len;
+ 
+ 	/* this probing routine is for Wifi neighbours only */
+-	if (!batadv_is_wifi_netdev(hard_iface->net_dev))
++	if (!batadv_is_wifi_hardif(hard_iface))
+ 		return true;
+ 
+ 	/* probe the neighbor only if no unicast packets have been sent
+@@ -351,7 +351,7 @@ int batadv_v_elp_iface_enable(struct batadv_hard_iface *hard_iface)
+ 	/* warn the user (again) if there is no throughput data is available */
+ 	hard_iface->bat_v.flags &= ~BATADV_WARNING_DEFAULT;
+ 
+-	if (batadv_is_wifi_netdev(hard_iface->net_dev))
++	if (batadv_is_wifi_hardif(hard_iface))
+ 		hard_iface->bat_v.flags &= ~BATADV_FULL_DUPLEX;
+ 
+ 	INIT_DELAYED_WORK(&hard_iface->bat_v.elp_wq,
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index c3fbc1b..57e8912 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -202,33 +202,14 @@ static bool batadv_is_valid_iface(const struct net_device *net_dev)
+ }
+ 
+ /**
+- * batadv_is_cfg80211_netdev - check if the given net_device struct is a
+- *  cfg80211 wifi interface
++ * batadv_is_wext_netdev - check if the given net_device struct is a
++ *  wext wifi interface
+  * @net_device: the device to check
+  *
+- * Return: true if the net device is a cfg80211 wireless device, false
++ * Return: true if the net device is a wext wireless device, false
+  *  otherwise.
+  */
+-bool batadv_is_cfg80211_netdev(struct net_device *net_device)
+-{
+-	if (!net_device)
+-		return false;
+-
+-	/* cfg80211 drivers have to set ieee80211_ptr */
+-	if (net_device->ieee80211_ptr)
+-		return true;
+-
+-	return false;
+-}
+-
+-/**
+- * batadv_is_wifi_netdev - check if the given net_device struct is a wifi
+- *  interface
+- * @net_device: the device to check
+- *
+- * Return: true if the net device is a 802.11 wireless device, false otherwise.
+- */
+-bool batadv_is_wifi_netdev(struct net_device *net_device)
++static bool batadv_is_wext_netdev(struct net_device *net_device)
+ {
+ 	if (!net_device)
+ 		return false;
+@@ -241,7 +222,77 @@ bool batadv_is_wifi_netdev(struct net_device *net_device)
+ 		return true;
+ #endif
+ 
+-	return batadv_is_cfg80211_netdev(net_device);
++	return false;
++}
++
++/**
++ * batadv_is_cfg80211_netdev - check if the given net_device struct is a
++ *  cfg80211 wifi interface
++ * @net_device: the device to check
++ *
++ * Return: true if the net device is a cfg80211 wireless device, false
++ *  otherwise.
++ */
++static bool batadv_is_cfg80211_netdev(struct net_device *net_device)
++{
++	if (!net_device)
++		return false;
++
++	/* cfg80211 drivers have to set ieee80211_ptr */
++	if (net_device->ieee80211_ptr)
++		return true;
++
++	return false;
++}
++
++/**
++ * batadv_wifi_flags_evaluate - calculate wifi flags for net_device
++ * @net_device: the device to check
++ *
++ * Return: batadv_hard_iface_wifi_flags flags of the device
++ */
++static u32 batadv_wifi_flags_evaluate(struct net_device *net_device)
++{
++	u32 wifi_flags = 0;
++
++	if (batadv_is_wext_netdev(net_device))
++		wifi_flags |= BATADV_HARDIF_WIFI_WEXT_DIRECT;
++
++	if (batadv_is_cfg80211_netdev(net_device))
++		wifi_flags |= BATADV_HARDIF_WIFI_CFG80211_DIRECT;
++
++	return wifi_flags;
++}
++
++/**
++ * batadv_is_cfg80211_hardif - check if the given hardif is a cfg80211 wifi
++ *  interface
++ * @hard_iface: the device to check
++ *
++ * Return: true if the net device is a cfg80211 wireless device, false
++ *  otherwise.
++ */
++bool batadv_is_cfg80211_hardif(struct batadv_hard_iface *hard_iface)
++{
++	u32 allowed_flags = 0;
++
++	allowed_flags |= BATADV_HARDIF_WIFI_CFG80211_DIRECT;
++
++	return !!(hard_iface->wifi_flags & allowed_flags);
++}
++
++/**
++ * batadv_is_wifi_hardif - check if the given hardif is a wifi interface
++ * @hard_iface: the device to check
++ *
++ * Return: true if the net device is a 802.11 wireless device, false otherwise.
++ */
++bool batadv_is_wifi_hardif(struct batadv_hard_iface *hard_iface)
++{
++	if (!hard_iface)
++		return false;
++
++	return hard_iface->wifi_flags != 0;
+ }
+ 
+ /**
+@@ -765,7 +816,8 @@ batadv_hardif_add_interface(struct net_device *net_dev)
+ 	kref_init(&hard_iface->refcount);
+ 
+ 	hard_iface->num_bcasts = BATADV_NUM_BCASTS_DEFAULT;
+-	if (batadv_is_wifi_netdev(net_dev))
++	hard_iface->wifi_flags = batadv_wifi_flags_evaluate(net_dev);
++	if (batadv_is_wifi_hardif(hard_iface))
+ 		hard_iface->num_bcasts = BATADV_NUM_BCASTS_WIRELESS;
+ 
+ 	batadv_v_hardif_init(hard_iface);
+diff --git a/net/batman-adv/hard-interface.h b/net/batman-adv/hard-interface.h
+index 7f9acab..7281dd2 100644
+--- a/net/batman-adv/hard-interface.h
++++ b/net/batman-adv/hard-interface.h
+@@ -65,9 +65,8 @@ enum batadv_hard_if_cleanup {
+ 
+ extern struct notifier_block batadv_hard_if_notifier;
+ 
+-bool batadv_is_cfg80211_netdev(struct net_device *net_device);
+-bool batadv_is_wifi_netdev(struct net_device *net_device);
+-bool batadv_is_wifi_iface(int ifindex);
++bool batadv_is_cfg80211_hardif(struct batadv_hard_iface *hard_iface);
++bool batadv_is_wifi_hardif(struct batadv_hard_iface *hard_iface);
+ struct batadv_hard_iface*
+ batadv_hardif_get_by_netdev(const struct net_device *net_dev);
+ int batadv_hardif_enable_interface(struct batadv_hard_iface *hard_iface,
+diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
+index f97d5a8..30ecbfb 100644
+--- a/net/batman-adv/translation-table.c
++++ b/net/batman-adv/translation-table.c
+@@ -646,6 +646,7 @@ bool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,
+ 	struct net *net = dev_net(soft_iface);
+ 	struct batadv_softif_vlan *vlan;
+ 	struct net_device *in_dev = NULL;
++	struct batadv_hard_iface *in_hardif = NULL;
+ 	struct hlist_head *head;
+ 	struct batadv_tt_orig_list_entry *orig_entry;
+ 	int hash_added, table_size, packet_size_max;
+@@ -657,6 +658,9 @@ bool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,
+ 	if (ifindex != BATADV_NULL_IFINDEX)
+ 		in_dev = dev_get_by_index(net, ifindex);
+ 
++	if (in_dev)
++		in_hardif = batadv_hardif_get_by_netdev(in_dev);
++
+ 	tt_local = batadv_tt_local_hash_find(bat_priv, addr, vid);
+ 
+ 	if (!is_multicast_ether_addr(addr))
+@@ -730,7 +734,7 @@ bool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,
+ 	 */
+ 	tt_local->common.flags = BATADV_TT_CLIENT_NEW;
+ 	tt_local->common.vid = vid;
+-	if (batadv_is_wifi_netdev(in_dev))
++	if (batadv_is_wifi_hardif(in_hardif))
+ 		tt_local->common.flags |= BATADV_TT_CLIENT_WIFI;
+ 	kref_init(&tt_local->common.refcount);
+ 	tt_local->last_seen = jiffies;
+@@ -790,7 +794,7 @@ check_roaming:
+ 	 */
+ 	remote_flags = tt_local->common.flags & BATADV_TT_REMOTE_MASK;
+ 
+-	if (batadv_is_wifi_netdev(in_dev))
++	if (batadv_is_wifi_hardif(in_hardif))
+ 		tt_local->common.flags |= BATADV_TT_CLIENT_WIFI;
+ 	else
+ 		tt_local->common.flags &= ~BATADV_TT_CLIENT_WIFI;
+@@ -814,6 +818,8 @@ check_roaming:
+ 
+ 	ret = true;
+ out:
++	if (in_hardif)
++		batadv_hardif_put(in_hardif);
+ 	if (in_dev)
+ 		dev_put(in_dev);
+ 	if (tt_local)
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 98ebac0..1bcce32 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -119,11 +119,23 @@ struct batadv_hard_iface_bat_v {
+ };
+ 
+ /**
++ * enum batadv_hard_iface_wifi_flags - Flags describing the wifi configuration
++ *  of a batadv_hard_iface
++ * @BATADV_HARDIF_WIFI_WEXT_DIRECT: it is a wext wifi device
++ * @BATADV_HARDIF_WIFI_CFG80211_DIRECT: it is a cfg80211 wifi device
++ */
++enum batadv_hard_iface_wifi_flags {
++	BATADV_HARDIF_WIFI_WEXT_DIRECT = BIT(0),
++	BATADV_HARDIF_WIFI_CFG80211_DIRECT = BIT(1),
++};
++
++/**
+  * struct batadv_hard_iface - network device known to batman-adv
+  * @list: list node for batadv_hardif_list
+  * @if_num: identificator of the interface
+  * @if_status: status of the interface for batman-adv
+  * @num_bcasts: number of payload re-broadcasts on this interface (ARQ)
++ * @wifi_flags: flags whether this is (directly or indirectly) a wifi interface
+  * @net_dev: pointer to the net_device
+  * @hardif_obj: kobject of the per interface sysfs "mesh" directory
+  * @refcount: number of contexts the object is used
+@@ -142,6 +154,7 @@ struct batadv_hard_iface {
+ 	s16 if_num;
+ 	char if_status;
+ 	u8 num_bcasts;
++	u32 wifi_flags;
+ 	struct net_device *net_dev;
+ 	struct kobject *hardif_obj;
+ 	struct kref refcount;
diff --git a/batman-adv/patches/0044-batman-adv-additional-checks-for-virtual-interfaces-.patch b/batman-adv/patches/0044-batman-adv-additional-checks-for-virtual-interfaces-.patch
new file mode 100644
index 0000000..e7246a3
--- /dev/null
+++ b/batman-adv/patches/0044-batman-adv-additional-checks-for-virtual-interfaces-.patch
@@ -0,0 +1,131 @@
+From: Marek Lindner <mareklindner@neomailbox.ch>
+Date: Fri, 30 Sep 2016 15:21:04 +0200
+Subject: [PATCH] batman-adv: additional checks for virtual interfaces on top of WiFi
+
+In a few situations batman-adv tries to determine whether a given interface
+is a WiFi interface to enable specific WiFi optimizations. If the interface
+batman-adv has been configured with is a virtual interface (e.g. VLAN) it
+would not be properly detected as WiFi interface and thus not benefit from
+the special WiFi treatment.
+This patch changes that by peeking under the hood whenever a virtual
+interface is in play.
+
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+[sven.eckelmann@open-mesh.com: integrate in wifi_flags caching, retrieve
+ namespace of link interface]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/hard-interface.c | 58 +++++++++++++++++++++++++++++++++++++++++
+ net/batman-adv/types.h          |  4 +++
+ 2 files changed, 62 insertions(+)
+
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index 57e8912..df31f2f 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -202,6 +202,47 @@ static bool batadv_is_valid_iface(const struct net_device *net_dev)
+ }
+ 
+ /**
++ * batadv_get_real_netdevice - check if the given netdev struct is a virtual
++ *  interface on top of another 'real' interface
++ * @netdev: the device to check
++ *
++ * Return: the 'real' net device or the original net device and NULL in case
++ *  of an error.
++ */
++static struct net_device *batadv_get_real_netdevice(struct net_device *netdev)
++{
++	struct batadv_hard_iface *hard_iface = NULL;
++	struct net_device *real_netdev = NULL;
++	struct net *real_net;
++	struct net *net;
++	int ifindex;
++
++	ASSERT_RTNL();
++
++	if (!netdev)
++		return NULL;
++
++	if (netdev->ifindex == dev_get_iflink(netdev)) {
++		dev_hold(netdev);
++		return netdev;
++	}
++
++	hard_iface = batadv_hardif_get_by_netdev(netdev);
++	if (!hard_iface || !hard_iface->soft_iface)
++		goto out;
++
++	net = dev_net(hard_iface->soft_iface);
++	ifindex = dev_get_iflink(netdev);
++	real_net = batadv_getlink_net(netdev, net);
++	real_netdev = dev_get_by_index(real_net, ifindex);
++
++out:
++	if (hard_iface)
++		batadv_hardif_put(hard_iface);
++	return real_netdev;
++}
++
++/**
+  * batadv_is_wext_netdev - check if the given net_device struct is a
+  *  wext wifi interface
+  * @net_device: the device to check
+@@ -254,6 +295,7 @@ static bool batadv_is_cfg80211_netdev(struct net_device *net_device)
+ static u32 batadv_wifi_flags_evaluate(struct net_device *net_device)
+ {
+ 	u32 wifi_flags = 0;
++	struct net_device *real_netdev;
+ 
+ 	if (batadv_is_wext_netdev(net_device))
+ 		wifi_flags |= BATADV_HARDIF_WIFI_WEXT_DIRECT;
+@@ -261,6 +303,21 @@ static u32 batadv_wifi_flags_evaluate(struct net_device *net_device)
+ 	if (batadv_is_cfg80211_netdev(net_device))
+ 		wifi_flags |= BATADV_HARDIF_WIFI_CFG80211_DIRECT;
+ 
++	real_netdev = batadv_get_real_netdevice(net_device);
++	if (!real_netdev)
++		return wifi_flags;
++
++	if (real_netdev == net_device)
++		goto out;
++
++	if (batadv_is_wext_netdev(real_netdev))
++		wifi_flags |= BATADV_HARDIF_WIFI_WEXT_INDIRECT;
++
++	if (batadv_is_cfg80211_netdev(real_netdev))
++		wifi_flags |= BATADV_HARDIF_WIFI_CFG80211_INDIRECT;
++
++out:
++	dev_put(real_netdev);
+ 	return wifi_flags;
+ }
+ 
+@@ -277,6 +334,7 @@ bool batadv_is_cfg80211_hardif(struct batadv_hard_iface *hard_iface)
+ 	u32 allowed_flags = 0;
+ 
+ 	allowed_flags |= BATADV_HARDIF_WIFI_CFG80211_DIRECT;
++	allowed_flags |= BATADV_HARDIF_WIFI_CFG80211_INDIRECT;
+ 
+ 	return !!(hard_iface->wifi_flags & allowed_flags);
+ }
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 1bcce32..caa00a5 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -123,10 +123,14 @@ struct batadv_hard_iface_bat_v {
+  *  of a batadv_hard_iface
+  * @BATADV_HARDIF_WIFI_WEXT_DIRECT: it is a wext wifi device
+  * @BATADV_HARDIF_WIFI_CFG80211_DIRECT: it is a cfg80211 wifi device
++ * @BATADV_HARDIF_WIFI_WEXT_INDIRECT: link device is a wext wifi device
++ * @BATADV_HARDIF_WIFI_CFG80211_INDIRECT: link device is a cfg80211 wifi device
+  */
+ enum batadv_hard_iface_wifi_flags {
+ 	BATADV_HARDIF_WIFI_WEXT_DIRECT = BIT(0),
+ 	BATADV_HARDIF_WIFI_CFG80211_DIRECT = BIT(1),
++	BATADV_HARDIF_WIFI_WEXT_INDIRECT = BIT(2),
++	BATADV_HARDIF_WIFI_CFG80211_INDIRECT = BIT(3),
+ };
+ 
+ /**
diff --git a/batman-adv/patches/0045-batman-adv-retrieve-B.A.T.M.A.N.-V-WiFi-neighbor-sta.patch b/batman-adv/patches/0045-batman-adv-retrieve-B.A.T.M.A.N.-V-WiFi-neighbor-sta.patch
new file mode 100644
index 0000000..d905539
--- /dev/null
+++ b/batman-adv/patches/0045-batman-adv-retrieve-B.A.T.M.A.N.-V-WiFi-neighbor-sta.patch
@@ -0,0 +1,95 @@
+From: Marek Lindner <mareklindner@neomailbox.ch>
+Date: Fri, 30 Sep 2016 15:21:05 +0200
+Subject: [PATCH] batman-adv: retrieve B.A.T.M.A.N. V WiFi neighbor stats from real interface
+
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+[sven.eckelmann@open-mesh.com: re-add batadv_get_real_netdev to take rtnl
+ semaphore for batadv_get_real_netdevice]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/bat_v_elp.c      | 10 ++++++++--
+ net/batman-adv/hard-interface.c | 22 ++++++++++++++++++++++
+ net/batman-adv/hard-interface.h |  1 +
+ 3 files changed, 31 insertions(+), 2 deletions(-)
+
+diff --git a/net/batman-adv/bat_v_elp.c b/net/batman-adv/bat_v_elp.c
+index 0d78689..f2fb2f0 100644
+--- a/net/batman-adv/bat_v_elp.c
++++ b/net/batman-adv/bat_v_elp.c
+@@ -75,6 +75,7 @@ static u32 batadv_v_elp_get_throughput(struct batadv_hardif_neigh_node *neigh)
+ {
+ 	struct batadv_hard_iface *hard_iface = neigh->if_incoming;
+ 	struct ethtool_link_ksettings link_settings;
++	struct net_device *real_netdev;
+ 	struct station_info sinfo;
+ 	u32 throughput;
+ 	int ret;
+@@ -94,8 +95,13 @@ static u32 batadv_v_elp_get_throughput(struct batadv_hardif_neigh_node *neigh)
+ 			/* unsupported WiFi driver version */
+ 			goto default_throughput;
+ 
+-		ret = cfg80211_get_station(hard_iface->net_dev,
+-					   neigh->addr, &sinfo);
++		real_netdev = batadv_get_real_netdev(hard_iface->net_dev);
++		if (!real_netdev)
++			goto default_throughput;
++
++		ret = cfg80211_get_station(real_netdev, neigh->addr, &sinfo);
++
++		dev_put(real_netdev);
+ 		if (ret == -ENOENT) {
+ 			/* Node is not associated anymore! It would be
+ 			 * possible to delete this neighbor. For now set
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index df31f2f..d0b632c 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -206,6 +206,9 @@ static bool batadv_is_valid_iface(const struct net_device *net_dev)
+  *  interface on top of another 'real' interface
+  * @netdev: the device to check
+  *
++ * Callers must hold the rtnl semaphore. You may want batadv_get_real_netdev()
++ * instead of this.
++ *
+  * Return: the 'real' net device or the original net device and NULL in case
+  *  of an error.
+  */
+@@ -243,6 +246,25 @@ out:
+ }
+ 
+ /**
++ * batadv_get_real_netdev - check if the given net_device struct is a virtual
++ *  interface on top of another 'real' interface
++ * @net_device: the device to check
++ *
++ * Return: the 'real' net device or the original net device and NULL in case
++ *  of an error.
++ */
++struct net_device *batadv_get_real_netdev(struct net_device *net_device)
++{
++	struct net_device *real_netdev = NULL;
++
++	rtnl_lock();
++	real_netdev = batadv_get_real_netdevice(net_device);
++	rtnl_unlock();
++
++	return real_netdev;
++}
++
++/**
+  * batadv_is_wext_netdev - check if the given net_device struct is a
+  *  wext wifi interface
+  * @net_device: the device to check
+diff --git a/net/batman-adv/hard-interface.h b/net/batman-adv/hard-interface.h
+index 7281dd2..d6309a4 100644
+--- a/net/batman-adv/hard-interface.h
++++ b/net/batman-adv/hard-interface.h
+@@ -65,6 +65,7 @@ enum batadv_hard_if_cleanup {
+ 
+ extern struct notifier_block batadv_hard_if_notifier;
+ 
++struct net_device *batadv_get_real_netdev(struct net_device *net_device);
+ bool batadv_is_cfg80211_hardif(struct batadv_hard_iface *hard_iface);
+ bool batadv_is_wifi_hardif(struct batadv_hard_iface *hard_iface);
+ struct batadv_hard_iface*
diff --git a/batman-adv/patches/0046-batman-adv-Update-wifi-flags-on-upper-link-change.patch b/batman-adv/patches/0046-batman-adv-Update-wifi-flags-on-upper-link-change.patch
new file mode 100644
index 0000000..36a81b8
--- /dev/null
+++ b/batman-adv/patches/0046-batman-adv-Update-wifi-flags-on-upper-link-change.patch
@@ -0,0 +1,44 @@
+From: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Date: Fri, 30 Sep 2016 15:21:06 +0200
+Subject: [PATCH] batman-adv: Update wifi flags on upper link change
+
+Things like VLANs don't have their link set when they are created. Thus
+the wifi flags have to be evaluated later to fix their contents for the
+link interface.
+
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ compat-include/linux/netdevice.h | 2 ++
+ net/batman-adv/hard-interface.c  | 5 +++++
+ 2 files changed, 7 insertions(+)
+
+diff --git a/compat-include/linux/netdevice.h b/compat-include/linux/netdevice.h
+index fb5b519..e71e614 100644
+--- a/compat-include/linux/netdevice.h
++++ b/compat-include/linux/netdevice.h
+@@ -43,6 +43,8 @@
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0)
+ 
++#define NETDEV_CHANGEUPPER	0x0015
++
+ #define netdev_notifier_info_to_dev(ptr) ptr
+ 
+ #endif /* < KERNEL_VERSION(3, 11, 0) */
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index d0b632c..d83e253 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -1006,6 +1006,11 @@ static int batadv_hard_if_event(struct notifier_block *this,
+ 		if (hard_iface == primary_if)
+ 			batadv_primary_if_update_addr(bat_priv, NULL);
+ 		break;
++	case NETDEV_CHANGEUPPER:
++		hard_iface->wifi_flags = batadv_wifi_flags_evaluate(net_dev);
++		if (batadv_is_wifi_hardif(hard_iface))
++			hard_iface->num_bcasts = BATADV_NUM_BCASTS_WIRELESS;
++		break;
+ 	default:
+ 		break;
+ 	}
diff --git a/batman-adv/patches/0047-batman-adv-Mark-batadv_netlink_ops-as-const.patch b/batman-adv/patches/0047-batman-adv-Mark-batadv_netlink_ops-as-const.patch
new file mode 100644
index 0000000..dde11ed
--- /dev/null
+++ b/batman-adv/patches/0047-batman-adv-Mark-batadv_netlink_ops-as-const.patch
@@ -0,0 +1,37 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Tue, 18 Oct 2016 15:57:36 +0200
+Subject: [PATCH] batman-adv: Mark batadv_netlink_ops as const
+
+The genl_ops don't need to be written by anyone and thus can be moved in a
+ro memory range.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ compat-patches/replacements.sh | 1 +
+ net/batman-adv/netlink.c       | 2 +-
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/compat-patches/replacements.sh b/compat-patches/replacements.sh
+index 669b0ff..7dcb953 100755
+--- a/compat-patches/replacements.sh
++++ b/compat-patches/replacements.sh
+@@ -5,4 +5,5 @@ set -e
+ # for kernel < 3.13 to make netlink compat code work
+ sed -i \
+ 	-e 's/^static const struct genl_multicast_group batadv_netlink_mcgrps/static __genl_const struct genl_multicast_group batadv_netlink_mcgrps/' \
++	-e 's/^static const struct genl_ops batadv_netlink_ops/static __genl_const struct genl_ops batadv_netlink_ops/' \
+ 	build/net/batman-adv/netlink.c
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 64cb6ac..aee20a3 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -534,7 +534,7 @@ batadv_netlink_dump_hardifs(struct sk_buff *msg, struct netlink_callback *cb)
+ 	return msg->len;
+ }
+ 
+-static struct genl_ops batadv_netlink_ops[] = {
++static const struct genl_ops batadv_netlink_ops[] = {
+ 	{
+ 		.cmd = BATADV_CMD_GET_MESH_INFO,
+ 		.flags = GENL_ADMIN_PERM,
diff --git a/batman-adv/patches/0048-batman-adv-Remove-unused-variable-initialization-in-.patch b/batman-adv/patches/0048-batman-adv-Remove-unused-variable-initialization-in-.patch
new file mode 100644
index 0000000..deb9b8d
--- /dev/null
+++ b/batman-adv/patches/0048-batman-adv-Remove-unused-variable-initialization-in-.patch
@@ -0,0 +1,23 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Tue, 25 Oct 2016 07:54:45 +0200
+Subject: [PATCH] batman-adv: Remove unused variable initialization in batadv_get_real_netdev
+
+Fixes: 8d5c6d68b625 ("batman-adv: retrieve B.A.T.M.A.N. V WiFi neighbor stats from real interface")
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/hard-interface.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index d83e253..61a431a 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -255,7 +255,7 @@ out:
+  */
+ struct net_device *batadv_get_real_netdev(struct net_device *net_device)
+ {
+-	struct net_device *real_netdev = NULL;
++	struct net_device *real_netdev;
+ 
+ 	rtnl_lock();
+ 	real_netdev = batadv_get_real_netdevice(net_device);
diff --git a/batman-adv/patches/0049-batman-adv-Start-new-development-cycle.patch b/batman-adv/patches/0049-batman-adv-Start-new-development-cycle.patch
new file mode 100644
index 0000000..086c6f1
--- /dev/null
+++ b/batman-adv/patches/0049-batman-adv-Start-new-development-cycle.patch
@@ -0,0 +1,22 @@
+From: Simon Wunderlich <sw@simonwunderlich.de>
+Date: Thu, 27 Oct 2016 21:16:34 +0200
+Subject: [PATCH] batman-adv: Start new development cycle
+
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ net/batman-adv/main.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/main.h b/net/batman-adv/main.h
+index 2a0bb49..a6cc804 100644
+--- a/net/batman-adv/main.h
++++ b/net/batman-adv/main.h
+@@ -24,7 +24,7 @@
+ #define BATADV_DRIVER_DEVICE "batman-adv"
+ 
+ #ifndef BATADV_SOURCE_VERSION
+-#define BATADV_SOURCE_VERSION "2016.4"
++#define BATADV_SOURCE_VERSION "2016.5"
+ #endif
+ 
+ /* B.A.T.M.A.N. parameters */
diff --git a/batman-adv/patches/0050-batman-adv-genetlink-no-longer-support-using-static-.patch b/batman-adv/patches/0050-batman-adv-genetlink-no-longer-support-using-static-.patch
new file mode 100644
index 0000000..f2e28d4
--- /dev/null
+++ b/batman-adv/patches/0050-batman-adv-genetlink-no-longer-support-using-static-.patch
@@ -0,0 +1,41 @@
+From: Johannes Berg <johannes.berg@intel.com>
+Date: Mon, 24 Oct 2016 14:40:02 +0200
+Subject: [PATCH] batman-adv: genetlink: no longer support using static family IDs
+
+Static family IDs have never really been used, the only
+use case was the workaround I introduced for those users
+that assumed their family ID was also their multicast
+group ID.
+
+Additionally, because static family IDs would never be
+reserved by the generic netlink code, using a relatively
+low ID would only work for built-in families that can be
+registered immediately after generic netlink is started,
+which is basically only the control family (apart from
+the workaround code, which I also had to add code for so
+it would reserve those IDs)
+
+Thus, anything other than GENL_ID_GENERATE is flawed and
+luckily not used except in the cases I mentioned. Move
+those workarounds into a few lines of code, and then get
+rid of GENL_ID_GENERATE entirely, making it more robust.
+
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/netlink.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index aee20a3..a951e02 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -49,7 +49,6 @@
+ #include "translation-table.h"
+ 
+ struct genl_family batadv_netlink_family = {
+-	.id = GENL_ID_GENERATE,
+ 	.hdrsize = 0,
+ 	.name = BATADV_NL_NAME,
+ 	.version = 1,
diff --git a/batman-adv/patches/0051-batman-adv-genetlink-statically-initialize-families.patch b/batman-adv/patches/0051-batman-adv-genetlink-statically-initialize-families.patch
new file mode 100644
index 0000000..3e3efc1
--- /dev/null
+++ b/batman-adv/patches/0051-batman-adv-genetlink-statically-initialize-families.patch
@@ -0,0 +1,109 @@
+From: Johannes Berg <johannes.berg@intel.com>
+Date: Mon, 24 Oct 2016 14:40:03 +0200
+Subject: [PATCH] batman-adv: genetlink: statically initialize families
+
+Instead of providing macros/inline functions to initialize
+the families, make all users initialize them statically and
+get rid of the macros.
+
+This reduces the kernel code size by about 1.6k on x86-64
+(with allyesconfig).
+
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+[sven@narfation.org: adjust compat code]
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ compat-include/net/genetlink.h | 21 ++-------------------
+ net/batman-adv/netlink.c       | 25 +++++++++++++++----------
+ 2 files changed, 17 insertions(+), 29 deletions(-)
+
+diff --git a/compat-include/net/genetlink.h b/compat-include/net/genetlink.h
+index 72a8991..2e8e17a 100644
+--- a/compat-include/net/genetlink.h
++++ b/compat-include/net/genetlink.h
+@@ -85,11 +85,6 @@ batadv_genlmsg_multicast_netns(struct batadv_genl_family *family,
+ #define genl_unregister_family(_family) \
+ 	genl_unregister_family(&(_family)->family)
+ 
+-#define genl_register_family_with_ops_groups(family, ops, grps) \
+-	batadv_genl_register_family_with_ops_grps((family), \
+-						  (ops), ARRAY_SIZE(ops), \
+-						  (grps), ARRAY_SIZE(grps))
+-
+ static inline int batadv_genl_register_family(struct genl_family *family)
+ {
+ 	unsigned int i;
+@@ -137,20 +132,8 @@ static inline int batadv_genl_register_family(struct genl_family *family)
+ 	return ret;
+ }
+ 
+-static inline int
+-batadv_genl_register_family_with_ops_grps(struct genl_family *family,
+-					  struct genl_ops *ops, size_t n_ops,
+-					  struct genl_multicast_group *mcgrps,
+-					  size_t n_mcgrps)
+-{
+-	family->ops = ops;
+-	family->n_ops = n_ops;
+-	family->mcgrps = mcgrps;
+-	family->n_mcgrps = n_mcgrps;
+-	family->module = THIS_MODULE;
+-
+-	return batadv_genl_register_family(family);
+-}
++#define genl_register_family(family) \
++	batadv_genl_register_family((family))
+ 
+ #define __genl_const
+ 
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index a951e02..5dfc5c4 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -48,13 +48,7 @@
+ #include "tp_meter.h"
+ #include "translation-table.h"
+ 
+-struct genl_family batadv_netlink_family = {
+-	.hdrsize = 0,
+-	.name = BATADV_NL_NAME,
+-	.version = 1,
+-	.maxattr = BATADV_ATTR_MAX,
+-	.netnsok = true,
+-};
++struct genl_family batadv_netlink_family;
+ 
+ /* multicast groups */
+ enum batadv_netlink_multicast_groups {
+@@ -609,6 +603,19 @@ static const struct genl_ops batadv_netlink_ops[] = {
+ 
+ };
+ 
++struct genl_family batadv_netlink_family = {
++	.hdrsize = 0,
++	.name = BATADV_NL_NAME,
++	.version = 1,
++	.maxattr = BATADV_ATTR_MAX,
++	.netnsok = true,
++	.module = THIS_MODULE,
++	.ops = batadv_netlink_ops,
++	.n_ops = ARRAY_SIZE(batadv_netlink_ops),
++	.mcgrps = batadv_netlink_mcgrps,
++	.n_mcgrps = ARRAY_SIZE(batadv_netlink_mcgrps),
++};
++
+ /**
+  * batadv_netlink_register - register batadv genl netlink family
+  */
+@@ -616,9 +623,7 @@ void __init batadv_netlink_register(void)
+ {
+ 	int ret;
+ 
+-	ret = genl_register_family_with_ops_groups(&batadv_netlink_family,
+-						   batadv_netlink_ops,
+-						   batadv_netlink_mcgrps);
++	ret = genl_register_family(&batadv_netlink_family);
+ 	if (ret)
+ 		pr_warn("unable to register netlink family");
+ }
diff --git a/batman-adv/patches/0052-batman-adv-genetlink-mark-families-as-__ro_after_ini.patch b/batman-adv/patches/0052-batman-adv-genetlink-mark-families-as-__ro_after_ini.patch
new file mode 100644
index 0000000..d3c7f5f
--- /dev/null
+++ b/batman-adv/patches/0052-batman-adv-genetlink-mark-families-as-__ro_after_ini.patch
@@ -0,0 +1,79 @@
+From: Johannes Berg <johannes.berg@intel.com>
+Date: Mon, 24 Oct 2016 14:40:05 +0200
+Subject: [PATCH] batman-adv: genetlink: mark families as __ro_after_init
+
+Now genl_register_family() is the only thing (other than the
+users themselves, perhaps, but I didn't find any doing that)
+writing to the family struct.
+
+In all families that I found, genl_register_family() is only
+called from __init functions (some indirectly, in which case
+I've add __init annotations to clarifly things), so all can
+actually be marked __ro_after_init.
+
+This protects the data structure from accidental corruption.
+
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+[sven@narfation.org: Add compat code]
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ compat-include/linux/cache.h | 35 +++++++++++++++++++++++++++++++++++
+ net/batman-adv/netlink.c     |  2 +-
+ 2 files changed, 36 insertions(+), 1 deletion(-)
+ create mode 100644 compat-include/linux/cache.h
+
+diff --git a/compat-include/linux/cache.h b/compat-include/linux/cache.h
+new file mode 100644
+index 0000000..93dff58
+--- /dev/null
++++ b/compat-include/linux/cache.h
+@@ -0,0 +1,35 @@
++/* Copyright (C) 2007-2016 B.A.T.M.A.N. contributors:
++ *
++ * Marek Lindner, Simon Wunderlich
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of version 2 of the GNU General Public
++ * License as published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, see <http://www.gnu.org/licenses/>.
++ *
++ * This file contains macros for maintaining compatibility with older versions
++ * of the Linux kernel.
++ */
++
++#ifndef _NET_BATMAN_ADV_COMPAT_LINUX_CACHE_H
++#define _NET_BATMAN_ADV_COMPAT_LINUX_CACHE_H
++
++#include <linux/version.h>
++#include_next <linux/cache.h>
++
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
++
++#ifndef __ro_after_init
++#define __ro_after_init
++#endif
++
++#endif /* < KERNEL_VERSION(4, 6, 0) */
++
++#endif /* _NET_BATMAN_ADV_COMPAT_LINUX_CACHE_H */
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 5dfc5c4..5d38c77 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -603,7 +603,7 @@ static const struct genl_ops batadv_netlink_ops[] = {
+ 
+ };
+ 
+-struct genl_family batadv_netlink_family = {
++struct genl_family batadv_netlink_family __ro_after_init = {
+ 	.hdrsize = 0,
+ 	.name = BATADV_NL_NAME,
+ 	.version = 1,
diff --git a/batman-adv/patches/0053-batman-adv-Introduce-missing-headers-for-genetlink-r.patch b/batman-adv/patches/0053-batman-adv-Introduce-missing-headers-for-genetlink-r.patch
new file mode 100644
index 0000000..5ed4f46
--- /dev/null
+++ b/batman-adv/patches/0053-batman-adv-Introduce-missing-headers-for-genetlink-r.patch
@@ -0,0 +1,30 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 29 Oct 2016 10:13:47 +0200
+Subject: [PATCH] batman-adv: Introduce missing headers for genetlink restructure
+
+Fixes: c776b4a071d8 ("batman-adv: genetlink: mark families as __ro_after_init")
+Fixes: f0f80621705b ("batman-adv: genetlink: statically initialize families")
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/netlink.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 5d38c77..0627381 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -20,11 +20,14 @@
+ 
+ #include <linux/atomic.h>
+ #include <linux/byteorder/generic.h>
++#include <linux/cache.h>
+ #include <linux/errno.h>
++#include <linux/export.h>
+ #include <linux/fs.h>
+ #include <linux/genetlink.h>
+ #include <linux/if_ether.h>
+ #include <linux/init.h>
++#include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/netlink.h>
+ #include <linux/printk.h>
diff --git a/batman-adv/patches/0054-batman-adv-Add-module-alias-for-batadv-netlink-famil.patch b/batman-adv/patches/0054-batman-adv-Add-module-alias-for-batadv-netlink-famil.patch
new file mode 100644
index 0000000..609b28c
--- /dev/null
+++ b/batman-adv/patches/0054-batman-adv-Add-module-alias-for-batadv-netlink-famil.patch
@@ -0,0 +1,38 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 29 Oct 2016 13:56:23 +0200
+Subject: [PATCH] batman-adv: Add module alias for batadv netlink family
+
+The batman-adv module has to be loaded to fulfill genl request by the
+userspace. When it is not loaded then requests will fail. It is therefore
+useful to get the module automatically loaded when such a request is made.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ net/batman-adv/main.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/net/batman-adv/main.c b/net/batman-adv/main.c
+index 6b5dae6..d46415e 100644
+--- a/net/batman-adv/main.c
++++ b/net/batman-adv/main.c
+@@ -23,6 +23,7 @@
+ #include <linux/crc32c.h>
+ #include <linux/errno.h>
+ #include <linux/fs.h>
++#include <linux/genetlink.h>
+ #include <linux/if_ether.h>
+ #include <linux/if_vlan.h>
+ #include <linux/init.h>
+@@ -44,6 +45,7 @@
+ #include <linux/workqueue.h>
+ #include <net/dsfield.h>
+ #include <net/rtnetlink.h>
++#include <uapi/linux/batman_adv.h>
+ 
+ #include "bat_algo.h"
+ #include "bat_iv_ogm.h"
+@@ -648,3 +650,4 @@ MODULE_DESCRIPTION(BATADV_DRIVER_DESC);
+ MODULE_SUPPORTED_DEVICE(BATADV_DRIVER_DEVICE);
+ MODULE_VERSION(BATADV_SOURCE_VERSION);
+ MODULE_ALIAS_RTNL_LINK("batadv");
++MODULE_ALIAS_GENL_FAMILY(BATADV_NL_NAME);
diff --git a/batman-adv/patches/0055-batman-adv-Ignore-MODULE_ALIAS_GENL_FAMILY-on-old-ke.patch b/batman-adv/patches/0055-batman-adv-Ignore-MODULE_ALIAS_GENL_FAMILY-on-old-ke.patch
new file mode 100644
index 0000000..459be57
--- /dev/null
+++ b/batman-adv/patches/0055-batman-adv-Ignore-MODULE_ALIAS_GENL_FAMILY-on-old-ke.patch
@@ -0,0 +1,49 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 30 Oct 2016 11:07:31 +0100
+Subject: [PATCH] batman-adv: Ignore MODULE_ALIAS_GENL_FAMILY on old kernels
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ compat-include/linux/genetlink.h | 33 +++++++++++++++++++++++++++++++++
+ 1 file changed, 33 insertions(+)
+ create mode 100644 compat-include/linux/genetlink.h
+
+diff --git a/compat-include/linux/genetlink.h b/compat-include/linux/genetlink.h
+new file mode 100644
+index 0000000..9c5983d
+--- /dev/null
++++ b/compat-include/linux/genetlink.h
+@@ -0,0 +1,33 @@
++/* Copyright (C) 2007-2016  B.A.T.M.A.N. contributors:
++ *
++ * Marek Lindner, Simon Wunderlich
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of version 2 of the GNU General Public
++ * License as published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, see <http://www.gnu.org/licenses/>.
++ *
++ * This file contains macros for maintaining compatibility with older versions
++ * of the Linux kernel.
++ */
++
++#ifndef _NET_BATMAN_ADV_COMPAT_LINUX_GENETLINK_H_
++#define _NET_BATMAN_ADV_COMPAT_LINUX_GENETLINK_H_
++
++#include <linux/version.h>
++#include_next <linux/genetlink.h>
++
++#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
++
++#define MODULE_ALIAS_GENL_FAMILY(family)
++
++#endif /* < KERNEL_VERSION(3, 5, 0) */
++
++#endif	/* _NET_BATMAN_ADV_COMPAT_LINUX_GENETLINK_H_ */
diff --git a/batman-adv/patches/0056-batman-adv-Deactivate-__ro_after_init-for-kernels-4..patch b/batman-adv/patches/0056-batman-adv-Deactivate-__ro_after_init-for-kernels-4..patch
new file mode 100644
index 0000000..0d924ad
--- /dev/null
+++ b/batman-adv/patches/0056-batman-adv-Deactivate-__ro_after_init-for-kernels-4..patch
@@ -0,0 +1,37 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Tue, 1 Nov 2016 07:17:50 +0100
+Subject: [PATCH] batman-adv: Deactivate __ro_after_init for kernels < 4.10
+
+The pre-4.10 kernels must write to batadv_netlink_family after the family
+was registered. Thus disabling __ro_after_init for now is required on these
+kernels.
+
+Fixes: c776b4a071d8 ("batman-adv: genetlink: mark families as __ro_after_init")
+Reported-by: Linus Lüssing <linus.luessing@c0d3.blue>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Tested-by: Linus Lüssing <linus.luessing@c0d3.blue>
+---
+ compat-include/linux/cache.h | 8 +++++---
+ 1 file changed, 5 insertions(+), 3 deletions(-)
+
+diff --git a/compat-include/linux/cache.h b/compat-include/linux/cache.h
+index 93dff58..7b7069a 100644
+--- a/compat-include/linux/cache.h
++++ b/compat-include/linux/cache.h
+@@ -24,11 +24,13 @@
+ #include <linux/version.h>
+ #include_next <linux/cache.h>
+ 
+-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+ 
+-#ifndef __ro_after_init
+-#define __ro_after_init
++/* hack for netlink.c which marked the family ops as ro */
++#ifdef __ro_after_init
++#undef __ro_after_init
+ #endif
++#define __ro_after_init
+ 
+ #endif /* < KERNEL_VERSION(4, 6, 0) */
+ 
diff --git a/batman-adv/patches/0057-batman-adv-fix-rare-race-conditions-on-interface-rem.patch b/batman-adv/patches/0057-batman-adv-fix-rare-race-conditions-on-interface-rem.patch
new file mode 100644
index 0000000..911c7b2
--- /dev/null
+++ b/batman-adv/patches/0057-batman-adv-fix-rare-race-conditions-on-interface-rem.patch
@@ -0,0 +1,548 @@
+From: Linus Lüssing <linus.luessing@c0d3.blue>
+Date: Tue, 1 Nov 2016 09:44:44 +0100
+Subject: [PATCH] batman-adv: fix rare race conditions on interface removal
+
+In rare cases during shutdown the following general protection fault can
+happen:
+
+  general protection fault: 0000 [#1] SMP
+  Modules linked in: batman_adv(O-) [...]
+  CPU: 3 PID: 1714 Comm: rmmod Tainted: G           O    4.6.0-rc6+ #1
+  [...]
+  Call Trace:
+   [<ffffffffa0363294>] batadv_hardif_disable_interface+0x29a/0x3a6 [batman_adv]
+   [<ffffffffa0373db4>] batadv_softif_destroy_netlink+0x4b/0xa4 [batman_adv]
+   [<ffffffff813b52f3>] __rtnl_link_unregister+0x48/0x92
+   [<ffffffff813b9240>] rtnl_link_unregister+0xc1/0xdb
+   [<ffffffff8108547c>] ? bit_waitqueue+0x87/0x87
+   [<ffffffffa03850d2>] batadv_exit+0x1a/0xf48 [batman_adv]
+   [<ffffffff810c26f9>] SyS_delete_module+0x136/0x1b0
+   [<ffffffff8144dc65>] entry_SYSCALL_64_fastpath+0x18/0xa8
+   [<ffffffff8108aaca>] ? trace_hardirqs_off_caller+0x37/0xa6
+  Code: 89 f7 e8 21 bd 0d e1 4d 85 e4 75 0e 31 f6 48 c7 c7 50 d7 3b a0 e8 50 16 f2 e0 49 8b 9c 24 28 01 00 00 48 85 db 0f 84 b2 00 00 00 <48> 8b 03 4d 85 ed 48 89 45 c8 74 09 4c 39 ab f8 00 00 00 75 1c
+  RIP  [<ffffffffa0371852>] batadv_purge_outstanding_packets+0x1c8/0x291 [batman_adv]
+   RSP <ffff88001da5fd78>
+  ---[ end trace 803b9bdc6a4a952b ]---
+  Kernel panic - not syncing: Fatal exception in interrupt
+  Kernel Offset: disabled
+  ---[ end Kernel panic - not syncing: Fatal exception in interrupt
+
+It does not happen often, but may potentially happen when frequently
+shutting down and reinitializing an interface. With some carefully
+placed msleep()s/mdelay()s it can be reproduced easily.
+
+The issue is, that on interface removal, any still running worker thread
+of a forwarding packet will race with the interface purging routine to
+free a forwarding packet. Temporarily giving up a spin-lock to be able
+to sleep in the purging routine is not safe.
+
+Furthermore, there is a potential general protection fault not just for
+the purging side shown above, but also on the worker side: Temporarily
+removing a forw_packet from the according forw_{bcast,bat}_list will make
+it impossible for the purging routine to catch and cancel it.
+
+ # How this patch tries to fix it:
+
+With this patch we split the queue purging into three steps: Step 1),
+removing forward packets from the queue of an interface and by that
+claim it as our responsibility to free.
+
+Step 2), we are either lucky to cancel a pending worker before it starts
+to run. Or if it is already running, we wait and let it do its thing,
+except two things:
+
+Through the claiming in step 1) we prevent workers from a) re-arming
+themselves. And b) prevent workers from freeing packets which we still
+hold in the interface purging routine.
+
+Finally, step 3, we are sure that no forwarding packets are pending or
+even running anymore on the interface to remove. We can then safely free
+the claimed forwarding packets.
+
+Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ compat-include/linux/list.h |  13 +-
+ net/batman-adv/bat_iv_ogm.c |  19 +--
+ net/batman-adv/send.c       | 285 +++++++++++++++++++++++++++++++++-----------
+ net/batman-adv/send.h       |   5 +
+ net/batman-adv/types.h      |   2 +
+ 5 files changed, 239 insertions(+), 85 deletions(-)
+
+diff --git a/compat-include/linux/list.h b/compat-include/linux/list.h
+index c7f07f1..30a14e0 100644
+--- a/compat-include/linux/list.h
++++ b/compat-include/linux/list.h
+@@ -43,12 +43,21 @@
+ 	pos && ({ n = pos->member.next; 1; }); \
+ 	pos = hlist_entry_safe(n, typeof(*pos), member))
+ 
+-#endif
++#endif /* < KERNEL_VERSION(3, 9, 0) */
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
+ 
+ #define hlist_add_behind(n, prev) hlist_add_after(prev, n)
+ 
+-#endif
++#endif /* < KERNEL_VERSION(3, 17, 0) */
++
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0)
++
++static inline bool hlist_fake(struct hlist_node *h)
++{
++	return h->pprev == &h->next;
++}
++
++#endif /* < KERNEL_VERSION(4, 3, 0) */
+ 
+ #endif	/* _NET_BATMAN_ADV_COMPAT_LINUX_LIST_H_ */
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index 36d8818..f00f666 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -717,17 +717,10 @@ static void batadv_iv_ogm_aggregate_new(const unsigned char *packet_buff,
+ 	if (direct_link)
+ 		forw_packet_aggr->direct_link_flags |= 1;
+ 
+-	/* add new packet to packet list */
+-	spin_lock_bh(&bat_priv->forw_bat_list_lock);
+-	hlist_add_head(&forw_packet_aggr->list, &bat_priv->forw_bat_list);
+-	spin_unlock_bh(&bat_priv->forw_bat_list_lock);
+-
+-	/* start timer for this packet */
+ 	INIT_DELAYED_WORK(&forw_packet_aggr->delayed_work,
+ 			  batadv_iv_send_outstanding_bat_ogm_packet);
+-	queue_delayed_work(batadv_event_workqueue,
+-			   &forw_packet_aggr->delayed_work,
+-			   send_time - jiffies);
++
++	batadv_forw_packet_ogmv1_queue(bat_priv, forw_packet_aggr, send_time);
+ }
+ 
+ /* aggregate a new packet into the existing ogm packet */
+@@ -1789,9 +1782,6 @@ static void batadv_iv_send_outstanding_bat_ogm_packet(struct work_struct *work)
+ 	forw_packet = container_of(delayed_work, struct batadv_forw_packet,
+ 				   delayed_work);
+ 	bat_priv = netdev_priv(forw_packet->if_incoming->soft_iface);
+-	spin_lock_bh(&bat_priv->forw_bat_list_lock);
+-	hlist_del(&forw_packet->list);
+-	spin_unlock_bh(&bat_priv->forw_bat_list_lock);
+ 
+ 	if (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING) {
+ 		dropped = true;
+@@ -1813,7 +1803,10 @@ static void batadv_iv_send_outstanding_bat_ogm_packet(struct work_struct *work)
+ 		batadv_iv_ogm_schedule(forw_packet->if_incoming);
+ 
+ out:
+-	batadv_forw_packet_free(forw_packet, dropped);
++	/* do we get something for free()? */
++	if (batadv_forw_packet_steal(forw_packet,
++				     &bat_priv->forw_bat_list_lock))
++		batadv_forw_packet_free(forw_packet, dropped);
+ }
+ 
+ static int batadv_iv_ogm_receive(struct sk_buff *skb,
+diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
+index 9ea272e..49021b7 100644
+--- a/net/batman-adv/send.c
++++ b/net/batman-adv/send.c
+@@ -19,6 +19,7 @@
+ #include "main.h"
+ 
+ #include <linux/atomic.h>
++#include <linux/bug.h>
+ #include <linux/byteorder/generic.h>
+ #include <linux/errno.h>
+ #include <linux/etherdevice.h>
+@@ -520,6 +521,8 @@ batadv_forw_packet_alloc(struct batadv_hard_iface *if_incoming,
+ 	if (if_outgoing)
+ 		kref_get(&if_outgoing->refcount);
+ 
++	INIT_HLIST_NODE(&forw_packet->list);
++	INIT_HLIST_NODE(&forw_packet->cleanup_list);
+ 	forw_packet->skb = NULL;
+ 	forw_packet->queue_left = queue_left;
+ 	forw_packet->if_incoming = if_incoming;
+@@ -535,19 +538,191 @@ err:
+ 	return NULL;
+ }
+ 
+-static void
+-_batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+-				 struct batadv_forw_packet *forw_packet,
+-				 unsigned long send_time)
++/**
++ * batadv_forw_packet_was_stolen - check whether someone stole this packet
++ * @forw_packet: the forwarding packet to check
++ *
++ * This function checks whether the given forwarding packet was claimed by
++ * someone else for free().
++ *
++ * Return: True if someone stole it, false otherwise.
++ */
++static bool
++batadv_forw_packet_was_stolen(struct batadv_forw_packet *forw_packet)
+ {
+-	/* add new packet to packet list */
+-	spin_lock_bh(&bat_priv->forw_bcast_list_lock);
+-	hlist_add_head(&forw_packet->list, &bat_priv->forw_bcast_list);
+-	spin_unlock_bh(&bat_priv->forw_bcast_list_lock);
++	return !hlist_unhashed(&forw_packet->cleanup_list);
++}
+ 
+-	/* start timer for this packet */
+-	queue_delayed_work(batadv_event_workqueue, &forw_packet->delayed_work,
+-			   send_time);
++/**
++ * batadv_forw_packet_steal - claim a forw_packet for free()
++ * @forw_packet: the forwarding packet to steal
++ * @lock: a key to the store to steal from (e.g. forw_{bat,bcast}_list_lock)
++ *
++ * This function tries to steal a specific forw_packet from global
++ * visibility for the purpose of getting it for free(). That means
++ * the caller is *not* allowed to requeue it afterwards.
++ *
++ * Return: True if stealing was successful. False if someone else stole it
++ * before us.
++ */
++bool batadv_forw_packet_steal(struct batadv_forw_packet *forw_packet,
++			      spinlock_t *lock)
++{
++	/* did purging routine steal it earlier? */
++	spin_lock_bh(lock);
++	if (batadv_forw_packet_was_stolen(forw_packet)) {
++		spin_unlock_bh(lock);
++		return false;
++	}
++
++	hlist_del_init(&forw_packet->list);
++
++	/* Just to spot misuse of this function */
++	hlist_add_fake(&forw_packet->cleanup_list);
++
++	spin_unlock_bh(lock);
++	return true;
++}
++
++/**
++ * batadv_forw_packet_list_steal - claim a list of forward packets for free()
++ * @forw_list: the to be stolen forward packets
++ * @cleanup_list: a backup pointer, to be able to dispose the packet later
++ * @hard_iface: the interface to steal forward packets from
++ *
++ * This function claims responsibility to free any forw_packet queued on the
++ * given hard_iface. If hard_iface is NULL forwarding packets on all hard
++ * interfaces will be claimed.
++ *
++ * The packets are being moved from the forw_list to the cleanup_list and
++ * by that allows already running threads to notice the claiming.
++ */
++static void
++batadv_forw_packet_list_steal(struct hlist_head *forw_list,
++			      struct hlist_head *cleanup_list,
++			      const struct batadv_hard_iface *hard_iface)
++{
++	struct batadv_forw_packet *forw_packet;
++	struct hlist_node *safe_tmp_node;
++
++	hlist_for_each_entry_safe(forw_packet, safe_tmp_node,
++				  forw_list, list) {
++		/* if purge_outstanding_packets() was called with an argument
++		 * we delete only packets belonging to the given interface
++		 */
++		if (hard_iface &&
++		    (forw_packet->if_incoming != hard_iface) &&
++		    (forw_packet->if_outgoing != hard_iface))
++			continue;
++
++		hlist_del(&forw_packet->list);
++		hlist_add_head(&forw_packet->cleanup_list, cleanup_list);
++	}
++}
++
++/**
++ * batadv_forw_packet_list_free - free a list of forward packets
++ * @head: a list of to be freed forw_packets
++ *
++ * This function cancels the scheduling of any packet in the provided list,
++ * waits for any possibly running packet forwarding thread to finish and
++ * finally, safely frees this forward packet.
++ *
++ * This function might sleep.
++ */
++static void batadv_forw_packet_list_free(struct hlist_head *head)
++{
++	struct batadv_forw_packet *forw_packet;
++	struct hlist_node *safe_tmp_node;
++
++	hlist_for_each_entry_safe(forw_packet, safe_tmp_node, head,
++				  cleanup_list) {
++		cancel_delayed_work_sync(&forw_packet->delayed_work);
++
++		hlist_del(&forw_packet->cleanup_list);
++		batadv_forw_packet_free(forw_packet, true);
++	}
++}
++
++/**
++ * batadv_forw_packet_queue - try to queue a forwarding packet
++ * @forw_packet: the forwarding packet to queue
++ * @lock: a key to the store (e.g. forw_{bat,bcast}_list_lock)
++ * @head: the shelve to queue it on (e.g. forw_{bat,bcast}_list)
++ * @send_time: timestamp (jiffies) when the packet is to be sent
++ *
++ * This function tries to (re)queue a forwarding packet. Requeuing
++ * is prevented if the according interface is shutting down
++ * (e.g. if batadv_forw_packet_list_steal() was called for this
++ * packet earlier).
++ *
++ * Calling batadv_forw_packet_queue() after a call to
++ * batadv_forw_packet_steal() is forbidden!
++ *
++ * Caller needs to ensure that forw_packet->delayed_work was initialized.
++ */
++static void batadv_forw_packet_queue(struct batadv_forw_packet *forw_packet,
++				     spinlock_t *lock, struct hlist_head *head,
++				     unsigned long send_time)
++{
++	spin_lock_bh(lock);
++
++	/* did purging routine steal it from us? */
++	if (batadv_forw_packet_was_stolen(forw_packet)) {
++		/* If you got it for free() without trouble, then
++		 * don't get back into the queue after stealing...
++		 */
++		WARN_ONCE(hlist_fake(&forw_packet->cleanup_list),
++			  "Requeuing after batadv_forw_packet_steal() not allowed!\n");
++
++		spin_unlock_bh(lock);
++		return;
++	}
++
++	hlist_del_init(&forw_packet->list);
++	hlist_add_head(&forw_packet->list, head);
++
++	queue_delayed_work(batadv_event_workqueue,
++			   &forw_packet->delayed_work,
++			   send_time - jiffies);
++	spin_unlock_bh(lock);
++}
++
++/**
++ * batadv_forw_packet_bcast_queue - try to queue a broadcast packet
++ * @bat_priv: the bat priv with all the soft interface information
++ * @forw_packet: the forwarding packet to queue
++ * @send_time: timestamp (jiffies) when the packet is to be sent
++ *
++ * This function tries to (re)queue a broadcast packet.
++ *
++ * Caller needs to ensure that forw_packet->delayed_work was initialized.
++ */
++static void
++batadv_forw_packet_bcast_queue(struct batadv_priv *bat_priv,
++			       struct batadv_forw_packet *forw_packet,
++			       unsigned long send_time)
++{
++	batadv_forw_packet_queue(forw_packet, &bat_priv->forw_bcast_list_lock,
++				 &bat_priv->forw_bcast_list, send_time);
++}
++
++/**
++ * batadv_forw_packet_ogmv1_queue - try to queue an OGMv1 packet
++ * @bat_priv: the bat priv with all the soft interface information
++ * @forw_packet: the forwarding packet to queue
++ * @send_time: timestamp (jiffies) when the packet is to be sent
++ *
++ * This function tries to (re)queue an OGMv1 packet.
++ *
++ * Caller needs to ensure that forw_packet->delayed_work was initialized.
++ */
++void batadv_forw_packet_ogmv1_queue(struct batadv_priv *bat_priv,
++				    struct batadv_forw_packet *forw_packet,
++				    unsigned long send_time)
++{
++	batadv_forw_packet_queue(forw_packet, &bat_priv->forw_bat_list_lock,
++				 &bat_priv->forw_bat_list, send_time);
+ }
+ 
+ /**
+@@ -600,7 +775,7 @@ int batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+ 	INIT_DELAYED_WORK(&forw_packet->delayed_work,
+ 			  batadv_send_outstanding_bcast_packet);
+ 
+-	_batadv_add_bcast_packet_to_list(bat_priv, forw_packet, delay);
++	batadv_forw_packet_bcast_queue(bat_priv, forw_packet, jiffies + delay);
+ 	return NETDEV_TX_OK;
+ 
+ err_packet_free:
+@@ -619,6 +794,7 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+ 	struct sk_buff *skb1;
+ 	struct net_device *soft_iface;
+ 	struct batadv_priv *bat_priv;
++	unsigned long send_time = jiffies + msecs_to_jiffies(5);
+ 	bool dropped = false;
+ 	u8 *neigh_addr;
+ 	u8 *orig_neigh;
+@@ -630,10 +806,6 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+ 	soft_iface = forw_packet->if_incoming->soft_iface;
+ 	bat_priv = netdev_priv(soft_iface);
+ 
+-	spin_lock_bh(&bat_priv->forw_bcast_list_lock);
+-	hlist_del(&forw_packet->list);
+-	spin_unlock_bh(&bat_priv->forw_bcast_list_lock);
+-
+ 	if (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING) {
+ 		dropped = true;
+ 		goto out;
+@@ -714,22 +886,34 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+ 
+ 	/* if we still have some more bcasts to send */
+ 	if (forw_packet->num_packets < BATADV_NUM_BCASTS_MAX) {
+-		_batadv_add_bcast_packet_to_list(bat_priv, forw_packet,
+-						 msecs_to_jiffies(5));
++		batadv_forw_packet_bcast_queue(bat_priv, forw_packet,
++					       send_time);
+ 		return;
+ 	}
+ 
+ out:
+-	batadv_forw_packet_free(forw_packet, dropped);
++	/* do we get something for free()? */
++	if (batadv_forw_packet_steal(forw_packet,
++				     &bat_priv->forw_bcast_list_lock))
++		batadv_forw_packet_free(forw_packet, dropped);
+ }
+ 
++/**
++ * batadv_purge_outstanding_packets - stop/purge scheduled bcast/OGMv1 packets
++ * @bat_priv: the bat priv with all the soft interface information
++ * @hard_iface: the hard interface to cancel and purge bcast/ogm packets on
++ *
++ * This method cancels and purges any broadcast and OGMv1 packet on the given
++ * hard_iface. If hard_iface is NULL, broadcast and OGMv1 packets on all hard
++ * interfaces will be canceled and purged.
++ *
++ * This function might sleep.
++ */
+ void
+ batadv_purge_outstanding_packets(struct batadv_priv *bat_priv,
+ 				 const struct batadv_hard_iface *hard_iface)
+ {
+-	struct batadv_forw_packet *forw_packet;
+-	struct hlist_node *safe_tmp_node;
+-	bool pending;
++	struct hlist_head head = HLIST_HEAD_INIT;
+ 
+ 	if (hard_iface)
+ 		batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
+@@ -739,57 +923,18 @@ batadv_purge_outstanding_packets(struct batadv_priv *bat_priv,
+ 		batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
+ 			   "purge_outstanding_packets()\n");
+ 
+-	/* free bcast list */
++	/* claim bcast list for free() */
+ 	spin_lock_bh(&bat_priv->forw_bcast_list_lock);
+-	hlist_for_each_entry_safe(forw_packet, safe_tmp_node,
+-				  &bat_priv->forw_bcast_list, list) {
+-		/* if purge_outstanding_packets() was called with an argument
+-		 * we delete only packets belonging to the given interface
+-		 */
+-		if ((hard_iface) &&
+-		    (forw_packet->if_incoming != hard_iface) &&
+-		    (forw_packet->if_outgoing != hard_iface))
+-			continue;
+-
+-		spin_unlock_bh(&bat_priv->forw_bcast_list_lock);
+-
+-		/* batadv_send_outstanding_bcast_packet() will lock the list to
+-		 * delete the item from the list
+-		 */
+-		pending = cancel_delayed_work_sync(&forw_packet->delayed_work);
+-		spin_lock_bh(&bat_priv->forw_bcast_list_lock);
+-
+-		if (pending) {
+-			hlist_del(&forw_packet->list);
+-			batadv_forw_packet_free(forw_packet, true);
+-		}
+-	}
++	batadv_forw_packet_list_steal(&bat_priv->forw_bcast_list, &head,
++				      hard_iface);
+ 	spin_unlock_bh(&bat_priv->forw_bcast_list_lock);
+ 
+-	/* free batman packet list */
++	/* claim batman packet list for free() */
+ 	spin_lock_bh(&bat_priv->forw_bat_list_lock);
+-	hlist_for_each_entry_safe(forw_packet, safe_tmp_node,
+-				  &bat_priv->forw_bat_list, list) {
+-		/* if purge_outstanding_packets() was called with an argument
+-		 * we delete only packets belonging to the given interface
+-		 */
+-		if ((hard_iface) &&
+-		    (forw_packet->if_incoming != hard_iface) &&
+-		    (forw_packet->if_outgoing != hard_iface))
+-			continue;
+-
+-		spin_unlock_bh(&bat_priv->forw_bat_list_lock);
+-
+-		/* send_outstanding_bat_packet() will lock the list to
+-		 * delete the item from the list
+-		 */
+-		pending = cancel_delayed_work_sync(&forw_packet->delayed_work);
+-		spin_lock_bh(&bat_priv->forw_bat_list_lock);
+-
+-		if (pending) {
+-			hlist_del(&forw_packet->list);
+-			batadv_forw_packet_free(forw_packet, true);
+-		}
+-	}
++	batadv_forw_packet_list_steal(&bat_priv->forw_bat_list, &head,
++				      hard_iface);
+ 	spin_unlock_bh(&bat_priv->forw_bat_list_lock);
++
++	/* then cancel or wait for packet workers to finish and free */
++	batadv_forw_packet_list_free(&head);
+ }
+diff --git a/net/batman-adv/send.h b/net/batman-adv/send.h
+index c580194..a94e1e8 100644
+--- a/net/batman-adv/send.h
++++ b/net/batman-adv/send.h
+@@ -21,6 +21,7 @@
+ #include "main.h"
+ 
+ #include <linux/compiler.h>
++#include <linux/spinlock.h>
+ #include <linux/types.h>
+ 
+ #include "packet.h"
+@@ -34,6 +35,10 @@ batadv_forw_packet_alloc(struct batadv_hard_iface *if_incoming,
+ 			 struct batadv_hard_iface *if_outgoing,
+ 			 atomic_t *queue_left,
+ 			 struct batadv_priv *bat_priv);
++bool batadv_forw_packet_steal(struct batadv_forw_packet *packet, spinlock_t *l);
++void batadv_forw_packet_ogmv1_queue(struct batadv_priv *bat_priv,
++				    struct batadv_forw_packet *forw_packet,
++				    unsigned long send_time);
+ 
+ int batadv_send_skb_to_orig(struct sk_buff *skb,
+ 			    struct batadv_orig_node *orig_node,
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index caa00a5..e913aee 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -1385,6 +1385,7 @@ struct batadv_skb_cb {
+ /**
+  * struct batadv_forw_packet - structure for bcast packets to be sent/forwarded
+  * @list: list node for batadv_priv::forw_{bat,bcast}_list
++ * @cleanup_list: list node for purging functions
+  * @send_time: execution time for delayed_work (packet sending)
+  * @own: bool for locally generated packets (local OGMs are re-scheduled after
+  *  sending)
+@@ -1401,6 +1402,7 @@ struct batadv_skb_cb {
+  */
+ struct batadv_forw_packet {
+ 	struct hlist_node list;
++	struct hlist_node cleanup_list;
+ 	unsigned long send_time;
+ 	u8 own;
+ 	struct sk_buff *skb;
diff --git a/batman-adv/patches/1001-batman-adv-introduce-no_rebroadcast-option.patch b/batman-adv/patches/1001-batman-adv-introduce-no_rebroadcast-option.patch
index 2f328d2..c0e0b2d 100644
--- a/batman-adv/patches/1001-batman-adv-introduce-no_rebroadcast-option.patch
+++ b/batman-adv/patches/1001-batman-adv-introduce-no_rebroadcast-option.patch
@@ -52,10 +52,10 @@ index 8981068..ac04928 100644
  Date:           Feb 2014
  Contact:        Antonio Quartulli <a@unstable.cc>
 diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
-index e034afb..b485a88 100644
+index 61a431a..b308048 100644
 --- a/net/batman-adv/hard-interface.c
 +++ b/net/batman-adv/hard-interface.c
-@@ -701,6 +701,8 @@ batadv_hardif_add_interface(struct net_device *net_dev)
+@@ -902,6 +902,8 @@ batadv_hardif_add_interface(struct net_device *net_dev)
  
  	batadv_v_hardif_init(hard_iface);
  
@@ -65,10 +65,10 @@ index e034afb..b485a88 100644
  	kref_get(&hard_iface->refcount);
  	list_add_tail_rcu(&hard_iface->list, &batadv_hardif_list);
 diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
-index 8d4e1f5..cb1b275 100644
+index 49021b7..04a8256 100644
 --- a/net/batman-adv/send.c
 +++ b/net/batman-adv/send.c
-@@ -639,11 +639,16 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+@@ -873,11 +873,16 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
  		if (!kref_get_unless_zero(&hard_iface->refcount))
  			continue;
  
@@ -86,10 +86,10 @@ index 8d4e1f5..cb1b275 100644
  	}
  	rcu_read_unlock();
 diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
-index 02d96f2..f91d09c 100644
+index 17c8441..430546b 100644
 --- a/net/batman-adv/sysfs.c
 +++ b/net/batman-adv/sysfs.c
-@@ -136,6 +136,17 @@ struct batadv_attribute batadv_attr_vlan_##_name = {	\
+@@ -135,6 +135,17 @@ struct batadv_attribute batadv_attr_vlan_##_name = {	\
  	.store  = _store,				\
  }
  
@@ -107,7 +107,7 @@ index 02d96f2..f91d09c 100644
  /* Use this, if you have customized show and store functions */
  #define BATADV_ATTR(_name, _mode, _show, _store)	\
  struct batadv_attribute batadv_attr_##_name = {		\
-@@ -295,6 +306,52 @@ ssize_t batadv_show_##_name(struct kobject *kobj,			\
+@@ -294,6 +305,52 @@ ssize_t batadv_show_##_name(struct kobject *kobj,			\
  	static BATADV_ATTR(_name, _mode, batadv_show_##_name,		\
  			   batadv_store_##_name)
  
@@ -160,15 +160,15 @@ index 02d96f2..f91d09c 100644
  static int batadv_store_bool_attr(char *buff, size_t count,
  				  struct net_device *net_dev,
  				  const char *attr_name, atomic_t *attr,
-@@ -1119,6 +1176,7 @@ static ssize_t batadv_show_throughput_override(struct kobject *kobj,
- static BATADV_ATTR(mesh_iface, S_IRUGO | S_IWUSR, batadv_show_mesh_iface,
+@@ -1113,6 +1170,7 @@ static ssize_t batadv_show_throughput_override(struct kobject *kobj,
+ static BATADV_ATTR(mesh_iface, 0644, batadv_show_mesh_iface,
  		   batadv_store_mesh_iface);
- static BATADV_ATTR(iface_status, S_IRUGO, batadv_show_iface_status, NULL);
-+BATADV_ATTR_HIF_BOOL(no_rebroadcast, S_IRUGO | S_IWUSR, NULL);
+ static BATADV_ATTR(iface_status, 0444, batadv_show_iface_status, NULL);
++BATADV_ATTR_HIF_BOOL(no_rebroadcast, 0644, NULL);
  #ifdef CONFIG_BATMAN_ADV_BATMAN_V
- BATADV_ATTR_HIF_UINT(elp_interval, bat_v.elp_interval, S_IRUGO | S_IWUSR,
+ BATADV_ATTR_HIF_UINT(elp_interval, bat_v.elp_interval, 0644,
  		     2 * BATADV_JITTER, INT_MAX, NULL);
-@@ -1130,6 +1188,7 @@ static BATADV_ATTR(throughput_override, S_IRUGO | S_IWUSR,
+@@ -1123,6 +1181,7 @@ static BATADV_ATTR(throughput_override, 0644, batadv_show_throughput_override,
  static struct batadv_attribute *batadv_batman_attrs[] = {
  	&batadv_attr_mesh_iface,
  	&batadv_attr_iface_status,
@@ -177,10 +177,10 @@ index 02d96f2..f91d09c 100644
  	&batadv_attr_elp_interval,
  	&batadv_attr_throughput_override,
 diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
-index b3dd1a3..9ee810d 100644
+index e913aee..da78f77 100644
 --- a/net/batman-adv/types.h
 +++ b/net/batman-adv/types.h
-@@ -156,6 +156,7 @@ struct batadv_hard_iface {
+@@ -173,6 +173,7 @@ struct batadv_hard_iface {
  	struct hlist_head neigh_list;
  	/* neigh_list_lock protects: neigh_list */
  	spinlock_t neigh_list_lock;
diff --git a/batman-adv/patches/1002-batman-adv-decrease-maximum-fragment-size.patch b/batman-adv/patches/1002-batman-adv-decrease-maximum-fragment-size.patch
index 011380e..cfe63ea 100644
--- a/batman-adv/patches/1002-batman-adv-decrease-maximum-fragment-size.patch
+++ b/batman-adv/patches/1002-batman-adv-decrease-maximum-fragment-size.patch
@@ -6,10 +6,10 @@ Subject: [PATCH] batman-adv: decrease maximum fragment size
  1 file changed, 1 insertion(+), 1 deletion(-)
 
 diff --git a/net/batman-adv/main.h b/net/batman-adv/main.h
-index 09af21e..23ebb8e 100644
+index a6cc804..5b78555 100644
 --- a/net/batman-adv/main.h
 +++ b/net/batman-adv/main.h
-@@ -167,7 +167,7 @@ enum batadv_uev_type {
+@@ -168,7 +168,7 @@ enum batadv_uev_type {
  /* Maximum number of fragments for one packet */
  #define BATADV_FRAG_MAX_FRAGMENTS 16
  /* Maxumim size of each fragment */
diff --git a/batman-adv/patches/1003-Add-compat-fallback-for-batadv_getlink_net.patch b/batman-adv/patches/1003-Add-compat-fallback-for-batadv_getlink_net.patch
index 23592e8..719f59d 100644
--- a/batman-adv/patches/1003-Add-compat-fallback-for-batadv_getlink_net.patch
+++ b/batman-adv/patches/1003-Add-compat-fallback-for-batadv_getlink_net.patch
@@ -6,12 +6,12 @@ Subject: [PATCH] Add compat fallback for batadv_getlink_net
  1 file changed, 4 insertions(+)
 
 diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
-index 08ce361..e6ea2f9 100644
+index b308048..075890e 100644
 --- a/net/batman-adv/hard-interface.c
 +++ b/net/batman-adv/hard-interface.c
 @@ -95,6 +95,9 @@ out:
- static const struct net *batadv_getlink_net(const struct net_device *netdev,
- 					    const struct net *fallback_net)
+ static struct net *batadv_getlink_net(const struct net_device *netdev,
+ 				      struct net *fallback_net)
  {
 +#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0)
 +	return fallback_net;
@@ -19,7 +19,7 @@ index 08ce361..e6ea2f9 100644
  	if (!netdev->rtnl_link_ops)
  		return fallback_net;
  
-@@ -102,6 +105,7 @@ static const struct net *batadv_getlink_net(const struct net_device *netdev,
+@@ -102,6 +105,7 @@ static struct net *batadv_getlink_net(const struct net_device *netdev,
  		return fallback_net;
  
  	return netdev->rtnl_link_ops->get_link_net(netdev);
